}}} tmpltss dproj
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <ProjectGuid>{073EFF39-7BE5-4E6F-897A-166A3AC1DEFD}</ProjectGuid>
        <MainSource>TMPLTSS.dpr</MainSource>
        <Base>True</Base>
        <Config Condition="'$(Config)'==''">Debug</Config>
        <TargetedPlatforms>1153</TargetedPlatforms>
        <AppType>Application</AppType>
        <FrameworkType>VCL</FrameworkType>
        <ProjectVersion>18.4</ProjectVersion>
        <Platform Condition="'$(Platform)'==''">Win32</Platform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Base)'=='true') or '$(Base_Win32)'!=''">
        <Base_Win32>true</Base_Win32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''">
        <Base_Win64>true</Base_Win64>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
        <Cfg_1>true</Cfg_1>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''">
        <Cfg_1_Win32>true</Cfg_1_Win32>
        <CfgParent>Cfg_1</CfgParent>
        <Cfg_1>true</Cfg_1>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
        <Cfg_2>true</Cfg_2>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='iOSDevice64' and '$(Cfg_2)'=='true') or '$(Cfg_2_iOSDevice64)'!=''">
        <Cfg_2_iOSDevice64>true</Cfg_2_iOSDevice64>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''">
        <Cfg_2_Win32>true</Cfg_2_Win32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base)'!=''">
        <DCC_DcuOutput>.\$(Platform)\$(Config)</DCC_DcuOutput>
        <DCC_ExeOutput>.\$(Platform)\$(Config)</DCC_ExeOutput>
        <DCC_UsePackage>FlexCel_Report;RESTBackendComponents;CloudService;FlexCel_XlsAdapter;soaprtl;RESTComponents;FlexCel_Pdf;emsclientfiredac;DataSnapFireDAC;FireDACIBDriver;emsclient;FireDACCommon;soapserver;FireDACCommonDriver;inet;FireDAC;FireDACSqliteDriver;FlexCel_Core;FlexCel_Render;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;$(DCC_Namespace)</DCC_Namespace>
        <Icon_MainIcon>$(BDS)\bin\delphi_PROJECTICON.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
        <SanitizedProjectName>TMPLTSS</SanitizedProjectName>
        <DCC_UnitSearchPath>units;CommonUnits;C:\Projects\_Externals\nativexml;CommonUnits\Synapse;$(D3P)\Source;$(BDSLIB)\$(Platform)\release;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.embarcadero.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_DcpOutput>.\$(Platform)\DCP</DCC_DcpOutput>
        <DCC_BplOutput>.\$(Platform)\BPL</DCC_BplOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win32)'!=''">
        <DCC_UsePackage>DBXSqliteDriver;DBXDb2Driver;vclactnband;vclFireDAC;cxExportRS25;dxHttpIndyRequestRS25;tethering;dxPScxCommonRS25;FireDACADSDriver;Kodak_Image_Edit;cxPivotGridOLAPRS25;JvPluginSystem;FireDACMSSQLDriver;vcltouch;JvBands;vcldb;Intraweb;svn;SKIA_FlexCel_Core;JvJans;cxLibraryRS25;JvDotNetCtrls;VCL_FlexCel_Components;vclib;AcroPDF;FireDACDBXDriver;Tee925;LproComponents;vclx;dxSpreadSheetConditionalFormattingDialogsRS25;TeeWorld925;VCLRESTComponents;dxPSLnksRS25;vclie;bindengine;dxFireDACServerModeRS25;JvHMI;FireDACMySQLDriver;DataSnapClient;bindcompdbx;ptEtsPanel;dxPSdxLCLnkRS25;IndyIPServer;DBXSybaseASEDriver;NxDBGridDsgn_dxe;IndySystem;dsnapcon;FireDACMSAccDriver;fmxFireDAC;TMYComp;vclimg;NxCommonDsgn_dxe;NxAddonsRun_dxe;Jcl;TeeMaker125;FireDACInfxDriver;emshosting;dxSpreadSheetRS25;dxPScxTLLnkRS25;DBXOdbcDriver;FireDACTDataDriver;cxGridRS25;dxSpreadSheetCoreConditionalFormattingDialogsRS25;DbxCommonDriver;JvManagedThreads;dxCloudServiceLibraryRS25;xmlrtl;JvTimeFramework;DataSnapNativeClient;fmxobj;PTExtPanels;D7MStreams;rtl;dxPScxGridLnkRS25;DbxClientDriver;DBXSybaseASADriver;X256PR50;dxPSCoreRS25;dxmdsRS25;JvSystem;JvStdCtrls;appanalytics;LockBox3DR;IndyIPClient;bindcompvcl;NxDBGridRun_dxe;FMX_FlexCel_Components;JvPascalInterpreter;JvDocking;VclSmp;FMXTee925;AUSComponents;FireDACODBCDriver;JclVcl;DataSnapIndy10ServerTransport;NxCommonRun_dxe;NxGridRun_dxe;DataSnapProviderClient;FireDACMongoDBDriver;cxVerticalGridRS25;JvControls;JvPrintPreview;PTZipCodeCityState;dxADOServerModeRS25;DataSnapServerMidas;dxCoreRS25;FMXTeeImport925;DBXInterBaseDriver;TeeDB925;FMX_FlexCel_Core;JvGlobus;svnui;JvMM;DBXMSSQLDriver;DatasnapConnectorsFreePascal;JOSE;bindcompfmx;JvNet;DBXOracleDriver;FMXTeePro925;inetdb;JvAppFrm;TeeImport925;emsedge;fmx;fmxdae;dxPScxPivotGridLnkRS25;PTCommon;JvWizards;PKBOOKMARK;FMXTeeLanguage925;dbexpress;IndyCore;FMXTeeDB925;addict4_d25;JvPageComps;dsnap;DataSnapCommon;NxCollectionRun_dxe;JvDB;DataSnapConnectors;dxPScxExtCommonRS25;cxPivotGridRS25;JclDeveloperTools;dxSpreadSheetReportDesignerRS25;dxPSdxSpreadSheetLnkRS25;HighLitePkg;JvCmp;DBXMySQLDriver;FireDACOracleDriver;DBXFirebirdDriver;NxInspectorDsgn_dxe;FireDACCommonODBC;LockBoxDR;cxTreeListRS25;IndyIPCommon;JvCustom;vcl;dxPScxVGridLnkRS25;PKIECtrl25;JvXPCtrls;TeeUI925;dxComnRS25;FireDACDb2Driver;dxSkinsCoreRS25;FmxTeeUI925;madExcept_;madBasic_;dxSpreadSheetCoreRS25;NxCollectionDsgn_dxe;JvCore;dxServerModeRS25;dxPScxPCProdRS25;JvCrypt;FireDACPgDriver;ibmonitor;TeePro925;TeeGL925;FireDACASADriver;addict4db_d25;Rave120VCL;ILCORP50;JvDlgs;JvRuntimeDesign;ibxpress;DataSnapServer;ibxbindings;NxGridDsgn_dxe;vclwinx;FireDACDSDriver;madDisAsm_;CustomIPTransport;vcldsnap;bindcomp;DBXInformixDriver;cxPivotGridChartRS25;dxDBXServerModeRS25;GW_Crap;dxGDIPlusRS25;dbxcds;VCL_FlexCel_Core;adortl;TeeImage925;NxSheetRun_dxe;TeeLanguage925;dsnapxml;dbrtl;inetdbxpress;IndyProtocols;JclContainers;NxInspectorRun_dxe;fmxase;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_Namespace>Winapi;System.Win;Data.Win;Datasnap.Win;Web.Win;Soap.Win;Xml.Win;Bde;VCLTee;Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;$(DCC_Namespace)</DCC_Namespace>
        <BT_BuildType>Debug</BT_BuildType>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <Manifest_File>$(BDS)\bin\default_app.manifest</Manifest_File>
        <DCC_UnitSearchPath>dcuout;$(D3P)\Win32\CommonDcu;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <DCC_DcuOutput>dcuout</DCC_DcuOutput>
        <DCC_ExeOutput>exe</DCC_ExeOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win64)'!=''">
        <Manifest_File>$(BDS)\bin\default_app.manifest</Manifest_File>
        <Icon_MainIcon>TMPLTSS_Icon.ico</Icon_MainIcon>
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1)'!=''">
        <DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
        <DCC_DebugInformation>0</DCC_DebugInformation>
        <DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
        <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2)'!=''">
        <DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
        <DCC_Optimize>false</DCC_Optimize>
        <DCC_GenerateStackFrames>true</DCC_GenerateStackFrames>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_iOSDevice64)'!=''">
        <BT_BuildType>Debug</BT_BuildType>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=;ProgramID=com.embarcadero.$(MSBuildProjectName)</VerInfo_Keys>
        <DCC_Define>madExcept;$(DCC_Define)</DCC_Define>
        <DCC_MapFile>3</DCC_MapFile>
        <Debugger_RunParams>/ini=DEVBAN /MASS2 /company=banner /test</Debugger_RunParams>
    </PropertyGroup>
    <ItemGroup>
        <DelphiCompile Include="$(MainSource)">
            <MainSource>MainSource</MainSource>
        </DelphiCompile>
        <DCCReference Include="units\tmpltssU.pas">
            <Form>Form1</Form>
        </DCCReference>
        <BuildConfiguration Include="Debug">
            <Key>Cfg_2</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
        <BuildConfiguration Include="Base">
            <Key>Base</Key>
        </BuildConfiguration>
        <BuildConfiguration Include="Release">
            <Key>Cfg_1</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
    </ItemGroup>
    <ProjectExtensions>
        <Borland.Personality>Delphi.Personality.12</Borland.Personality>
        <Borland.ProjectType/>
        <BorlandProject>
            <Delphi.Personality>
                <Source>
                    <Source Name="MainSource">TMPLTSS.dpr</Source>
                </Source>
                <Excluded_Packages>
                    <Excluded_Packages Name="C:\Projects\_Externals\Tokyo\Win32\BPL\LockBox3FMXDD250.bpl">TurboPack LockBox 3 FMX designtime package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcboffice2k250.bpl">Embarcadero C++Builder Office 2000 Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcbofficexp250.bpl">Embarcadero C++Builder Office XP Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dcloffice2k250.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dclofficexp250.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
                </Excluded_Packages>
            </Delphi.Personality>
            <Platforms>
                <Platform value="iOSDevice64">True</Platform>
                <Platform value="Linux64">True</Platform>
                <Platform value="Win32">True</Platform>
                <Platform value="Win64">False</Platform>
            </Platforms>
        </BorlandProject>
        <ProjectFileVersion>12</ProjectFileVersion>
    </ProjectExtensions>
    <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
    <Import Project="$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj" Condition="Exists('$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj')"/>
</Project>
}}}
object Form1: TForm1
  Left = 412
  Top = 190
  Caption = 
    'TMPLTSS: Copy Template to Output, subsituting some data from a P' +
    'rimary input CSV file.'
  ClientHeight = 197
  ClientWidth = 608
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  OnCreate = FormCreate
  OnDestroy = FormDestroy
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 608
    Height = 197
    Align = alClient
    TabOrder = 0
    object Label1: TLabel
      Left = 24
      Top = 112
      Width = 37
      Height = 13
      Caption = 'Status'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clWindowText
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = [fsBold, fsUnderline]
      ParentFont = False
    end
    object lStatus: TLabel
      Left = 24
      Top = 136
      Width = 100
      Height = 13
      Caption = 'Status Message here'
    end
    object Button1: TButton
      Left = 264
      Top = 64
      Width = 75
      Height = 25
      Caption = 'Run'
      TabOrder = 0
      OnClick = Button1Click
    end
  end
end
}}}
Unit tmpltssU;

// The main input file to this program is a .CSV file.  For each record
// that is read from the main input file, this program will open another input file
// (a Template file), and copy ALL of the rows from that to the TMPLTOUT file.  If while
// doing this, it sees that it has been asked to include some data from the current
// .CSV row into the Template record, it will do that data inclusion before writing
// the Template record to TMPLOUT file.
//
// Note: the user may have fully prepared our main input file... and if they did,
// that file is sitting in the main input directory - and it is called SPREADSHT.csv.
//
// If they didn't fully prepare it - they at least would have put their main input
// file into our main input directory...  So, this program checks for presence
// of SPREADSHT.csv... and if NOT present, then this program asks user to specify
// "which file in the input directory is the main input file for this run?"  It is
// doing this so that it then can prepare a file called SPREADSHT.csv... which will
// become the main data source that is referred to (to pick up data while we are
// processing the input Template files - bouncing them up against the main input
// spreadsheet).
//
//   CHANGE LOG:
//
//   INIT  CHGDATE  TAG      PURPOSE
//   --- ---------- ------   ---------------------------------------------------------------------------
//   GM :2022-03-01 SY6355 - add new pgm to help take in Spreadsheet based agent load data
//   GM :2022-03-25 SY6977/6978 - deal with EDJ data that is more diverse than thought
//   GM :2022-03-29 SY6355 - when last byte of input S rec (CSV) is comma, last col of data is not accessible
//   GM :2022-04-05 SY6355 - add edits of csv data which came from external party
//   GM :2022-06-23 SY6355 - add edit for proper LENGTH of a csv field: zip code (must be 5 in len)

Interface

Uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler,
  IdIOHandlerStream, adodb, db, DateUtils, ComCtrls, SABUtils, uLGAini, RunAFile,
  umapimail, ExtCtrls, DebenuPDFLibrary, uPDFtoTIF;

Type
  TForm1 = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Label1: tLabel;
    lStatus: tLabel;
    procedure FormCreate(Sender: TObject);
    Procedure FormShow(Sender: tObject);
    Procedure Button1Click(Sender: tObject);
    procedure FormDestroy(Sender: TObject);
  Private
    { Private declarations }
    Procedure Translate(Const SAV09: AnsiString; Const TMPLTYPE: AnsiString; Const LastLUV: AnsiString;
     Const tmpltnmI: AnsiString; Const x: Integer; Const workdir: AnsiString; Var xltResult: AnsiString);
    //
    Procedure CDEdits(Const Srec: AnsiString; Const STSL: tStringList;
     Const MHTSL: tStringList; Const HTSL: tStringList; Var CDEmsg: AnsiString);

    Procedure CkTHead(Const tmpltnmI: AnsiString; Const Trec: AnsiString; Const TTTSL: tStringList;
     Const UTTSL: tStringList; Const VTTSL: tStringList; Const WTTSL: tStringList; Var ISHEADR: AnsiString;
     Var HWRITE: AnsiString; Var TMPLTYPE: AnsiString; Var TILDE: AnsiString; Var SEP: AnsiString);

    //
  Public
    { Public declarations }
    log: ttextfileout;
    s, pfilenm, tfilenm: AnsiString;
    x: Integer;
    Function DtNow(DT: tDateTime): AnsiString;
  End;

Var
  Form1: TForm1;

Implementation

{$R *.dfm}

//    FUNCTIONS

Function TForm1.DtNow(DT: tDateTime): AnsiString;
Begin
  Result := EmptyStr;
  Result := datetostr(DT) + ' ' + timetostr(DT) + ': ';
End;

Function IsStrANumber(Const s: AnsiString): Boolean;
Var
  P: PAnsiChar;
Begin
  P := PAnsiChar(s);
  Result := False;
  While P^ <> #0 Do
  Begin
    If Not (P^ In ['0'..'9']) Then
      Exit;
    Inc(P);
  End;
  Result := True;
End;



function OccurrencesOfChar(const S: string; const C: char): integer;
var
  i: Integer;
begin
  result := 0;
  for i := 1 to Length(S) do
    if S[i] = C then
      inc(result);
end;






//   SUBROUTINES


// Substitute something in the Template rec with some data coming in from main spreadsheet
Procedure Substitute(Const HTSL: tStringList; Const invalue: AnsiString; Var CELLNUM: Integer);
Var
 R: Integer;
 V: Integer;
Label
  KEEPON, ONWARD;
Begin
  CELLNUM := 0;       //  set to zero
  //
  For R := 0 To HTSL.Count - 1 Do
    begin
      if HTSL[R] = invalue then
       begin
        CELLNUM := R;
        Break;
       end;
    end;
  //
End;







procedure Split(Delimiter: Char; Str: string; ListOfStrings: TStrings) ;
begin
   ListOfStrings.Clear;
   ListOfStrings.Delimiter       := Delimiter;
   ListOfStrings.StrictDelimiter := True; // Requires D2006 or newer.
   ListOfStrings.DelimitedText   := Str;
end;







// Special Srec edits for a CANDOTOAGFILE process
Procedure Tform1.CDEdits(Const Srec: AnsiString; Const STSL: tStringList;
 Const MHTSL: tStringList; Const HTSL: tStringList; Var CDEmsg: AnsiString);

Var
 DT1: AnsiString;
 DT2: AnsiString;
 DT3: AnsiString;
 CELLNUM: Integer;

Label
  RLEN, ROK, RINP, EXITNOW, CDColCntOK, VDTSOK, ADTSOK, LDTSOK, DDTSOK;

Begin
 If STSL.Count > 52 then Goto CDColCntOK;
 CDEmsg := 'too few columns';
 Goto EXITNOW;
 //
 CDColCntOK:
 Substitute(HTSL, '~VF', CELLNUM);
 DT2 := STSL[CELLNUM];
 Substitute(HTSL, '~VX', CELLNUM);
 DT3 := STSL[CELLNUM];
 if DT3 = '""' then DT3 := '';     // special case here - it is the furthest right column and had "" appended if null
 Substitute(HTSL, '~VS', CELLNUM);
 DT1 := STSL[CELLNUM];
 if (length(DT1) = 8) or (length(DT1) = 0) then
   if ((length(DT1)) = (length(DT2))) and ((length(DT1)) = (length(DT3))) then Goto VDTSOK;
 CDEmsg := 'has a date inconsistency: "' + MHTSL[CELLNUM] + '" or one of the two dt flds to right of it is blnk or bad format';
 Goto EXITNOW;
  //
 VDTSOK:
 Substitute(HTSL, '~AF', CELLNUM);
 DT2 := STSL[CELLNUM];
 Substitute(HTSL, '~AX', CELLNUM);
 DT3 := STSL[CELLNUM];
 Substitute(HTSL, '~AS', CELLNUM);
 DT1 := STSL[CELLNUM];
 if (length(DT1) = 8) or (length(DT1) = 0) then
  if ((length(DT1)) = (length(DT2))) and ((length(DT1)) = (length(DT3))) then Goto ADTSOK;
 CDEmsg := 'has a date inconsistency: "' + MHTSL[CELLNUM] + '" or one of the two dt flds to right of it is blnk or bad format';
  Goto EXITNOW;
 //
 ADTSOK:
 Substitute(HTSL, '~LF', CELLNUM);
 DT2 := STSL[CELLNUM];
 Substitute(HTSL, '~LX', CELLNUM);
 DT3 := STSL[CELLNUM];
 Substitute(HTSL, '~LS', CELLNUM);
 DT1 := STSL[CELLNUM];
 if (length(DT1) = 8) or (length(DT1) = 0) then
  if ((length(DT1)) = (length(DT2))) and ((length(DT1)) = (length(DT3))) then Goto LDTSOK;
 CDEmsg := 'has a date inconsistency: "' + MHTSL[CELLNUM] + '" or one of the two dt flds to right of it is blnk or bad format';
 Goto EXITNOW;
 //
 LDTSOK:
 Substitute(HTSL, '~DF', CELLNUM);
 DT2 := STSL[CELLNUM];
 Substitute(HTSL, '~DX', CELLNUM);
 DT3 := STSL[CELLNUM];
 Substitute(HTSL, '~DS', CELLNUM);
 DT1 := STSL[CELLNUM];
 if (length(DT1) = 8) or (length(DT1) = 0) then
  if ((length(DT1)) = (length(DT2))) and ((length(DT1)) = (length(DT3))) then Goto DDTSOK;
 CDEmsg := 'has a date inconsistency: "' + MHTSL[CELLNUM] + '" or one of the two dt flds to right of it is blnk or bad format';
 Goto EXITNOW;
 //
 DDTSOK:
 //
 Substitute(HTSL, '~NP', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~FN', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~LN', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~DB', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~GN', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~SS', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~TC', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~RD', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~ET', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~RC', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~P1', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~EB', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~B8', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~B1', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~B4', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~B5', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~B6', CELLNUM);
 if length(STSL[CELLNUM]) <> 5 then Goto RLEN;
 Substitute(HTSL, '~B7', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~R1', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~R4', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~R5', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~R6', CELLNUM);
 if length(STSL[CELLNUM]) <> 5 then Goto RLEN;
 Substitute(HTSL, '~R7', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~L2', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~L3', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~L4', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 Substitute(HTSL, '~LL', CELLNUM);
 if length(STSL[CELLNUM]) = 0 then Goto RINP;
 //
 Goto ROK;
 //
 RINP:
 CDEmsg := 'has a reqd field missing/empty: "' + MHTSL[CELLNUM] + '"';
 Goto EXITNOW;
  //
 RLEN:
 CDEmsg := 'has field with an invalid length: "' + MHTSL[CELLNUM] + '"';
 Goto EXITNOW;
 //
 ROK:
 //
EXITNOW:
//
End;






// Try to determine whether the current Template record (passed to this routine) is a Header record.  If so, set ISHEADR to Y.
Procedure Tform1.CkTHead(Const tmpltnmI: AnsiString; Const Trec: AnsiString; Const TTTSL: tStringList;
 Const UTTSL: tStringList; Const VTTSL: tStringList; Const WTTSL: tStringList; Var ISHEADR: AnsiString;
 Var HWRITE: AnsiString;  Var TMPLTYPE: AnsiString; Var TILDE: AnsiString; Var SEP: AnsiString);

Var
 P: Integer;
 XTSL: tStringList;
 tmatch: AnsiString;
 workbyte: AnsiString;
 ttype: AnsiString;
Label
  EXITNOW, NOTCT;
Begin
  // isolate stuff left of the equal sign (in TTTSL) row by row
  // match tmpltnmI to data that is in TTTSL
  // when find correct row in TTTSL, capture the file type info (right of the equal sign)
  // based on template type - do logic to see if the Trec we got as input is a Header
  // if it is a Header, then set ISHEADR to Y
  // exit
  //
  tmatch := 'N';     //  indicate, have not yet found a match to available template types
  ttype := '';       //  set template type to null
  TILDE := '';       //  set the tilde info to be null
  //
  For P := 0 To TTTSL.Count - 1 Do
    begin
      XTSL := tStringList.Create;
      Split('=', TTTSL[P], XTSL);
      if XTSL[0] = tmpltnmI then
       begin
        ttype := XTSL[1];
        HWRITE := UTTSL[P];
        TILDE := StringReplace(VTTSL[P], ';', ',', [rfReplaceAll]);     // the commas in the tilde info are stored in file as semicolons
        //
        SEP := '';
        if WTTSL[P] = 'COMMA' then SEP := ',';
        if WTTSL[P] = 'PIPE' then SEP := '|';
        //
        Break;
       end;
      XTSL.Free;
    end;
  //
  if ttype = '' then
   begin
     log.Write(DtNow(Now) + 'Sought Template Was Not in TEMPLATE_TYPES.CSV: ' + tmpltnmI);
     Application.ProcessMessages;
     Goto EXITNOW;
   end;
  //
  //  as more template types are added to TEMPLATE_TYPES, add code below to determine HEADER recd for that added type
  //
  TMPLTYPE := ttype;                     // send template type back to caller
  //
  if ttype <> 'CANDOTAGFILE' then Goto NOTCT;
  //
  workbyte := Copy(Trec, 1, 1);          // capture first byte of Trec
  If IsStrANumber(workbyte) = True Then Goto EXITNOW;
  ISHEADR := 'Y';
  Goto EXITNOW;
  //
  NOTCT:
  //
  //
  EXITNOW:
End;



// Based on the kind of data passed in, pass back a translated value if possible.
Procedure Tform1.Translate(Const SAV09: AnsiString; Const TMPLTYPE: AnsiString; Const LastLUV: AnsiString;
 Const tmpltnmI: AnsiString; Const x: Integer; Const workdir: AnsiString; Var xltResult: AnsiString);

Var
 W: Integer;
 XFile: TextFile;
 XTSL: tStringList;
 InptX: AnsiString;
 updated: AnsiString;
 LMX: AnsiString;
 Xrec: AnsiString;
Label
  SKIPX;
Begin
//  Begin
//  xltResult := '[xlt]';
//End;
//
  InptX := workdir + 'TRANSLATES.CSV';   // available translate values
  AssignFile(XFile, InptX);
  Reset(XFile);
  updated := 'N';
  LMX := '';
//
  While Not Eof(XFile) Do
   begin
     ReadLn(XFile, Xrec);
     XTSL := tStringList.Create;
     XTSL.Text := StringReplace(Xrec, ',', #13#10, [rfReplaceAll]);
     If (Copy(Xrec, 1, 1) = '*') then Goto SKIPX;
     // if input Translate guidance record has some apostrophes (to prevent loss of lead zeros), remove apostrophes
     XTSL[1] := StringReplace(XTSL[1], #39, '', [rfReplaceAll]);   // #39 is an apostrophe
     XTSL[2] := StringReplace(XTSL[2], #39, '', [rfReplaceAll]);   // replace apostrophe with null
     if TMPLTYPE <> XTSL[0] then Goto SKIPX;
     if trim(SAV09) <> trim(XTSL[1]) then Goto SKIPX;
     if LastLUV <> XTSL[2] then Goto SKIPX;      // LastLUV has "last picked-up value from main input sprdsht"
     xltResult := XTSL[3];
     updated := 'Y';
     break;
    SKIPX:
     XTSL.Free;
   end;
    CloseFile(XFile);
    if updated <> 'Y' then
      begin
        LMX := 'Template ' + tmpltnmI + ' of type ' + TMPLTYPE + ' line ' + IntToStr(x);
        LMX := LMX + ' seeks unsupported translate based on TRANSLATES.csv:';
        LMX := LMX + ' input value of ' + LastLUV + ' for field name of ' + SAV09 + ' not found.';
        log.Write(DtNow(Now) + LMX);
        Application.ProcessMessages;
      end;
End;





//        M A I N L I N E

Procedure TForm1.Button1Click(Sender: tObject);
Var
  FINALO, TFile, SFile, TTFile, OFile: TextFile;
  myCvalue: Integer;
  saveWTSLC: Integer;
  saveN: Integer;
  Treadcnt: Integer;
  Sreadcnt: Integer;
  GWrtCnt: Integer;
  CELLNUM: Integer;
  countspc: Integer;
  tempLen: Integer;
  N: Integer;
  E: Integer;
  SAV07: AnsiString;
  SAV08: AnsiString;
  SAV09: AnsiString;
  xltResult: AnsiString;
  tempfield: AnsiString;
  squished: AnsiString;
  spprule: AnsiString;
  sppresult: AnsiString;
  LastLUV: AnsiString;  // last look-up value (last piece of data we retrieved from main sprdsht)
  LM1: AnsiString;
  LMD: AnsiString;
  InptTT: AnsiString;
  ISHEADR: AnsiString;
  HWRITE: AnsiString;
  TILDE: AnsiString;
  SEP: AnsiString;
  TMPLTYPE: AnsiString;
  Sready: AnsiString;
  Grec: AnsiString;
  Trec: AnsiString;
  TTrec: AnsiString;
  Srec: AnsiString;
  OutpTNam: AnsiString;
  InptTNam: AnsiString;
  invalue: AnsiString;
  outvalue: AnsiString;
  openDialog: TOpenDialog;
  MHTSL, VTTSL, WTTSL, FworkTSL, SPPTSL, STSL, WorkTSL, HTSL, TTTSL, UTTSL, TTYPESTSL: tStringList;
  tmpltnmI: AnsiString;
  tmpltnmO: AnsiString;
  Lcellzero: Integer;
  InptFNam: AnsiString;
  TmpltNam: AnsiString;
  InptSNam: AnsiString;
  spac4: AnsiString;
  spac6: AnsiString;
  spac50: ShortString;
  spac1000: AnsiString;
  MSGRETN: Integer;
  WRTCT: Integer;
  DOPRT: AnsiString;
  CHPN: AnsiString;                                   // To be able to pass the participant number from the Contra Header to grid-build
  LRcvrPN: AnsiString;                                // LNA participant number of the Carrier who received the prior transaction
  CURpNUM: AnsiString;                                // LNA participant number of the requesting Broker/Dealer
  CRcvrPN: AnsiString;                                // LNA participant number of the Carrier who received this transaction
  CURseqnc: AnsiString;                               // LNA 53xx sequence from original LNA file
  CURrtyp: AnsiString;                                // Has data like B53xx
  CURfid: AnsiString;                                 // Has 3-byte field ID
  CURkey: AnsiString;                                 // key is made up of the B53xx + field ID
  CURfloc: AnsiString;                                // location within the 53xx recd where data came from
  CURflen: AnsiString;                                // len of the data taken from the 53xx record
  CURffmt: AnsiString;                                // dtcc-specified format of the data from the LNA 53xx rec
  CURfnam: AnsiString;                                // field label/name
  CURdtyp: AnsiString;                                // data type (A: agt level;  C: contact info;   S: state levl)
  CURrcf: AnsiString;                                 // RR.COL value for FC (sequential) output file
  CURrcs: AnsiString;                                 // RR.COL value for the FS (sequential) output file
  CURrpa: AnsiString;                                 // RR.COL value for the plotter / page-painter (grid) oput file #1
  CURcra: AnsiString;                                 // Collision Rule
  CURula: AnsiString;                                 // sw saying whether to include field label in grid oput
  CURuxa: AnsiString;                                 // sw saying whether to use transltn result field in grid oput
  CURfla: AnsiString;                                 // sw saying to reserve left side of line (make it unusable) when it is currently set to blanks
  CURrpb: AnsiString;                                 // RR.COL value for grid 2
  CURcrb: AnsiString;                                 // grid 2 collision rule
  CURulb: AnsiString;                                 // grid 2 'use label' switch
  CURuxb: AnsiString;                                 // grid 2 'use translation result' switch
  CURflb: AnsiString; // grid 2 sw saying to reserve left side of line (make it unusable) when it is currently set to blanks
  CURda: AnsiString;                                  // pre-translate (raw data) from the dtcc LNA 53xx record
  CURdb: AnsiString;                                  // translated value (if no translate applies, then this field has the raw data from the LNA rec)
  Data: AnsiString;
  FCOL, SCOL, P1COL, P2COL, P1ROW, P2ROW: Integer;
  G1POSTS: Integer;                               // num of updates made to Grid1 with something other than 'blanks' in the posted data field
  G2POSTS: Integer;                               // num of updates made to Grid2 with something other than 'blanks' in the posted data field
  P1swOK, P2swOK: AnsiString;
  P2LSTkey, P1LSTkey, FLSTkey, SLSTkey: AnsiString;
  G1PC, G2PC: AnsiString;
  G1PCN, G2PCN: Integer;
  G1OBL, G2OBL: AnsiString;
  LSTseqnc: AnsiString;
  WRTSETNO: AnsiString;
  SETNO: Integer;
  TRXCD: AnsiString;
  LSTTRXCD: AnsiString;
  TROKTOGO: AnsiString;
  G1TROKAY: AnsiString;                               // the set of LNA transactions acceptable to be processed into Grid 1
  G2TROKAY: AnsiString;                               // the set of LNA transactions acceptable to be processed into Grid 2
  records: longint;
  fileDate: Integer;
  rc: Integer;
  SrtIFils, SrtOFil: AnsiString;
  today: tDateTime;
  CurDt: String;
  QP: TDebenuPDFLibrary;
  CURDOCNO: AnsiString;
  AnswrPN: AnsiString;
  LSTDOCNO: AnsiString;
  workdir, tifdir, xtifdir: AnsiString;
  TIFPARMS: AnsiString;
  OTEXT: AnsiString;
  PDStartd: AnsiString;
  RECNO: AnsiString;
  LRECWD: AnsiString;
  OFSETNO: Integer;
  Emsg: AnsiString;
  workosn: AnsiString;
  zros10: AnsiString;
  LusedOF: AnsiString;
  ol: toutlookmail;
  fontID1, I: Integer;
  strg : AnsiString;
  COMPANY: AnsiString;
  COTXT: AnsiString;
  Z : integer;
  wfolder: AnsiString;
  dtstring: AnsiString;
  CDEmsg: AnsiString;

Label
  ISDETAIL, GoASIS, SKIPPDX, NOSPP, NOHEAD, SKIPs, SKIPt, SKIPtt, NEXTREC, NOTHEAD, NEXTONE, NOT07A;

Begin
  lStatus.Caption := 'tmpltss started';
  Application.ProcessMessages;
  Button1.Enabled := False;
  //
  // set Grid print control parameter defaults
  G1PC := '   ';
  G2PC := '   ';
  G1PCN := 99;
  G2PCN := 99;
  G1OBL := 'N';
  G2OBL := 'N';
  G1POSTS := 0;
  G2POSTS := 0;
  SETNO := -1;
  TRXCD := '  ';
  LSTTRXCD := '  ';
  LSTseqnc := '';
  LRcvrPN := '    ';                              // default this participant number field to blanks
  zros10 := '0000000000';
  //
  P1swOK := '1';                                  //  indicate that the Grid-oriented (plotter) output file is in fine status currently
  P2swOK := '2';
  spac4 := AnsiString(stringofchar(' ', 4));
  spac6 := AnsiString(stringofchar(' ', 6));
  spac50 := AnsiString(stringofchar(' ', 50));
  spac1000 := AnsiString(stringofchar(' ', 1000));
  //
  DateTimeToString(CurDt, 'yyyymmddhhnnsszz', Now);
  today := Now;
//  CurDt := FormatDateTime('ddddd', today);        // CurDt will now have f format like this:  05/31/2000
//  WorkTSL := tStringList.Create;
//  WorkTSL.Text := StringReplace(CurDt, '/', #13#10, [rfReplaceAll]); // Split the date value into it's sub-components (all are 'AnsiString' components)
//  If Length(WorkTSL[0]) < 2 Then
//    WorkTSL[0] := '0' + WorkTSL[0];
//  If Length(WorkTSL[1]) < 2 Then
//    WorkTSL[1] := '0' + WorkTSL[1];
//  CurDt := WorkTSL[2] + WorkTSL[0] + WorkTSL[1];     // CurDt will now have format like this: 20000531
//  WorkTSL.Free;
 //
  COMPANY := '';
  If (findcmdlineswitch('company=banner') or findcmdlineswitch('Company=Banner') or findcmdlineswitch('COMPANY=BANNER')) Then
    begin
      COMPANY := '17';
      COTXT := 'Banner';
    end;
  If (findcmdlineswitch('company=penn') or findcmdlineswitch('Company=Penn') or findcmdlineswitch('COMPANY=PENN')) Then
    begin
      COMPANY := 'WP';
      COTXT := 'Penn';
    end;
 //
  if COMPANY = '' then
    begin
      lStatus.Caption := 'Run parameter for COMPANY is missing (example /company=banner).  ABORTING NOW';
      Application.ProcessMessages;
      ShowMessage('JOB FAILED WHEN SETTING COMPANY VALUE - CALL SUPPORT');
      close;
      Halt(0);
    end;
 //
 If findcmdlineswitch('MASS') Then
  begin
   wfolder := 'MASS';
   workdir := LGAIni.ReadString(COTXT, 'Workarea', '') + 'MASS\Control\';
   log := ttextfileout.Create(Format('%sTmpltSS_%s.log', [WorkAreaUNC + 'MASS\Log\', CurDt]));
   log.Write(DtNow(Now) + 'Begin TmpltSS program.');
   log.Write(DtNow(Now) + 'Exec parm says to work in folder: MASS\CONTROL');
   lStatus.Caption := 'Exec parm says to work in folder: MASS\CONTROL';
   Application.ProcessMessages;
  end;
 If findcmdlineswitch('MASS1') Then
  begin
   wfolder := 'MASS1';
   workdir := LGAIni.ReadString(COTXT, 'Workarea', '') + 'MASS1\Control\';
   log := ttextfileout.Create(Format('%sTmpltSS_%s.log', [WorkAreaUNC + 'MASS1\Log\', CurDt]));
   log.Write(DtNow(Now) + 'Begin TmpltSS program.');
   log.Write(DtNow(Now) + 'Exec parm says to work in folder: MASS1\CONTROL');
   lStatus.Caption := 'Exec parm says to work in folder: MASS1\CONTROL';
   Application.ProcessMessages;
  end;
 If findcmdlineswitch('MASS2') Then
  begin
   wfolder := 'MASS2';
   workdir := LGAIni.ReadString(COTXT, 'Workarea', '') + 'MASS2\Control\';
   log := ttextfileout.Create(Format('%sTmpltSS_%s.log', [WorkAreaUNC + 'MASS2\Log\', CurDt]));
   log.Write(DtNow(Now) + 'Begin TmpltSS program.');
   log.Write(DtNow(Now) + 'Exec parm says to work in folder: MASS2\CONTROL');
   lStatus.Caption := 'Exec parm says to work in folder: MASS2\CONTROL';
   Application.ProcessMessages;
  end;
 //
 {
  openDialog := TOpenDialog.Create(self);
  openDialog.InitialDir := GetCurrentDir;
  openDialog.Options := [ofFileMustExist];
  openDialog.Filter := ' CSV files|*.csv';
  workdir := openDialog.InitialDir;             //   THE VALUE OF workdir WILL NEED TO CHANGE ONCE WE ARE BEYOND UNIT TESTING
  if openDialog.Execute then
    begin
     FworkTSL := TStringList.Create;
     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
     InptFNam := FworkTSL[FworkTSL.Count - 1];
     Showmessage('Selected File:' + InptFNam);
    end
   else
    begin
     ShowMessage('File Selection Cancelled; Run Aborted !');
     Halt(0);
    end;
  }
  //
  // save possible template types into TTTSL now
  //
  If Not FileExists(workdir + 'TEMPLATE_TYPES.CSV') Then
  Begin
    log.Write(DtNow(Now) + 'File missing ' + workdir + 'TEMPLATE_TYPES.CSV');
    ShowMessage('HALTING NOW!   Required input file is not found: TEMPLATE_TYPES.CSV');
    close;
    Halt(0);
  End;
  //
  InptTT := workdir + 'TEMPLATE_TYPES.CSV';   // available template names
  AssignFile(TTFile, InptTT);
  Reset(TTFile);
  E := 0;
  TTTSL := tStringList.Create;
  UTTSL := tStringList.Create;
  VTTSL := tStringList.Create;
  WTTSL := tStringList.Create;
  While Not Eof(TTFile) Do
   begin
    ReadLn(TTFile, TTrec);
    If (Copy(TTrec, 1, 1) = '*') then Goto SKIPtt;
    TTrec := stringreplace(TTrec, ',', '=', [rfIgnoreCase]);    // replace first comma with eq sign
    TTYPESTSL := tStringList.Create;
    TTYPESTSL.Text := StringReplace(TTrec, ',', #13#10, [rfReplaceAll]);
    TTTSL.Append(TTYPESTSL[0]);
    UTTSL.Append(TTYPESTSL[1]);
    WTTSL.Append(TTYPESTSL[2]);    // delimiter info
    VTTSL.Append(TTYPESTSL[3]);    // the "tilde" values (for collumn names) used with a spreadsheet referred to by this template type
    TTYPESTSL.Free;
    inc(E);
    SKIPtt:
   end;
  CloseFile(TTFile);
  //
  //  The user of this program MAY have already prepared the main input file (a csv).  If they DID,
  //  then they had to call it this name:  SPREADSHT.CSV.    At or near the top of their file, they
  //  had to put a TILDE row, too.   That row of special tilde values is used by this program to
  //  look up stuff from the main spreadsheet, and include that data into the created output file.
  //
  //  BUT - maybe user did NOT yet prepare that main inpt file (spreadsht.csv).
  //  if they did not yet prepare the file completely, then the next bit of code will try to
  //  set up the spreadsht.csv for them... by asking them which file in the input directory
  //  is the main input file they want to read in.   It has to be a CSV file.
  //
  //  If this dialogue with the user IS needed, then we also will ask the user to choose
  //  from the list of available TEMPLATE files (we then match that up to Template Types
  //  data - and this tells us "what kind of file we will be constructing").  Having
  //  this then also allows us to pick up the proper TILDE row data...
  //
  //  This Tilde row info is important.   It is what provides a column name to the columns that
  //  are in the main input spreadsheet.   This Tilde row is written out as the FIRST record in
  //  the SPREADSHT.CSV that this logic builds.
  //
  If FileExists(workdir + 'SPREADSHT.CSV') Then
   begin
      LMD := 'Unknown';
      fileDate := FileAge(workdir + 'SPREADSHT.CSV');
      if fileDate > -1 then LMD := DateToStr(FileDateToDateTime(fileDate));
      LM1 := 'SPREADSHT.CSV (last modified ' + LMD + ') was in directory upon pgm start';
      lStatus.Caption := LM1;
      log.Write(DtNow(Now) + LM1);
      Application.ProcessMessages;
      //
      MSGRETN := Application.MessageBox('Sure you want to process SPREADSHT.CSV?', 'DOUBLE CHECK INPUT csv FILE', MB_YESNO);
      if MSGRETN = 6 then
        begin
          lStatus.Caption := 'User clicked YES to After-checking-input-file-do-you-want-to-continue?';
          log.Write(DtNow(Now) + 'User clicked YES to After-checking-input-file-do-you-want-to-continue?');
          Application.ProcessMessages;
          Goto GoASIS;
        end
       else
        begin
          lStatus.Caption := 'User clicked NO to After-checking-input-file-do-you-want-to-continue?';
          log.Write(DtNow(Now) + 'User clicked NO to After-checking-input-file-do-you-want-to-continue?');
          Application.ProcessMessages;
          Halt;
        end;
   end;
  //
  //  So, this next code is only done IF the user didn't fully set up the main input file
  //  (called SPREADSHT.CSV).  We now will have a dialogue with the user - to learn WHICH csv
  //  in the input directory is the MAIN input for this run.  We'll use the data in that csv
  //  to create SPREADSHT.CSV.  In creating the SPREADSHT.CSV file, we need to put into
  //  that file - as the TOP record - the Tilde column headers name record... which is data
  //  that is stored in TEMPLATE_TYPES.
  //
  openDialog := TOpenDialog.Create(self);
  openDialog.InitialDir := workdir;
  openDialog.Options := [ofFileMustExist];
  openDialog.Filter := ' CSV files|*.csv';
  //
  //
  ShowMessage('When you click OK, you will then be asked to select MAIN input file for this run.');
  lStatus.Caption := 'User is asked to SELECT MAIN INPUT FILE NOW';
  Application.ProcessMessages;
  //
  //
  if openDialog.Execute then
    begin
     FworkTSL := TStringList.Create;
     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
     InptFNam := FworkTSL[FworkTSL.Count - 1];
     FworkTSL.free;
    end
   else
    begin
     lStatus.Caption := 'User canceled run instead of selecting Primary Input file.';
     log.Write(DtNow(Now) + 'User canceled run instead of selecting Primary Input file.');
     Application.ProcessMessages;
     ShowMessage('Primary Input file not provided; Run Aborted !');
     Halt(0);
    end;
  //
  log.Write(DtNow(Now) + 'User-selected MAIN input file is: ' + InptFNam);
  lStatus.Caption := 'Selected input file is:' + InptFNam;
  ShowMessage('Now, please select WHICH TEMPLATE SHOULD BE USED');
  lStatus.Caption := 'User is asked WHICH TEMPLATE TO USE';
  Application.ProcessMessages;
  //
  openDialog := TOpenDialog.Create(self);
  openDialog.InitialDir := workdir;
  openDialog.Options := [ofFileMustExist];
  openDialog.Filter := ' TMP (Template) files|TMP_*.*';
  //
  if openDialog.Execute then
    begin
     FworkTSL := TStringList.Create;
     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
     TmpltNam := FworkTSL[FworkTSL.Count - 1];
     FworkTSL.free;
    end
   else
    begin
     lStatus.Caption := 'User canceled run instead of selecting a Template.';
     log.Write(DtNow(Now) + 'User canceled run instead of selecting a Template.');
     Application.ProcessMessages;
     ShowMessage('Template File Selection Cancelled; Run Aborted !');
     Halt(0);
    end;
  //
  log.Write(DtNow(Now) + 'User-selected template file is: ' + TmpltNam);
  lStatus.Caption := 'Selected template file is:' + TmpltNam;
  Application.ProcessMessages;
  //
  HWRITE := 'N';          // default to N
  ISHEADR := 'N';         // default to N
  TMPLTYPE := '';         // default this to null
  TILDE := '';            // default this to null
  //
  CkTHead(TmpltNam, spac1000, TTTSL, UTTSL, VTTSL, WTTSL, ISHEADR, HWRITE, TMPLTYPE, TILDE, SEP);   // go set the TILDE info
  //
  OutpTNam := workdir + 'SPREADSHT.CSV';
  AssignFile(OFile, OutpTNam);
  ReWrite(OFile);
  //
  WriteLn(OFile, TILDE);
  //
  InptSNam := workdir + InptFNam;        // user-selected main input file
  AssignFile(SFile, InptSNam);
  Reset(SFile);
  //
  While Not Eof(SFile) Do                // copy user-selected data to SPREADSHT.CSV which we are constructing
   Begin
    ReadLn(SFile, Srec);                 // copy Srecs from provided "main input file" to file we are creating (called SPREADSHT)
    //                                   // but, while we are copying - we will also update first col - to include template file name
    Z:=Pos(',',Srec);                                                   // find the in-row position of the first comma
    //
    Grec := TrimLeft(Srec);              // take any spaces out of left side of an Srec
    if copy(Grec, 1, 1) = ',' then       // if detail row, then add name of template to be used into first column
     begin
      WriteLn(OFile, '~' + TmpltNam + copy(Srec, Z, (Length(Srec) - Z + 1))); // wrt our updated version of this Srec (has template file name in first collumn)
     end
    else
     begin
      WriteLn(OFile, Srec);              //  if NOT a detail row (or if a template value was plugged in already), then leave Srec as it is and write it out
     end;
    //
   End;
  Grec := '';
  CloseFile(SFile);
  CloseFile(Ofile);
  //
  //
 GoASIS:
  //
  ///////////////////////////////////////////////////////////////////////////////////////
  // Pre-Delete on the output files
  ///////////////////////////////////////////////////////////////////////////////////////
  //
  InptSNam := workdir + 'SPREADSHT.CSV';        // main input into this program is a spreadsheet (a csv)
  Sreadcnt := 0;                                // counter of spreadsheet file reads
  AssignFile(SFile, InptSNam);
  Reset(SFile);
  //
  // set log messages
  lStatus.Caption := 'Pre-Delete of Outputs needed by ' + InptSNam;
  log.Write(DtNow(Now) + 'Pre-Delete of Outputs needed by ' + InptSNam);
  Application.ProcessMessages;
  //
  Sready := 'N';     // indicate that we have not yet encountered the tilde record
  //
  While Not Eof(SFile) Do
   Begin
    ReadLn(SFile, Srec);
    STSL := tStringList.Create;
    STSL.Text := StringReplace(Srec, ',', #13#10, [rfReplaceAll]);
    //
    Lcellzero := Length(STSL[0]);      // get data len of the data in cell zero of this S row
    //
    // if dont yet have cell addressability to spreadsheet items, see if we have encountered the S rec that provides that
    If Sready = 'N' then
     begin
      If (Copy(STSL[0], 1, 1) = '~') and (Lcellzero < 6) then
       begin
        Sready := 'Y';                 // indicate that we now have addressability info for S
        HTSL := tStringList.Create;
        HTSL.Text := StringReplace(Srec, ',', #13#10, [rfReplaceAll]);  // save string list of cell addressability/names
        Goto SKIPPDX;
       end;
     end;
    //
    // in each significant (non-header) row of the incoming main spreadsheet, col zero has "what template file are we to use?"  sample: ~A.csv would tell us that template A.csv is to be used
    If (Copy(STSL[0], 1, 1) <> '~') OR (Sready = 'N') then Goto SKIPPDX;   // if col zero data doesnt begin with tilde, then no template info is in this rec - so, bypass this rec
    //
    tmpltnmI := Copy(STSL[0], 2, Lcellzero - 1);  // capture the in-spreadsheet-row template name
    //tmpltnmO := Copy(tmpltnmI, 1, Length(tmpltnmI) - 4) + '_OUTPUT' + Copy(tmpltnmI, Length(tmpltnmI) - 4 + 1, 4); // set OUTPUT file name for use with this template
    tmpltnmO := Copy(tmpltnmI, 1, Length(tmpltnmI) - 4) + '_OUTPUT_' + CurDt + Copy(tmpltnmI, Length(tmpltnmI) - 4 + 1, 4); // set OUTPUT file name for use with this template
    //
    If FileExists(workdir + tmpltnmO) Then
     begin
      DeleteFile(workdir + tmpltnmO);
      log.Write(DtNow(Now) + 'Doing pre-delete of output file:' + tmpltnmO);
      Application.ProcessMessages;
     end;
    //
  SKIPPDX:
   STSL.Free;
   End;
  //
  /////////////////////////////////////////////////////////////////////////////////////////////
  //
  tmpltnmI := '';
  tmpltnmO := '';
  Lcellzero := 0;
  //
  if Sready = 'N' then
   begin
    log.Write(DtNow(Now) + 'NO TILDE RECORD IN SPREADSHT.CSV - HALTING NOW!');
    Application.ProcessMessages;
    ShowMessage('NO TILDE COLLUMN IDENTIFIER RECD IN SPREADSHT.CSV - HALTING NOW!');
    close;
    Halt(0);
   end;
  /////////////////////////////////////////////////////////////////////////////////
  //
  //   Now, read through each SPREADSHT.CSV record - and for each row, use
  //   the specified template file to create some outputs, as needed.
  //
  // Note: this program copies Template rows to an output for that Template type.
  // As it is doing that, it will include some data from the main input spredsht
  // as needed (a spreadsheet (actually a csv) lookup).  For each read (main) spreadsht
  // row - we open-append the appropriate output file (the output file that goes with
  // that specified "template").  In this way, these output files grow and grow
  // as more and more input rows (from the main sprdsht) are seen/processed.
  //
  ///////////////////////////////////////////////////////////////////////////////////
  //
  Reset(SFile);                      // now re-open the main input csv for input
  //
  // set log messages
  lStatus.Caption := 'Reading ' + InptSNam;
  log.Write(DtNow(Now) + 'Reading ' + InptSNam);
  Application.ProcessMessages;
  //
  GWrtCnt := 0;  // indicate that NO writes of "G" records have occurred yet
  //
  While Not Eof(SFile) Do
   Begin
    ReadLn(SFile, Srec);
    Inc(Sreadcnt);
    //
    if Copy(Srec[Length(Srec)], 1, 1) = ',' then Srec := Srec + '""';     // if last byte of a CSV rec is a comma, then last col not accessible without this
    //
    //  Main input into this program is a sprdsht (csv) of data values - which can be referred to by tilde fields from Template recds.
    //  For this pgm to work right, a row had to be added at top of that main input sprdsht - which "names" the columns to those tilde values
    //  That main input spreadsht row which has the tilde "column names" is put into the HTSL tstringlist below.
    //
    STSL := tStringList.Create;
    STSL.Text := StringReplace(Srec, ',', #13#10, [rfReplaceAll]);
    //
    //                                 // leftmost column of the spreadshet has a fld to tell us which template to use
    Lcellzero := Length(STSL[0]);      // get data len of the data in cell zero of this S row
    //
    If (Copy(STSL[0], 1, 1) = '~') and (Lcellzero < 6) then Goto SKIPs;  // this looks like the tilde recd... skip it
    //
    If Copy(STSL[0], 1, 1) = '~' then Goto ISDETAIL;                     // if this sprdsht row cell zero starts w tilde, it is a detail recd
    MHTSL := tStringList.Create;
    MHTSL.Text := STSL.Text;
    Goto SKIPs;
    //
   ISDETAIL:
    //
    // Okay... the incoming S record is a Detail S record... so, process it
    //
    //
    // A few Edits of the input data (primary input CSV) occur now....
    //
    if TMPLTYPE = 'CANDOTAGFILE' then
     begin
      CDEmsg := '';
      CDEdits(Srec, STSL, MHTSL, HTSL, CDEmsg);           // go do special Srec data edits for a CANDOTAGFILE situation
      if CDEmsg <> '' then
       begin
        lStatus.Caption := 'HALTING RUN NOW! Data row ' + IntToStr(Sreadcnt - 1) + ' of main input file ' + CDEmsg;
        log.Write(DtNow(Now) + 'HALTING RUN NOW! Data row ' + IntToStr(Sreadcnt - 1) + ' of main input file ' + CDEmsg);
        Application.ProcessMessages;
        ShowMessage('JOB FAILED FOR DATA INCONSISTENCY - SEE LOG - CALL SUPPORT');
        close;
        Halt(0);
       end;
     end;
    //
    tmpltnmI := Copy(STSL[0], 2, Lcellzero - 1);                         // capture the in-spreadsheet-row template name
    //
    //tmpltnmO := Copy(tmpltnmI, 1, Length(tmpltnmI) - 4) + '_OUTPUT' + Copy(tmpltnmI, Length(tmpltnmI) - 4 + 1, 4); // set OUTPUT file name for use with this template
    tmpltnmO := Copy(tmpltnmI, 1, Length(tmpltnmI) - 4) + '_OUTPUT_' + CurDt + Copy(tmpltnmI, Length(tmpltnmI) - 4 + 1, 4); // set OUTPUT file name for use with this template
    //
    // set the name of the template that needs to be opened - and open that input fle
    InptTNam := workdir + tmpltnmI;
    AssignFile(TFile, InptTNam);
    Reset(TFile);
    //
    // set output file name for the above Template and open this output (if file exists, open append)
    OutpTNam := workdir + tmpltnmO;
    AssignFile(OFile, OutpTNam);
    If FileExists(OutpTNam) Then
      Append(OFile)
    else
      ReWrite(OFile);
    //
    Treadcnt := 0;                                // counter of template file reads
    x := 0;
    While Not Eof(TFile) Do
      Begin
        Inc(x);
        //
        ReadLn(TFile, Trec);
        //
        HWRITE := 'N';          // assume that - even if it IS a header - we are NOT going to write it out
        ISHEADR := 'N';         // assume that the current Template record we have read is NOT a Header record
        TMPLTYPE := '';         // default this to null
        TILDE := '';            // default this to null
        SEP := '';              // default separator/delimiter to n/a
        //
        //
        // parameters sent to CkTHead are:   a) name of template in use (as set by first cell of S rec)
        //                                   b) the curret Trec (record read from the Template file)
        //                                   c) TTTSL is the stringlist containing known template types
        //                                   d) UTTSL is additional data for each of those templates
        //                                   e) ISHEADR is the switch that CkTHead will set to Y if/when it determines that Trec is a 'header'
        //                                   f) HWRITE is to let mainline know whether Header should be written - and when / how often
        //                                   g) TMPLTYPE tells mainline "what kind of file" is being constructed
        //                                   h) Separator/Delimiter value for columns in Template (if any)
        CkTHead(tmpltnmI, Trec, TTTSL, UTTSL, VTTSL, WTTSL, ISHEADR, HWRITE, TMPLTYPE, TILDE, SEP);  // check this line and set info
        //
        if ISHEADR <> 'Y' then Goto NOHEAD;
        //
        if (HWRITE = 'ALL') then
        begin
          WriteLn(OFile, Trec);
          Goto SKIPt;
        end;
        //
        if (ISHEADR = 'Y') and (GWrtCnt = 0) and (HWRITE = 'TOP') then
        begin
          WriteLn(OFile, Trec);
          Goto SKIPt;
        end;
        //
        if ISHEADR = 'Y' then Goto SKIPt;
        //
        NOHEAD:
        //
        WorkTSL := tStringList.Create;
        Treadcnt := Treadcnt + 1;
        //
        WorkTSL.Text := StringReplace(Trec, SEP, #13#10, [rfReplaceAll]);
        //
        Grec := WorkTSL[0];
        //
        For N := 1 To WorkTSL.Count - 1 Do
         Begin
          If (Copy(WorkTSL[N], 1, 1) = '~') Then
           Begin
            outvalue := '';
            invalue := WorkTSL[N];
            //
            spprule := '';
            sppresult := '';
            if length(invalue) > 3 then
             Begin
               SPPTSL := tStringList.Create;
               Split('/', invalue, SPPTSL);
               WorkTSL[N] := SPPTSL[0];          // shrink this to be only the column specifier (3-pos value)
               invalue := WorkTSL[N];
               spprule := SPPTSL[1];             //  .. and this is everything RIGHT of the / in that template SS reference
               SPPTSL.free;
               SPPTSL := tStringList.Create;
               Split('=', spprule, SPPTSL);      // now, we need to further split that info that was right of the /
               spprule := SPPTSL[0];             //  .. stuff LEFT of the equal sign is the 'rule' value
               sppresult := SPPTSL[1];           //    .. and stuff RIGHT of the equal sign is the 'result' part
               SPPTSL.free;
              End;
            //
            Substitute(HTSL, invalue, CELLNUM);  // now, determine the column we'll need when accessing sprdsht data
            //
            WorkTSL[N] := STSL[CELLNUM];         // for now, we'll put the related spreadsheet data into this location
            //
            if length(spprule) = 0 then Goto NOSPP;  // if no special processing to apply, then skip this part
            //
            tempLen := Length(WorkTSL[N]);                     // the length of the data we just got from S record
            countspc := OccurrencesOfChar(WorkTSL[N], ' ');    // the count of spaces in the data item is put into field countspc
            //
            if spprule = 'IFBLANK' then
              begin
              if (tempLen = 0) OR (countspc = tempLen) then    // fld empty or all 'spaces'...    // fld empty or all 'spaces'...
                 begin
                   WorkTSL[N] := sppresult;          // template said to move this in place if blanks or empty
                   if (TMPLTYPE = 'CANDOTAGFILE') and (N > 22) and (Length(sppresult) = 0) then WorkTSL[N] := ' ';
                 end;
              end;
            //
            if spprule = 'IFNONBLANK' then
              begin
               if countspc <> length(WorkTSL[N]) then
                 begin
                   WorkTSL[N] := sppresult;          // template said to move this in place if NOT blanks or empty
                   if (TMPLTYPE = 'CANDOTAGFILE') and (N > 22) and (Length(sppresult) = 0) then WorkTSL[N] := ' ';
                 end;
              end;
            //
            NOSPP:
            //
            LastLUV := WorkTSL[N];               // save off the value we have looked up and used from sprdsht
            //
            //   LNAPLOT is not fond of some of these fields coming in as truly 'empty'...
            if (TMPLTYPE = 'CANDOTAGFILE') and (N > 22) and (Length(LastLUV) = 0) then
              begin
                WorkTSL[N] := ' ';
                LastLUV := ' ';
              end;
            //      note: if/when we make the below FixLen routine, the immed above may can go away
            //FixLen(WorkTSL, N, TMPLTYPE);      // adjust len of the received data item if we must
            //
            if CELLNUM = 0 then
             Begin
              LM1 := 'Template ' + tmpltnmI + ' has unresolveable spreadsheet reference:';
              LM1 := LM1 + invalue + ' on line ' + IntToStr(x);
              log.Write(DtNow(Now) + LM1);
              Application.ProcessMessages;
             End;
           End;
          //
          //  The next three fields are saved off from the template csv.   But, these only really help in regards
          //  to LNA template.
          //
          if N = 7 then SAV07 := WorkTSL[N];
          if N = 8 then SAV08 := WorkTSL[N];
          if N = 9 then SAV09 := WorkTSL[N];
          //
          // Here is another LNA-targeted assist (but could be leveraged for other template types):
          //
          if WorkTSL[N] = '[translate]'  then
            begin
              xltResult := LastLUV;     // set return value to same value we as are going to look up
              saveN := N;
              saveWTSLC := WorkTSL.Count;
              Translate(SAV09, TMPLTYPE, LastLUV, tmpltnmI, x, workdir, xltResult);
              WorkTSL[N] := xltResult;
            end;
          //
          Grec := Grec + SEP + WorkTSL[N];
          //
         End;
        //
        WriteLn(OFile, Grec);
        Inc(GWrtCnt);
        WorkTSL.Free;
        SKIPt:
      End;
    //
    CloseFile(TFile);
    CloseFile(OFile);
    SKIPs:
    STSL.Free;
   End;
  //
  CloseFile(SFile);
  If Assigned(MHTSL) Then MHTSL.Free;
  //
  if TMPLTYPE = 'CANDOTAGFILE' then
   begin
    lStatus.Caption := 'Now will put resultant CANDO_TAGFILE into ' + wfolder + ' folder';
    log.Write(DtNow(Now) + 'Now will put resultant CANDO_TAGFILE into ' + wfolder + ' folder');
    Application.ProcessMessages;
    Reset(OFile);
    if FileExists(WorkAreaUNC + wfolder + '\CANDO_TAGFILE.CSV') then DeleteFile(WorkAreaUNC + wfolder + '\CANDO_TAGFILE.CSV');
    AssignFile(FINALO, WorkAreaUNC + wfolder + '\CANDO_TAGFILE.CSV');
    ReWrite(FINALO);
    //
    While Not Eof(OFile) Do       // copy output file to CANDO_TAGFILE in \MASS folder
     Begin
      ReadLn(OFile, Srec);
      WriteLn(FINALO, Srec);
     End;
    CloseFile(FINALO);
    CloseFile(Ofile);
   end;
  //
  // now, rename SPREADSHT.CSV so it's filename has date and time in it
  //
  lStatus.Caption := 'Renaming SPREADSHT.csv now';
  log.Write(DtNow(Now) + 'Renaming SPREADSHT.csv now');
  Application.ProcessMessages;
  dtstring := DtNow(Now);
  dtstring := stringreplace(dtstring, ':', '_', [rfReplaceAll]);
  dtstring := stringreplace(dtstring, ' ', '_', [rfReplaceAll]);
  dtstring := stringreplace(dtstring, '/', '_', [rfReplaceAll]);
  RenameFile(workdir + 'SPREADSHT.csv', workdir + 'SPREADSHT_' + dtstring + '.csv');
  //
  lStatus.Caption := 'Closing Input file' + InptSNam;
  log.Write(DtNow(Now) + 'Closing Input file' + InptSNam);
  Application.ProcessMessages;
  //
  lStatus.Caption := 'Wrapping up now.';
  log.Write(DtNow(Now) + 'Finished TmpltSS program.');
  Application.ProcessMessages;
  //
  close;
  //
 End;



procedure TForm1.FormCreate(Sender: TObject);
var
 CurDt: String;
begin

end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
    log.Free;
end;

Procedure TForm1.FormShow(Sender: tObject);
Begin
  Button1.Enabled := True;
 // LoadDatabase;                                            // access to Admin System data
End;


End.


}}} template_types.csv
* template file name,type of file,write rule for headers,delimiter,tilde info,"comments       (note: any row in this csv file which starts with an aserisk is considered a comment only, and is not really processed by TMPLTSS program)"
AI7976.CSV,CANDOTAGFILE,TOP,COMMA,~ZT;~ZC;;~NP;~FN;~MN;~LN;~DB;~GN;~SS;~TC;;~RD;~ET;~RC;~P1;~P2;~EB;~PP;;~B8;~B1;~B2;~B4;~B5;~B7;~B6;;~R1;~R2;~R4;~R5;~R7;~R6;;~L2;~L3;~LL;~L4;~L7;~AR;~DS;~DF;~DX;~LS;~LF;~LX;~AS;~AF;~AX;~VS;~VF;~VX,"program will recognize AI7976.CSV in the input spreadsheet and know to process the template as a cando tagfile.  A cando tagfile has exactly ONE header at top of file - and that header is recgonized by interogating BYTE ONE of the record.  Any row where BYTE ONE is non-numeric is a ""header""."
TMP_LNACTEJAI7976.csv,CANDOTAGFILE,TOP,COMMA,~ZT;~ZC;;~NP;~FN;~MN;~LN;~DB;~GN;~SS;~TC;;~RD;~ET;~RC;~P1;~P2;~EB;~PP;;~B8;~B1;~B2;~B4;~B5;~B7;~B6;;~R1;~R2;~R4;~R5;~R7;~R6;;~L2;~L3;~LL;~L4;~L7;~AR;~DS;~DF;~DX;~LS;~LF;~LX;~AS;~AF;~AX;~VS;~VF;~VX,"program will recognize this template filename and know to process the template as a cando tagfile.  A cando tagfile has exactly ONE header at top of file - and that header is recgonized by interogating BYTE ONE of the record.  Any row where BYTE ONE is non-numeric is a ""header""."
TMP_LNACTEJLC7976.csv,CANDOTAGFILE,TOP,COMMA,~ZT;~ZC;;~NP;~FN;~MN;~LN;~DB;~GN;~SS;~TC;;~RD;~ET;~RC;~P1;~P2;~EB;~PP;;~B8;~B1;~B2;~B4;~B5;~B7;~B6;;~R1;~R2;~R4;~R5;~R7;~R6;;~L2;~L3;~LL;~L4;~L7;~AR;~DS;~DF;~DX;~LS;~LF;~LX;~AS;~AF;~AX;~VS;~VF;~VX,"program will recognize this template filename and know to process the template as a cando tagfile.  A cando tagfile has exactly ONE header at top of file - and that header is recgonized by interogating BYTE ONE of the record.  Any row where BYTE ONE is non-numeric is a ""header""."
TMP_LNACTEJAA7976.csv,CANDOTAGFILE,TOP,COMMA,~ZT;~ZC;;~NP;~FN;~MN;~LN;~DB;~GN;~SS;~TC;;~RD;~ET;~RC;~P1;~P2;~EB;~PP;;~B8;~B1;~B2;~B4;~B5;~B7;~B6;;~R1;~R2;~R4;~R5;~R7;~R6;;~L2;~L3;~LL;~L4;~L7;~AR;~DS;~DF;~DX;~LS;~LF;~LX;~AS;~AF;~AX;~VS;~VF;~VX,"program will recognize this template filename and know to process the template as a cando tagfile.  A cando tagfile has exactly ONE header at top of file - and that header is recgonized by interogating BYTE ONE of the record.  Any row where BYTE ONE is non-numeric is a ""header""."
TMP_VERTAFORE_RETURN_FILE_20506_20220318120000_Processed.Exp,VERTAFORERETURN,NONE,PIPE,~ZT;~ZC;~AN;~NP;~FN;~MN;~LN;~DB;~GN;~SS;~TC;;~RD;~ET;~RC;~P1;~P2;~EB;~PP;;~B8;~B1;~B2;~B4;~B5;~B7;~B6;;~R1;~R2;~R4;~R5;~R7;~R6;;~L2;~L3;~LL;~L4;~L7;~AR;~DS;~DF;~DX;~LS;~LF;~LX;~AS;~AF;~AX;~VS;~VF;~VX,"generic, no-header processing of a template"
}}}TMP_LNACTEJAA7976.csv
SUBMIT HEAD INFO,CONTRA HEAD INFO,LNA RECD HEADER,REC COUNTR,RECTP,FID,ID),Loc,End,DTCC              ,F,Name  ,Transl,UpTo18,TagNa,D,F,F,GR.COL,ColRL,(,R,L,PXLT,VALUE
0057LNA0057,79760057,B5301000057,1,B5301,06A,28,20,A/N,ORG.NSCC.CTL      ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,                    
0057LNA0057,79760057,B5301000057,1,B5301,07A,48,2,A/N,TRX.TYP           ,A,01@001,01@001,05@027,     , ,Y,N,02@027,     , ,Y,N,AA  ,2022 MAL SPRDSHT LOAD OF STATES
0057LNA0057,79760057,B5301000057,1,B5301,08A,50,8,D  ,TRX.EFF           ,A,01@003,01@003,      ,     , ,N,N,      ,     , ,N,N,    ,        
0057LNA0057,79760057,B5301000057,1,B5301,09A,58,2,A/N,TRX.STATUS        ,A,01@011,01@011,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,1,B5301,10A,60,2,A/N,TRX.REASON        ,A,01@013,01@013,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,1,B5301,11A,62,9,N  ,PRIOR.FIRM.ID     ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,0
0057LNA0057,79760057,B5301000057,1,B5301,12A,71,35,A/N,PRIOR.FIRM.NM     ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,1,B5301,13A,106,1,A/N,PRDCR.TYPE        ,A,01@015,01@015,24@004,     ,I,Y,N,      ,     , ,N,N,~ET,[translate]
0057LNA0057,79760057,B5301000057,1,B5301,14A,107,2,A/N,PRDCR.ROLE        ,A,01@016,01@016,24@035,     ,I,Y,N,      ,     , ,N,N,~RC,[translate]
0057LNA0057,79760057,B5301000057,1,B5301,15A,109,20,A/N,PRDCR.TITLE       ,A,01@018,01@018,24@063,     ,I,N,N,      ,     , ,N,N,    ,                    
0057LNA0057,79760057,B5301000057,1,B5301,16A,129,1,A/N,EMPLEE.IND        ,A,01@038,01@038,26@004,     ,Y,N,N,      ,     , ,N,N,    ,Y
0057LNA0057,79760057,B5301000057,1,B5301,17A,130,2,A/N,DISTRIB.CHNL      ,A,01@039,01@039,26@020,     ,Y,Y,N,      ,     , ,N,N,WH  ,WIREHOUSE
0057LNA0057,79760057,B5301000057,1,B5301,18A,132,1,A/N,SEX               ,A,01@041,01@041,12@017,     ,Y,N,N,05@017,     ,Y,N,N,    ,~GN
0057LNA0057,79760057,B5301000057,1,B5301,19A,133,8,D  ,DOB               ,A,01@042,01@042,12@004,     ,Y,N,N,05@004,     ,Y,N,N,    ,~DB
0057LNA0057,79760057,B5301000057,1,B5301,20A,141,1,A/N,CITZN.IND         ,A,01@050,01@050,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,1,B5301,21A,142,2,A/N,CITZN.COUNTRY     ,A,01@051,01@051,26@065,     ,Y,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,1,B5301,23A,176,10,A/N,DISTRIB.CRD       ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,250
0057LNA0057,79760057,B5301000057,1,B5301,24A,186,1,A/N,PR.IND            ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,1,B5301,25A,187,1,A/N,PORTAL.STRG.IND   ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,1,B5301,26A,188,8,D  ,FINRA.REGIS.DT    ,A,01@053,01@053,28@020,     ,Y,N,N,      ,     , ,N,N,    ,~RD
0057LNA0057,79760057,B5301000057,2,B5302,06A,28,9,N  ,PRD.TAXID         ,A,01@061,01@061,12@023,SKIP1,Y,N,N,05@023,SKIP1,Y,N,N,    ,~SS
0057LNA0057,79760057,B5301000057,2,B5302,07A,37,2,A/N,TAXID.CD          ,A,01@070,01@070,12@043,SKIP1,Y,N,N,05@043,SKIP1,Y,N,N,~TC,[translate]
0057LNA0057,79760057,B5301000057,2,B5302,08A,39,20,A/N,OTH.ID1           ,A,01@072,01@072,12@059,     ,Y,N,N,05@059,     ,Y,N,N,    ,                    
0057LNA0057,79760057,B5301000057,2,B5302,09A,59,2,A/N,TYPE              ,A,01@092,01@092,12@055,     , ,N,N,05@055,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,2,B5302,19A,159,10,N  ,PRD.NPN           ,A,01@094,01@094,12@023,SKIP1,Y,N,N,05@023,SKIP1,Y,N,N,    ,~NP
0057LNA0057,79760057,B5301000057,3,B5303,06A,28,2,A/N,PRDCR.NAME.TYP    ,A,01@104,01@104,10@003,     , ,Y,N,04@003,     , ,Y,N,LG  ,LEGL NAM
0057LNA0057,79760057,B5301000057,3,B5303,07A,30,35,A/N,PRDCR.NAT.LNAM    ,A,01@106,01@106,10@046,     , ,N,N,04@020,     , ,N,N,    ,~LN
0057LNA0057,79760057,B5301000057,3,B5303,08A,65,25,A/N,PRDCR.NAT.FNAM    ,A,01@141,01@141,10@020,     , ,N,N,04@040,     , ,N,N,    ,~FN
0057LNA0057,79760057,B5301000057,3,B5303,09A,90,25,A/N,PRDCR.NAT.MNAM    ,A,01@166,01@166,      ,     , ,N,N,      ,     , ,N,N,    ,~MN
0057LNA0057,79760057,B5301000057,3,B5303,10A,115,10,A/N,PRDCR.NAT.NMPFX   ,A,01@191,01@191,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,3,B5303,11A,125,10,A/N,PRDCR.NAT.NMSFX   ,A,01@201,01@201,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,3,B5303,12A,135,105,A/N,PRDCR.ORGZL.NM    ,A,01@211,01@211,30@020,     ,I,N,N,      ,     , ,N,N,    ,                                                                                                         
0057LNA0057,79760057,B5301000057,4,B5304,06A,28,2,A/N,PRDCR.AD.TYP      ,C,01@316,      ,32@015,SKIP1, ,Y,N,      ,     , ,N,N,BB  ,BUS MAIL AD
0057LNA0057,79760057,B5301000057,4,B5304,07A,30,10,A/N,PRDCR.AD.TYP.RF   ,C,01@318,      ,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,4,B5304,08A,40,35,A/N,PRDCR.AD.LN1      ,C,01@328,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B1
0057LNA0057,79760057,B5301000057,4,B5304,09A,75,35,A/N,PRDCR.AD.LN2      ,C,01@363,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B2
0057LNA0057,79760057,B5301000057,4,B5304,10A,110,35,A/N,PRDCR.AD.LN3      ,C,01@398,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,4,B5304,11A,145,30,A/N,PRDCR.AD.CITY     ,C,01@433,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B4
0057LNA0057,79760057,B5301000057,4,B5304,12A,175,2,A/N,PRDCR.AD.ST       ,C,01@463,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B5
0057LNA0057,79760057,B5301000057,4,B5304,13A,177,15,A/N,PRDCR.AD.ZIP      ,C,01@465,      ,32@023,SKIP1, ,N,N,      ,     , ,N,N,    ,~B6
0057LNA0057,79760057,B5301000057,4,B5304,14A,192,2,A/N,PRDCR.AD.CNTRY    ,C,01@480,      ,      ,     , ,N,N,      ,     , ,N,N,    ,~B7
0057LNA0057,79760057,B5301000057,4,B5304,15A,194,2,A/N,PRDCR.DOC.PREF    ,C,01@482,      ,30@004,     , ,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,4,B5304,16A,196,2,A/N,PRDCR.AC.SEQ4     ,C,01@484,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,5,B5304,06A,28,2,A/N,PRDCR.AD.TYP      ,C,01@316,      ,32@015,SKIP1, ,Y,N,      ,     , ,N,N,RS  ,RESID ADDR
0057LNA0057,79760057,B5301000057,5,B5304,07A,30,10,A/N,PRDCR.AD.TYP.RF   ,C,01@318,      ,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,5,B5304,08A,40,35,A/N,PRDCR.AD.LN1      ,C,01@328,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R1
0057LNA0057,79760057,B5301000057,5,B5304,09A,75,35,A/N,PRDCR.AD.LN2      ,C,01@363,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R2
0057LNA0057,79760057,B5301000057,5,B5304,10A,110,35,A/N,PRDCR.AD.LN3      ,C,01@398,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,5,B5304,11A,145,30,A/N,PRDCR.AD.CITY     ,C,01@433,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R4
0057LNA0057,79760057,B5301000057,5,B5304,12A,175,2,A/N,PRDCR.AD.ST       ,C,01@463,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R5
0057LNA0057,79760057,B5301000057,5,B5304,13A,177,15,A/N,PRDCR.AD.ZIP      ,C,01@465,      ,32@023,SKIP1, ,N,N,      ,     , ,N,N,    ,~R6
0057LNA0057,79760057,B5301000057,5,B5304,14A,192,2,A/N,PRDCR.AD.CNTRY    ,C,01@480,      ,      ,     , ,N,N,      ,     , ,N,N,    ,~R7
0057LNA0057,79760057,B5301000057,5,B5304,15A,194,2,A/N,PRDCR.DOC.PREF    ,C,01@482,      ,30@004,     , ,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,5,B5304,16A,196,2,A/N,PRDCR.AC.SEQ4     ,C,01@484,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,6,B5305,06A,28,12,A/N,PRDCR.PHN         ,C,01@486,      ,14@030,SKIP1, ,N,N,      ,     , ,N,N,    ,~P1
0057LNA0057,79760057,B5301000057,6,B5305,07A,40,6,A/N,EXT               ,C,01@498,      ,14@050,SKIP1,I,N,N,      ,     , ,N,N,    ,~P2
0057LNA0057,79760057,B5301000057,6,B5305,09A,48,2,A/N,PRDCR.PHN.TYP     ,C,01@506,      ,14@004,SKIP1, ,Y,N,      ,     , ,N,N,BB  ,BUS PHN
0057LNA0057,79760057,B5301000057,6,B5305,10A,50,80,A/N,PRDCR.EMAIL.AD    ,C,01@508,      ,19@030,SKIP1, ,N,N,      ,     , ,N,N,    ,~EB
0057LNA0057,79760057,B5301000057,6,B5305,11A,130,2,A/N,PRDCR.CNTCT.PREF  ,C,01@588,      ,14@060,     ,I,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,6,B5305,12A,132,1,A/N,PRDCR.EMAIL.TYP   ,C,01@590,      ,19@010,SKIP1, ,Y,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,6,B5305,13A,133,2,A/N,PRDCR.AC.SEQ5     ,C,01@591,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,7,B5311,06A,28,25,A/N,DIS.CTL           ,S,      ,      ,      ,     , ,N,N,07@004,     ,I,N,N,    , 
0057LNA0057,79760057,B5301000057,7,B5311,07A,53,5,A/N,NAIC.NO           ,S,      ,01@316,      ,     , ,N,N,07@038,     ,I,N,N,    ,94250
0057LNA0057,79760057,B5301000057,7,B5311,08A,58,2,A/N,LIC.ST.REG.TERITRY,S,      ,01@321,      ,     , ,N,N,12@004,SKIP1,N,N,N,    ,~L2
0057LNA0057,79760057,B5301000057,7,B5311,09A,60,1,A/N,RES.NONRES.IND    ,S,      ,01@323,      ,     , ,N,N,12@007,SKIP1,N,Y,N,~L3,[translate]
0057LNA0057,79760057,B5301000057,7,B5311,10A,61,2,A/N,LIC.TYP           ,S,      ,01@324,      ,     , ,N,N,      ,     , ,N,N,~L4,[translate]
0057LNA0057,79760057,B5301000057,7,B5311,11A,63,2,A/N,RES.ST            ,S,      ,01@326,      ,     , ,N,N,09@003,     ,I,N,N,    ,~R5
0057LNA0057,79760057,B5301000057,7,B5311,12A,65,2,A/N,RES.ST.LIC.STAT   ,S,      ,01@328,      ,     , ,N,N,09@021,     ,I,Y,N,    ,  
0057LNA0057,79760057,B5301000057,7,B5311,13A,67,15,A/N,RES.ST.LIC.NUM    ,S,      ,01@330,      ,     , ,N,N,09@051,     ,I,N,N,    ,               
0057LNA0057,79760057,B5301000057,7,B5311,14A,82,1,A/N,CORP.IND          ,S,      ,01@345,      ,     , ,N,N,07@052,     ,I,N,N,    ,~L7/IFBLANK=N
0057LNA0057,79760057,B5301000057,7,B5311,15A,83,10,A/N,CORP.TAXID        ,S,      ,01@346,      ,     , ,N,N,07@065,     ,I,N,N,    ,~L7
0057LNA0057,79760057,B5301000057,7,B5311,16A,93,1,A/N,QO.OR.TW.IND      ,S,      ,      ,      ,     , ,N,N,08@004,     ,I,N,N,    ,N
0057LNA0057,79760057,B5301000057,7,B5311,17A,94,9,A/N,QO.OR.TW.TAXID    ,S,      ,      ,      ,     , ,N,N,08@022,     ,I,N,N,    ,         
0057LNA0057,79760057,B5301000057,7,B5311,18A,103,35,A/N,QO.OR.TW.LNAME    ,S,      ,      ,      ,     , ,N,N,08@050,     ,I,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,7,B5311,19A,138,25,A/N,QO.OR.TW.FNAME    ,S,      ,      ,      ,     , ,N,N,08@090,     ,N,N,N,    ,                         
0057LNA0057,79760057,B5301000057,7,B5311,20A,163,16,$  ,APPT.FEE.AMT      ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,0
0057LNA0057,79760057,B5301000057,7,B5311,21A,179,16,$  ,LIC.FEE.AMT       ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,0
0057LNA0057,79760057,B5301000057,7,B5311,22A,195,15,A/N,ST.LIC.NUM        ,S,      ,01@356,      ,     , ,N,N,12@020,SKIP1,N,N,N,    ,~LL
0057LNA0057,79760057,B5301000057,7,B5311,23A,210,2,A/N,TW.APPT.RES.ST    ,S,      ,      ,      ,     , ,N,N,11@004,     ,I,N,N,    ,  
0057LNA0057,79760057,B5301000057,7,B5311,24A,212,1,A/N,ST.SEC.REGIS.IND  ,S,      ,      ,      ,     , ,N,N,11@040,     ,I,N,N,    , 
0057LNA0057,79760057,B5301000057,7,B5311,25A,213,1,A/N,IMMED.APPT.IND    ,S,      ,01@371,      ,     , ,N,N,11@070,     ,I,N,N,    ,~AR
0057LNA0057,79760057,B5301000057,8,B5312,06A,28,2,A/N,LIC.LOA           ,S,      ,01@372,      ,     , ,N,N,12@063,SKIP1,N,Y,N,~LS/IFNONBLANK=LI,[translate]
0057LNA0057,79760057,B5301000057,8,B5312,07A,30,2,A/N,LIC.STATUS        ,S,      ,01@374,      ,     , ,N,N,      ,     ,N,N,N,~LS/IFNONBLANK=AC,[translate]
0057LNA0057,79760057,B5301000057,8,B5312,08A,32,2,A/N,LIC.LOA.STAT.RSN  ,S,      ,01@376,      ,     , ,N,N,      ,     ,N,N,N,    , 
0057LNA0057,79760057,B5301000057,8,B5312,09A,34,8,D  ,LIC.LOA.STAT.DT   ,S,      ,01@378,      ,     , ,N,N,      ,     ,N,N,N,    ,~LS
0057LNA0057,79760057,B5301000057,8,B5312,10A,42,8,D  ,EFF               ,S,      ,01@386,      ,     , ,N,N,12@036,SKIP1,Y,N,Y,    ,~LF
0057LNA0057,79760057,B5301000057,8,B5312,11A,50,8,D  ,EXP               ,S,      ,01@394,      ,     , ,N,N,12@050,SKIP1,Y,N,N,    ,~LX
0057LNA0057,79760057,B5301000057,9,B5313,06A,28,2,A/N,APPT.LOA          ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,LI  ,LIFE
0057LNA0057,79760057,B5301000057,9,B5313,07A,30,2,A/N,APPT.LOA.STAT     ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,  
0057LNA0057,79760057,B5301000057,9,B5313,08A,32,2,A/N,APPT.LOA.STAT.RSN ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,  
0057LNA0057,79760057,B5301000057,9,B5313,09A,34,8,D  ,APPT.LOA.STAT.DT  ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
0057LNA0057,79760057,B5301000057,9,B5313,10A,42,8,D  ,APPT.LOA.EFF.DT   ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
0057LNA0057,79760057,B5301000057,9,B5313,11A,50,8,D  ,APPT.LOA.EXP.DT   ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
}}}TMP_LNACTEJAI7976.csv
SUBMIT HEAD INFO,CONTRA HEAD INFO,LNA RECD HEADER,REC COUNTR,RECTP,FID,ID),Loc,End,DTCC              ,F,Name  ,Transl,UpTo18,TagNa,D,F,F,GR.COL,ColRL,(,R,L,PXLT,VALUE
0057LNA0057,79760057,B5301000057,4,B5301,06A,28,20,A/N,ORG.NSCC.CTL      ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,                    
0057LNA0057,79760057,B5301000057,4,B5301,07A,48,2,A/N,TRX.TYP           ,A,01@001,01@001,05@027,     , ,Y,N,02@027,     , ,Y,N,AI  ,2022 MASS AGENT LOAD VIA SPREADSHEET
0057LNA0057,79760057,B5301000057,4,B5301,08A,50,8,D  ,TRX.EFF           ,A,01@003,01@003,      ,     , ,N,N,      ,     , ,N,N,    ,        
0057LNA0057,79760057,B5301000057,4,B5301,09A,58,2,A/N,TRX.STATUS        ,A,01@011,01@011,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,4,B5301,10A,60,2,A/N,TRX.REASON        ,A,01@013,01@013,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,4,B5301,11A,62,9,N  ,PRIOR.FIRM.ID     ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,0
0057LNA0057,79760057,B5301000057,4,B5301,12A,71,35,A/N,PRIOR.FIRM.NM     ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,4,B5301,13A,106,1,A/N,PRDCR.TYPE        ,A,01@015,01@015,24@004,     ,I,Y,N,      ,     , ,N,N,~ET,[translate]
0057LNA0057,79760057,B5301000057,4,B5301,14A,107,2,A/N,PRDCR.ROLE        ,A,01@016,01@016,24@035,     ,I,Y,N,      ,     , ,N,N,~RC,[translate]
0057LNA0057,79760057,B5301000057,4,B5301,15A,109,20,A/N,PRDCR.TITLE       ,A,01@018,01@018,24@063,     ,I,N,N,      ,     , ,N,N,    ,                    
0057LNA0057,79760057,B5301000057,4,B5301,16A,129,1,A/N,EMPLEE.IND        ,A,01@038,01@038,26@004,     ,Y,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,4,B5301,17A,130,2,A/N,DISTRIB.CHNL      ,A,01@039,01@039,26@020,     ,Y,Y,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,4,B5301,18A,132,1,A/N,SEX               ,A,01@041,01@041,12@017,     ,Y,N,N,05@017,     ,Y,N,N,    ,~GN
0057LNA0057,79760057,B5301000057,4,B5301,19A,133,8,D  ,DOB               ,A,01@042,01@042,12@004,     ,Y,N,N,05@004,     ,Y,N,N,    ,~DB
0057LNA0057,79760057,B5301000057,4,B5301,20A,141,1,A/N,CITZN.IND         ,A,01@050,01@050,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,4,B5301,21A,142,2,A/N,CITZN.COUNTRY     ,A,01@051,01@051,26@065,     ,Y,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,4,B5301,23A,176,10,A/N,DISTRIB.CRD       ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    ,250
0057LNA0057,79760057,B5301000057,4,B5301,24A,186,1,A/N,PR.IND            ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,4,B5301,25A,187,1,A/N,PORTAL.STRG.IND   ,A,      ,      ,      ,     , ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,4,B5301,26A,188,8,D  ,FINRA.REGIS.DT    ,A,01@053,01@053,28@020,     ,Y,N,N,      ,     , ,N,N,    ,~RD
0057LNA0057,79760057,B5301000057,5,B5302,06A,28,9,N  ,PRD.TAXID         ,A,01@061,01@061,12@023,SKIP1,Y,N,N,05@023,SKIP1,Y,N,N,    ,~SS
0057LNA0057,79760057,B5301000057,5,B5302,07A,37,2,A/N,TAXID.CD          ,A,01@070,01@070,12@043,SKIP1,Y,N,N,05@043,SKIP1,Y,N,N,~TC,[translate]
0057LNA0057,79760057,B5301000057,5,B5302,08A,39,20,A/N,OTH.ID1           ,A,01@072,01@072,12@059,     ,Y,N,N,05@059,     ,Y,N,N,    , 
0057LNA0057,79760057,B5301000057,5,B5302,09A,59,2,A/N,TYPE              ,A,01@092,01@092,12@055,     , ,N,N,05@055,     , ,N,N, , 
0057LNA0057,79760057,B5301000057,5,B5302,19A,159,10,N  ,PRD.NPN           ,A,01@094,01@094,12@023,SKIP1,Y,N,N,05@023,SKIP1,Y,N,N,    ,~NP
0057LNA0057,79760057,B5301000057,6,B5303,06A,28,2,A/N,PRDCR.NAME.TYP    ,A,01@104,01@104,10@003,     , ,Y,N,04@003,     , ,Y,N,LG  ,LEGL NAM
0057LNA0057,79760057,B5301000057,6,B5303,07A,30,35,A/N,PRDCR.NAT.LNAM    ,A,01@106,01@106,10@046,     , ,N,N,04@020,     , ,N,N,    ,~LN
0057LNA0057,79760057,B5301000057,6,B5303,08A,65,25,A/N,PRDCR.NAT.FNAM    ,A,01@141,01@141,10@020,     , ,N,N,04@040,     , ,N,N,    ,~FN
0057LNA0057,79760057,B5301000057,6,B5303,09A,90,25,A/N,PRDCR.NAT.MNAM    ,A,01@166,01@166,      ,     , ,N,N,      ,     , ,N,N,    ,~MN
0057LNA0057,79760057,B5301000057,6,B5303,10A,115,10,A/N,PRDCR.NAT.NMPFX   ,A,01@191,01@191,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,6,B5303,11A,125,10,A/N,PRDCR.NAT.NMSFX   ,A,01@201,01@201,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,6,B5303,12A,135,105,A/N,PRDCR.ORGZL.NM    ,A,01@211,01@211,30@020,     ,I,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,7,B5304,06A,28,2,A/N,PRDCR.AD.TYP      ,C,01@316,      ,32@015,SKIP1, ,Y,N,      ,     , ,N,N,RS  ,RESID ADDR
0057LNA0057,79760057,B5301000057,7,B5304,07A,30,10,A/N,PRDCR.AD.TYP.RF   ,C,01@318,      ,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,7,B5304,08A,40,35,A/N,PRDCR.AD.LN1      ,C,01@328,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R1
0057LNA0057,79760057,B5301000057,7,B5304,09A,75,35,A/N,PRDCR.AD.LN2      ,C,01@363,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R2
0057LNA0057,79760057,B5301000057,7,B5304,10A,110,35,A/N,PRDCR.AD.LN3      ,C,01@398,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,7,B5304,11A,145,30,A/N,PRDCR.AD.CITY     ,C,01@433,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R4
0057LNA0057,79760057,B5301000057,7,B5304,12A,175,2,A/N,PRDCR.AD.ST       ,C,01@463,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~R5
0057LNA0057,79760057,B5301000057,7,B5304,13A,177,15,A/N,PRDCR.AD.ZIP      ,C,01@465,      ,32@023,SKIP1, ,N,N,      ,     , ,N,N,    ,~R6
0057LNA0057,79760057,B5301000057,7,B5304,14A,192,2,A/N,PRDCR.AD.CNTRY    ,C,01@480,      ,      ,     , ,N,N,      ,     , ,N,N,    ,~R7
0057LNA0057,79760057,B5301000057,7,B5304,15A,194,2,A/N,PRDCR.DOC.PREF    ,C,01@482,      ,30@004,     , ,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,7,B5304,16A,196,2,A/N,PRDCR.AC.SEQ4     ,C,01@484,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,8,B5304,06A,28,2,A/N,PRDCR.AD.TYP      ,C,01@316,      ,32@015,SKIP1, ,Y,N,      ,     , ,N,N,BB  ,BUS MAIL AD
0057LNA0057,79760057,B5301000057,8,B5304,07A,30,10,A/N,PRDCR.AD.TYP.RF   ,C,01@318,      ,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,8,B5304,08A,40,35,A/N,PRDCR.AD.LN1      ,C,01@328,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B1
0057LNA0057,79760057,B5301000057,8,B5304,09A,75,35,A/N,PRDCR.AD.LN2      ,C,01@363,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B2
0057LNA0057,79760057,B5301000057,8,B5304,10A,110,35,A/N,PRDCR.AD.LN3      ,C,01@398,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,8,B5304,11A,145,30,A/N,PRDCR.AD.CITY     ,C,01@433,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B4
0057LNA0057,79760057,B5301000057,8,B5304,12A,175,2,A/N,PRDCR.AD.ST       ,C,01@463,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B5
0057LNA0057,79760057,B5301000057,8,B5304,13A,177,15,A/N,PRDCR.AD.ZIP      ,C,01@465,      ,32@023,SKIP1, ,N,N,      ,     , ,N,N,    ,~B6
0057LNA0057,79760057,B5301000057,8,B5304,14A,192,2,A/N,PRDCR.AD.CNTRY    ,C,01@480,      ,      ,     , ,N,N,      ,     , ,N,N,    ,~B7
0057LNA0057,79760057,B5301000057,8,B5304,15A,194,2,A/N,PRDCR.DOC.PREF    ,C,01@482,      ,30@004,     , ,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,8,B5304,16A,196,2,A/N,PRDCR.AC.SEQ4     ,C,01@484,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,9,B5304,06A,28,2,A/N,PRDCR.AD.TYP      ,C,01@316,      ,32@015,SKIP1, ,Y,N,      ,     , ,N,N,BR  ,BRANCH ADDR
0057LNA0057,79760057,B5301000057,9,B5304,07A,30,10,A/N,PRDCR.AD.TYP.RF   ,C,01@318,      ,      ,     , ,N,N,      ,     , ,N,N,    ,          
0057LNA0057,79760057,B5301000057,9,B5304,08A,40,35,A/N,PRDCR.AD.LN1      ,C,01@328,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B1
0057LNA0057,79760057,B5301000057,9,B5304,09A,75,35,A/N,PRDCR.AD.LN2      ,C,01@363,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B2
0057LNA0057,79760057,B5301000057,9,B5304,10A,110,35,A/N,PRDCR.AD.LN3      ,C,01@398,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,9,B5304,11A,145,30,A/N,PRDCR.AD.CITY     ,C,01@433,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B4
0057LNA0057,79760057,B5301000057,9,B5304,12A,175,2,A/N,PRDCR.AD.ST       ,C,01@463,      ,32@020,SKIP1, ,N,N,      ,     , ,N,N,    ,~B5
0057LNA0057,79760057,B5301000057,9,B5304,13A,177,15,A/N,PRDCR.AD.ZIP      ,C,01@465,      ,32@023,SKIP1, ,N,N,      ,     , ,N,N,    ,~B6
0057LNA0057,79760057,B5301000057,9,B5304,14A,192,2,A/N,PRDCR.AD.CNTRY    ,C,01@480,      ,      ,     , ,N,N,      ,     , ,N,N,    ,~B7
0057LNA0057,79760057,B5301000057,9,B5304,15A,194,2,A/N,PRDCR.DOC.PREF    ,C,01@482,      ,30@004,     , ,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,9,B5304,16A,196,2,A/N,PRDCR.AC.SEQ4     ,C,01@484,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,10,B5305,06A,28,12,A/N,PRDCR.PHN         ,C,01@486,      ,14@030,SKIP1, ,N,N,      ,     , ,N,N,    ,~P1
0057LNA0057,79760057,B5301000057,10,B5305,07A,40,6,A/N,EXT               ,C,01@498,      ,14@050,SKIP1,I,N,N,      ,     , ,N,N,    ,~P2
0057LNA0057,79760057,B5301000057,10,B5305,09A,48,2,A/N,PRDCR.PHN.TYP     ,C,01@506,      ,14@004,SKIP1, ,Y,N,      ,     , ,N,N,BB  ,BUS PHN
0057LNA0057,79760057,B5301000057,10,B5305,10A,50,80,A/N,PRDCR.EMAIL.AD    ,C,01@508,      ,19@030,SKIP1, ,N,N,      ,     , ,N,N,    ,~EB
0057LNA0057,79760057,B5301000057,10,B5305,11A,130,2,A/N,PRDCR.CNTCT.PREF  ,C,01@588,      ,14@060,     ,I,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,10,B5305,12A,132,1,A/N,PRDCR.EMAIL.TYP   ,C,01@590,      ,19@010,SKIP1, ,Y,N,      ,     , ,N,N,1,BUS EMAIL
0057LNA0057,79760057,B5301000057,10,B5305,13A,133,2,A/N,PRDCR.AC.SEQ5     ,C,01@591,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,11,B5305,06A,28,12,A/N,PRDCR.PHN         ,C,01@486,      ,14@030,SKIP1, ,N,N,      ,     , ,N,N,    ,~PP
0057LNA0057,79760057,B5301000057,11,B5305,07A,40,6,A/N,EXT               ,C,01@498,      ,14@050,SKIP1,I,N,N,      ,     , ,N,N,    ,      
0057LNA0057,79760057,B5301000057,11,B5305,09A,48,2,A/N,PRDCR.PHN.TYP     ,C,01@506,      ,14@004,SKIP1, ,Y,N,      ,     , ,N,N,RS  ,RES PHN
0057LNA0057,79760057,B5301000057,11,B5305,10A,50,80,A/N,PRDCR.EMAIL.AD    ,C,01@508,      ,19@030,SKIP1, ,N,N,      ,     , ,N,N,    , 
0057LNA0057,79760057,B5301000057,11,B5305,11A,130,2,A/N,PRDCR.CNTCT.PREF  ,C,01@588,      ,14@060,     ,I,Y,N,      ,     , ,N,N,~B8,[translate]
0057LNA0057,79760057,B5301000057,11,B5305,12A,132,1,A/N,PRDCR.EMAIL.TYP   ,C,01@590,      ,19@010,SKIP1, ,Y,N,      ,     , ,N,N,1,BUS EMAIL
0057LNA0057,79760057,B5301000057,11,B5305,13A,133,2,A/N,PRDCR.AC.SEQ5     ,C,01@591,      ,      ,     , ,N,N,      ,     , ,N,N,    ,  
0057LNA0057,79760057,B5301000057,12,B5311,06A,28,25,A/N,DIS.CTL           ,S,      ,      ,      ,     , ,N,N,07@004,     ,I,N,N,    , 
0057LNA0057,79760057,B5301000057,12,B5311,07A,53,5,A/N,NAIC.NO           ,S,      ,01@316,      ,     , ,N,N,07@038,     ,I,N,N,    ,     
0057LNA0057,79760057,B5301000057,12,B5311,08A,58,2,A/N,LIC.ST.REG.TERITRY,S,      ,01@321,      ,     , ,N,N,12@004,SKIP1,N,N,N,    ,~L2
0057LNA0057,79760057,B5301000057,12,B5311,09A,60,1,A/N,RES.NONRES.IND    ,S,      ,01@323,      ,     , ,N,N,12@007,SKIP1,N,Y,N,~L3,[translate]
0057LNA0057,79760057,B5301000057,12,B5311,10A,61,2,A/N,LIC.TYP           ,S,      ,01@324,      ,     , ,N,N,      ,     , ,N,N,~L4,[translate]
0057LNA0057,79760057,B5301000057,12,B5311,11A,63,2,A/N,RES.ST            ,S,      ,01@326,      ,     , ,N,N,09@003,     ,I,N,N,    ,  
0057LNA0057,79760057,B5301000057,12,B5311,12A,65,2,A/N,RES.ST.LIC.STAT   ,S,      ,01@328,      ,     , ,N,N,09@021,     ,I,Y,N,    ,  
0057LNA0057,79760057,B5301000057,12,B5311,13A,67,15,A/N,RES.ST.LIC.NUM    ,S,      ,01@330,      ,     , ,N,N,09@051,     ,I,N,N,    ,               
0057LNA0057,79760057,B5301000057,12,B5311,14A,82,1,A/N,CORP.IND          ,S,      ,01@345,      ,     , ,N,N,07@052,     ,I,N,N,    ,~L7/IFBLANK=N
0057LNA0057,79760057,B5301000057,12,B5311,15A,83,10,A/N,CORP.TAXID        ,S,      ,01@346,      ,     , ,N,N,07@065,     ,I,N,N,    ,~L7
0057LNA0057,79760057,B5301000057,12,B5311,16A,93,1,A/N,QO.OR.TW.IND      ,S,      ,      ,      ,     , ,N,N,08@004,     ,I,N,N,    ,N
0057LNA0057,79760057,B5301000057,12,B5311,17A,94,9,A/N,QO.OR.TW.TAXID    ,S,      ,      ,      ,     , ,N,N,08@022,     ,I,N,N,    ,         
0057LNA0057,79760057,B5301000057,12,B5311,18A,103,35,A/N,QO.OR.TW.LNAME    ,S,      ,      ,      ,     , ,N,N,08@050,     ,I,N,N,    ,                                   
0057LNA0057,79760057,B5301000057,12,B5311,19A,138,25,A/N,QO.OR.TW.FNAME    ,S,      ,      ,      ,     , ,N,N,08@090,     ,N,N,N,    ,                         
0057LNA0057,79760057,B5301000057,12,B5311,20A,163,16,$  ,APPT.FEE.AMT      ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,0
0057LNA0057,79760057,B5301000057,12,B5311,21A,179,16,$  ,LIC.FEE.AMT       ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,0
0057LNA0057,79760057,B5301000057,12,B5311,22A,195,15,A/N,ST.LIC.NUM        ,S,      ,01@356,      ,     , ,N,N,12@020,SKIP1,N,N,N,    ,~LL
0057LNA0057,79760057,B5301000057,12,B5311,23A,210,2,A/N,TW.APPT.RES.ST    ,S,      ,      ,      ,     , ,N,N,11@004,     ,I,N,N,    ,  
0057LNA0057,79760057,B5301000057,12,B5311,24A,212,1,A/N,ST.SEC.REGIS.IND  ,S,      ,      ,      ,     , ,N,N,11@040,     ,I,N,N,    , 
0057LNA0057,79760057,B5301000057,12,B5311,25A,213,1,A/N,IMMED.APPT.IND    ,S,      ,01@371,      ,     , ,N,N,11@070,     ,I,N,N,    ,~AR
0057LNA0057,79760057,B5301000057,13,B5312,06A,28,2,A/N,LIC.LOA           ,S,      ,01@372,      ,     , ,N,N,12@063,SKIP1,N,Y,N,~DS/IFNONBLANK=DS,[translate]
0057LNA0057,79760057,B5301000057,13,B5312,07A,30,2,A/N,LIC.STATUS        ,S,      ,01@374,      ,     , ,N,N,      ,     ,N,N,N,~DS/IFNONBLANK=AC,[translate]
0057LNA0057,79760057,B5301000057,13,B5312,08A,32,2,A/N,LIC.LOA.STAT.RSN  ,S,      ,01@376,      ,     , ,N,N,      ,     ,N,N,N,    , 
0057LNA0057,79760057,B5301000057,13,B5312,09A,34,8,D  ,LIC.LOA.STAT.DT   ,S,      ,01@378,      ,     , ,N,N,      ,     ,N,N,N,    ,~DS
0057LNA0057,79760057,B5301000057,13,B5312,10A,42,8,D  ,EFF               ,S,      ,01@386,      ,     , ,N,N,12@036,SKIP1,Y,N,Y,    ,~DF
0057LNA0057,79760057,B5301000057,13,B5312,11A,50,8,D  ,EXP               ,S,      ,01@394,      ,     , ,N,N,12@050,SKIP1,Y,N,N,    ,~DX
0057LNA0057,79760057,B5301000057,14,B5312,06A,28,2,A/N,LIC.LOA           ,S,      ,01@372,      ,     , ,N,N,12@063,SKIP1,N,Y,N,~LS/IFNONBLANK=LI,[translate]
0057LNA0057,79760057,B5301000057,14,B5312,07A,30,2,A/N,LIC.STATUS        ,S,      ,01@374,      ,     , ,N,N,      ,     ,N,N,N,~LS/IFNONBLANK=AC,[translate]
0057LNA0057,79760057,B5301000057,14,B5312,08A,32,2,A/N,LIC.LOA.STAT.RSN  ,S,      ,01@376,      ,     , ,N,N,      ,     ,N,N,N,    , 
0057LNA0057,79760057,B5301000057,14,B5312,09A,34,8,D  ,LIC.LOA.STAT.DT   ,S,      ,01@378,      ,     , ,N,N,      ,     ,N,N,N,    ,~LS
0057LNA0057,79760057,B5301000057,14,B5312,10A,42,8,D  ,EFF               ,S,      ,01@386,      ,     , ,N,N,12@036,SKIP1,Y,N,Y,    ,~LF
0057LNA0057,79760057,B5301000057,14,B5312,11A,50,8,D  ,EXP               ,S,      ,01@394,      ,     , ,N,N,12@050,SKIP1,Y,N,N,    ,~LX
0057LNA0057,79760057,B5301000057,15,B5312,06A,28,2,A/N,LIC.LOA           ,S,      ,01@372,      ,     , ,N,N,12@063,SKIP1,N,Y,N,~AS/IFNONBLANK=VA,[translate]
0057LNA0057,79760057,B5301000057,15,B5312,07A,30,2,A/N,LIC.STATUS        ,S,      ,01@374,      ,     , ,N,N,      ,     ,N,N,N,~AS/IFNONBLANK=AC,[translate]
0057LNA0057,79760057,B5301000057,15,B5312,08A,32,2,A/N,LIC.LOA.STAT.RSN  ,S,      ,01@376,      ,     , ,N,N,      ,     ,N,N,N,    , 
0057LNA0057,79760057,B5301000057,15,B5312,09A,34,8,D  ,LIC.LOA.STAT.DT   ,S,      ,01@378,      ,     , ,N,N,      ,     ,N,N,N,    ,~AS
0057LNA0057,79760057,B5301000057,15,B5312,10A,42,8,D  ,EFF               ,S,      ,01@386,      ,     , ,N,N,12@036,SKIP1,Y,N,Y,    ,~AF
0057LNA0057,79760057,B5301000057,15,B5312,11A,50,8,D  ,EXP               ,S,      ,01@394,      ,     , ,N,N,12@050,SKIP1,Y,N,N,    ,~AX
0057LNA0057,79760057,B5301000057,16,B5312,06A,28,2,A/N,LIC.LOA           ,S,      ,01@372,      ,     , ,N,N,12@063,SKIP1,N,Y,N,~VS/IFNONBLANK=VL,[translate]
0057LNA0057,79760057,B5301000057,16,B5312,07A,30,2,A/N,LIC.STATUS        ,S,      ,01@374,      ,     , ,N,N,      ,     ,N,N,N,~VS/IFNONBLANK=AC,[translate]
0057LNA0057,79760057,B5301000057,16,B5312,08A,32,2,A/N,LIC.LOA.STAT.RSN  ,S,      ,01@376,      ,     , ,N,N,      ,     ,N,N,N,    , 
0057LNA0057,79760057,B5301000057,16,B5312,09A,34,8,D  ,LIC.LOA.STAT.DT   ,S,      ,01@378,      ,     , ,N,N,      ,     ,N,N,N,    ,~VS
0057LNA0057,79760057,B5301000057,16,B5312,10A,42,8,D  ,EFF               ,S,      ,01@386,      ,     , ,N,N,12@036,SKIP1,Y,N,Y,    ,~VF
0057LNA0057,79760057,B5301000057,16,B5312,11A,50,8,D  ,EXP               ,S,      ,01@394,      ,     , ,N,N,12@050,SKIP1,Y,N,N,    ,~VX
0057LNA0057,79760057,B5301000057,17,B5313,06A,28,2,A/N,APPT.LOA          ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,LI  ,LIFE
0057LNA0057,79760057,B5301000057,17,B5313,07A,30,2,A/N,APPT.LOA.STAT     ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,  
0057LNA0057,79760057,B5301000057,17,B5313,08A,32,2,A/N,APPT.LOA.STAT.RSN ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,  
0057LNA0057,79760057,B5301000057,17,B5313,09A,34,8,D  ,APPT.LOA.STAT.DT  ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
0057LNA0057,79760057,B5301000057,17,B5313,10A,42,8,D  ,APPT.LOA.EFF.DT   ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
0057LNA0057,79760057,B5301000057,17,B5313,11A,50,8,D  ,APPT.LOA.EXP.DT   ,S,      ,      ,      ,     , ,N,N,      ,     ,N,N,N,    ,        
}}}TMP_VERTAFORE_RETURN_FILE_20506_20220318120000_Processed.Exp
IN|A|~SS|~AN|~LN|~FN|~MN|||~DB||N|~GN|||||||||||||||||58|~R5|~LL|20220318||||||||||||||||||~NP||||||||||||||||||
RA|A|I|~SS|~AN||||~R1||||~R4|~R5|~R6||||~EB||N|||
BA|A|I|~SS|~AN||||~B1||||~B4|~B5|~B6|~P1|||~EB||N|||
LI|A|I|~SS|~AN|20220318|||~LL|~L2|Y|Y||B|20220318|20230318||||||||||||||||
AP|A|I|~SS|~AN|~L2|~LL|A|Y||20220318|||||A|||||NNYNNNNNNNNNN|||20230318||||
TR||I|||||541|17|~L2|A|Y|A|~L2|L|Y|~LL|20220318|||||N|||||20220317||||20220318|NNYNNNNNNNNNN|20220318|20230318|Demo|||N||||N|N|N|N|N|||1|1||||||||||||||||||||||
}}}SPREADSHT_6_16_2022_10_32_48_PM__.csv
~ZT,~ZC,,~NP,~FN,~MN,~LN,~DB,~GN,~SS,~TC,,~RD,~ET,~RC,~P1,~P2,~EB,~PP,,~B8,~B1,~B2,~B4,~B5,~B7,~B6,,~R1,~R2,~R4,~R5,~R7,~R6,,~L2,~L3,~LL,~L4,~L7,~AR,~DS,~DF,~DX,~LS,~LF,~LX,~AS,~AF,~AX,~VS,~VF,~VX
Translation Template,"""To"" Company",Hier Boss to attach to,NPN,FirstName,MiddleName,LastName,DOB,GENDER,TAX,TAX ID CD,Agencys ID,Registration Date,Entity Type,Role Code,Business Phn Num,Bus Phn Ext,Business Email Addr,Personal Phn Num,Personal Email Addr,Contact Info,BUS ADDR LINE ONE,BUS ADDR LINE TWO,BUS CITY,BUS ST,BUS COUNTRY,BUS ZIP,BUS +4,RESID ADDR LINE ONE,RESID ADDR LINE TWO,RESID CITY,RESID ST,RESID COUNTRY,RESID ZIP,RESID +4,LIC STATE,LIC RESIDENT?,LIC NUM,LIC TYPE CODE,LIC CORP TAXID,APPT RQSTD?,Active DS LICLOASTATDT   ,Active DS LICLOAEFFDT   ,Active DS LICLOAEXPDT   ,Active LI LICLOASTATDT   ,Active LI LICLOAEFFDT   ,Active LI LICLOAEXPDT   ,Active VA LICLOASTATDT   ,Active VA LICLOAEFFDT   ,Active VA LICLOAEXPDT   ,Active VL LICLOASTATDT   ,Active VL LICLOAEFFDT   ,Active VL LICLOAEXPDT   
~TMP_LNACTEJAI7976.csv,,,390114,Douglas,Paul,Smith,19560106,M,263113520,34,,19920817,1,8P,2077729576,,paul.smith2@edwardjones.com,,,B,619 FOREST AVENUE,,PORTLAND,ME,USA,04101,0,110 Skillings Street,,South Portland,ME,USA,04106,0,ME,R,PRR284127,2,,ALL,20220509,20170317,20240131,20220509,20170317,20240131,20220509,20170317,20240131,20220509,20170317,20240131
~TMP_LNACTEJAI7976.csv,,,402980,Michael,William,Cummins,19611218,M,43529156,34,,19850705,1,8P,8603886266,,mike.cummins@edwardjones.com,,,B,24 ELM STREET SUITE 1,,OLD SAYBROOK,CT,USA,06475,0,5 Leada Woods Road,,Old Saybrook,CT,USA,06475,0,CT,R,402980,2,,ALL,20220509,19840831,20231231,20220509,19840831,20231231,20220509,19840831,20231231,20220509,19840831,20231231
~TMP_LNACTEJAI7976.csv,,,423593,Jeffrey,Scott,Kolod,19621123,M,95489759,34,,19940114,1,8P,2074396206,,jeffrey.kolod@edwardjones.com,,,B,11 SANBORN LANE UNIT 7,,ELIOT,ME,USA,03903,0,28 Gate House Rd,,Shapleigh,ME,USA,04076,0,ME,R,PRR41504,2,,ALL,20220509,19950227,20221130,20220509,19950227,20221130,20220509,19951001,20221130,20220509,19951001,20221130
~TMP_LNACTEJAI7976.csv,,,440638,Timothy,Michael,Dalton,19640401,M,138621012,34,,19910228,1,8P,9739489700,,timothy.dalton@edwardjones.com,,,B,202 U S HWY 206 SUITE B,,BRANCHVILLE,NJ,USA,07826,0,17 Cardinal Drive,,Hackettstown,NJ,USA,07840,0,NJ,R,9949804,2,,ALL,20220509,20150212,20230430,20220509,20150212,20230430,20220509,20150212,20230430,20220509,20150212,20230430
}}}TRANSLATES.csv
* this file tells TMPLTSS program how to do a field translate.,,,
* the third col is what is sent in for translate.  Col 4 has Result value.   Note: col 3 values with quotes around the value is to retain leading zeros.   Pgm strips away the quotes before comparing.,,,
* tmplt type,field for compare,rcvd value,result value
CANDOTAGFILE,PRDCR.TYPE,1,Person
CANDOTAGFILE,PRDCR.TYPE,2,Non-Person
CANDOTAGFILE,PRDCR.TYPE,4,Corporation
CANDOTAGFILE,PRDCR.TYPE,7,Limited Liability Corporation
CANDOTAGFILE,PRDCR.TYPE,8,Partnership
CANDOTAGFILE,PRDCR.TYPE,E,Sole-Proprietorship
CANDOTAGFILE,PRDCR.TYPE,P,Limited Liability Partnership
CANDOTAGFILE,PRDCR.TYPE,U,Unincorporated Association
CANDOTAGFILE,PRDCR.TYPE,B,Brokerage General Agency
CANDOTAGFILE,PRDCR.ROLE,AG,Agent
CANDOTAGFILE,PRDCR.ROLE,G1,Agency
CANDOTAGFILE,PRDCR.ROLE,J8,Broker/Dealer
CANDOTAGFILE,PRDCR.ROLE,BE,Bank Employee
CANDOTAGFILE,PRDCR.ROLE,ZJ,Branch
CANDOTAGFILE,PRDCR.ROLE,BK,Bank
CANDOTAGFILE,PRDCR.ROLE,BR,Broker
CANDOTAGFILE,PRDCR.ROLE,JY,Financial Planner
CANDOTAGFILE,PRDCR.ROLE,GE,General Agent
CANDOTAGFILE,PRDCR.ROLE,JZ,Managing General Agent
CANDOTAGFILE,PRDCR.ROLE,PA,Paid Affiliate
CANDOTAGFILE,PRDCR.ROLE,8P,Producer
CANDOTAGFILE,PRDCR.ROLE,QO,Qualifying Officer
CANDOTAGFILE,PRDCR.ROLE,H1,Registered Investment Advisor
CANDOTAGFILE,PRDCR.ROLE,H8,Servicing Only Agent
CANDOTAGFILE,PRDCR.ROLE,TM,Team
CANDOTAGFILE,PRDCR.ROLE,BO,Broker or Sales Office
CANDOTAGFILE,PRDCR.ROLE,DS,Distributor
CANDOTAGFILE,PRDCR.ROLE,EV,Selling Agent
CANDOTAGFILE,PRDCR.ROLE,EW,Servicing Broker
CANDOTAGFILE,PRDCR.ROLE,J3,Brokers Assistant
CANDOTAGFILE,PRDCR.ROLE,BG,Brokerage General Agency
CANDOTAGFILE,TAXID.CD,34,Social Security Number
CANDOTAGFILE,TAXID.CD,FI,Federal Tax ID
CANDOTAGFILE,TAXID.CD,SB,Canadian Social Security Number
CANDOTAGFILE,PRDCR.DOC.PREF,B,Business
CANDOTAGFILE,PRDCR.DOC.PREF,BB,Business
CANDOTAGFILE,PRDCR.DOC.PREF,BE,Business E-mail
CANDOTAGFILE,PRDCR.DOC.PREF,BF,Business Facsimile
CANDOTAGFILE,PRDCR.DOC.PREF,BR,Branch Address
CANDOTAGFILE,PRDCR.DOC.PREF,BU,Business Address (for Overnight Mail)
CANDOTAGFILE,PRDCR.DOC.PREF,CM,Commission Mailing Address
CANDOTAGFILE,PRDCR.DOC.PREF,HO,Home Office/Back Office Address
CANDOTAGFILE,PRDCR.DOC.PREF,PM,Policy Mailing Address
CANDOTAGFILE,PRDCR.DOC.PREF,RE,Resident Email
CANDOTAGFILE,PRDCR.DOC.PREF,RF,Resident Facsimile
CANDOTAGFILE,PRDCR.DOC.PREF,RS,Residence Address
CANDOTAGFILE,PRDCR.DOC.PREF,VA,Vacation Address
CANDOTAGFILE,PRDCR.CNTCT.PREF,BB,Business Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,B,Business Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,BE,Business E-mail
CANDOTAGFILE,PRDCR.CNTCT.PREF,BF,Business Facsimile
CANDOTAGFILE,PRDCR.CNTCT.PREF,BR,Branch Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,CL,Cellular Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,HO,Home Office/Back Office Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,PG,Pager
CANDOTAGFILE,PRDCR.CNTCT.PREF,RE,Resident Email
CANDOTAGFILE,PRDCR.CNTCT.PREF,RF,Resident Facsimile
CANDOTAGFILE,PRDCR.CNTCT.PREF,RS,Residence Phone
CANDOTAGFILE,PRDCR.CNTCT.PREF,VM,Voice Mail
CANDOTAGFILE,RES.NONRES.IND,R,Resident
CANDOTAGFILE,RES.NONRES.IND,N,Non-Resident
CANDOTAGFILE,LIC.TYP,'00',Agent
CANDOTAGFILE,LIC.TYP,'01',Broker
CANDOTAGFILE,LIC.TYP,'02',Producer
CANDOTAGFILE,LIC.TYP,'03',Agency/Firm
CANDOTAGFILE,LIC.TYP,'04',Temporary
CANDOTAGFILE,LIC.TYP,0,Agent
CANDOTAGFILE,LIC.TYP,1,Broker
CANDOTAGFILE,LIC.TYP,2,Producer
CANDOTAGFILE,LIC.TYP,3,Agency/Firm
CANDOTAGFILE,LIC.TYP,4,Temporary
CANDOTAGFILE,LIC.STATUS,AC,Active
CANDOTAGFILE,LIC.STATUS,IA,Inactive
CANDOTAGFILE,LIC.STATUS,PD,Pending 
CANDOTAGFILE,LIC.STATUS,PN,Pending License Number
CANDOTAGFILE,LIC.STATUS,RJ,Rejected
CANDOTAGFILE,LIC.STATUS,SU,Suspended
CANDOTAGFILE,LIC.STATUS,TR,Terminated
CANDOTAGFILE,LIC.STATUS,WD,Withdrawn
CANDOTAGFILE,LIC.LOA,DS,Disability/Health
CANDOTAGFILE,LIC.LOA,FX,Fixed Annuity
CANDOTAGFILE,LIC.LOA,LI,Life
CANDOTAGFILE,LIC.LOA,LT,Long Term Care
CANDOTAGFILE,LIC.LOA,LP,Long Tem Care Partnership
CANDOTAGFILE,LIC.LOA,PN,Pre-need (Funeral)
CANDOTAGFILE,LIC.LOA,VA,Variable Annuity
CANDOTAGFILE,LIC.LOA,VL,Variable Life
}}}LNACNF_Project.dproj
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <ProjectGuid>{A36A8EC8-1332-40AD-8D16-1FECCE888AB4}</ProjectGuid>
        <MainSource>LNACNF_Project.dpr</MainSource>
        <Base>True</Base>
        <Config Condition="'$(Config)'==''">Debug</Config>
        <TargetedPlatforms>1</TargetedPlatforms>
        <AppType>Application</AppType>
        <FrameworkType>VCL</FrameworkType>
        <ProjectVersion>18.4</ProjectVersion>
        <Platform Condition="'$(Platform)'==''">Win32</Platform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Base)'=='true') or '$(Base_Win32)'!=''">
        <Base_Win32>true</Base_Win32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''">
        <Base_Win64>true</Base_Win64>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
        <Cfg_1>true</Cfg_1>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''">
        <Cfg_1_Win32>true</Cfg_1_Win32>
        <CfgParent>Cfg_1</CfgParent>
        <Cfg_1>true</Cfg_1>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
        <Cfg_2>true</Cfg_2>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='iOSDevice64' and '$(Cfg_2)'=='true') or '$(Cfg_2_iOSDevice64)'!=''">
        <Cfg_2_iOSDevice64>true</Cfg_2_iOSDevice64>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''">
        <Cfg_2_Win32>true</Cfg_2_Win32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base)'!=''">
        <DCC_DcuOutput>dcuout</DCC_DcuOutput>
        <DCC_ExeOutput>exe</DCC_ExeOutput>
        <DCC_UsePackage>vcl;rtl;vclx;indy;vclie;xmlrtl;inetdbbde;inet;inetdbxpress;dbrtl;soaprtl;dsnap;VclSmp;dbexpress;vcldb;dbxcds;inetdb;bdertl;vcldbx;adortl;ibxpress;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOfficeXP;ILCORP50;addict3_d7;addict3db_d7;AUSComponents;PKBOOKMARK;PTCommon;ptEtsPanel;LproComponents;PTZipCodeCityState;Tee97;TeeUI97;TeeDB97;TeePro97;TeeGL97;TeeImage97;TeeLanguage97;TeeWorld97;FlexCel_Report;RESTBackendComponents;CloudService;FlexCel_XlsAdapter;soaprtl;soapmidas;RESTComponents;FlexCel_Pdf;FireDACIBDriver;FireDACCommon;soapserver;FireDACCommonDriver;inet;FireDAC;FireDACSqliteDriver;FlexCel_Core;FlexCel_Render;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_Namespace>Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;System;Xml;Data;Datasnap;Web;Soap;Winapi;Data.Win;Xml.Win;System.Win;Datasnap.Win;Web.Win;Soap.Win;Bde;VCLTee;$(DCC_Namespace)</DCC_Namespace>
        <Icon_MainIcon>$(BDS)\bin\delphi_PROJECTICON.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.LGAmerica.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>units;EXCH;CommonUnits;..\..\_commonvnext;C:\Projects\_Externals\nativexml;DCUOut;CommonUnits\Synapse;$(D3P)\Source;$(BDSlib)\win32\release;$(BDSlib)\win32\Debug;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <DCC_Define>SQL;$(DCC_Define)</DCC_Define>
        <DCC_DcpOutput>$(D3P)\$(Platform)\DCP</DCC_DcpOutput>
        <DCC_BplOutput>$(D3P)\$(Platform)\BPL</DCC_BplOutput>
        <SanitizedProjectName>LNACNF_Project</SanitizedProjectName>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win32)'!=''">
        <DCC_UsePackage>DBXSqliteDriver;dxSpreadSheetCoreDialogsRS25;dxSkinOffice2007PinkRS25;dxSkinMcSkinRS25;vclFireDAC;cxExportRS25;dxHttpIndyRequestRS25;tethering;dxPScxCommonRS25;addict3db_;FireDACADSDriver;Kodak_Image_Edit;cxPivotGridOLAPRS25;JvPluginSystem;vcltouch;dxSkinDarkRoomRS25;dxSkinDarkSideRS25;Intraweb;svn;JvBands;JvJans;cxLibraryRS25;JvDotNetCtrls;dxSkinOffice2007SilverRS25;dxSkinBlackRS25;dxSkinOffice2007BlueRS25;dxSkinOffice2007BlackRS25;AcroPDF;XMLPartner_PD;Tee925;dxSkinVS2010RS25;dxSkinFoggyRS25;dxSkinSevenRS25;dxSpreadSheetConditionalFormattingDialogsRS25;dxSkinSpringTimeRS25;TeeWorld925;TeeTree2D25Tee9;VCLRESTComponents;XMLPartner_PR;RvCore;cxPageControlRS25;dxSkinLilianRS25;dxPSLnksRS25;RvCompiler;bindengine;dxFireDACServerModeRS25;JvHMI;FireDACMySQLDriver;dxSkinOffice2013LightGrayRS25;dxSkinMetropolisRS25;dxSkinOffice2016DarkRS25;bindcompdbx;dxSkinBlueprintRS25;dxSkinStardustRS25;IndyIPServer;dxPSdxLCLnkRS25;NxDBGridDsgn_dxe;IndySystem;dxSkinOffice2007GreenRS25;dsnapcon;VirtualTreesR;dxLayoutControlRS25;FireDACMSAccDriver;fmxFireDAC;RvBarcode;vclimg;NxCommonDsgn_dxe;Jcl;NxAddonsRun_dxe;dxPScxTLLnkRS25;RvStandard;dxSkinVisualStudio2013LightRS25;dxSpreadSheetRS25;RvReport;TeeMaker125;cxGridRS25;dxSpreadSheetCoreConditionalFormattingDialogsRS25;dxSkinTheAsphaltWorldRS25;DbxCommonDriver;JvManagedThreads;dxSkinHighContrastRS25;JvTimeFramework;fmxobj;dxPScxGridLnkRS25;D7MStreams;PTExtPanels;DbxClientDriver;dxPSCoreRS25;CodeSiteExpressPkg;dxmdsRS25;JvSystem;JvStdCtrls;dxSkinOffice2016ColorfulRS25;appanalytics;LockBox3DR;IndyIPClient;bindcompvcl;dxThemeRS25;NxDBGridRun_dxe;JvDocking;JvPascalInterpreter;FMXTee925;JclVcl;NxCommonRun_dxe;NxGridRun_dxe;cxVerticalGridRS25;JvControls;JvPrintPreview;dxADOServerModeRS25;dxSkinPumpkinRS25;dxCoreRS25;dxSkinValentineRS25;FMXTeeImport925;DBXInterBaseDriver;RvGraphics;TeeDB925;dxSkinOffice2010BlueRS25;JvGlobus;svnui;dxSkinMoneyTwinsRS25;dxSkinSilverRS25;JvMM;dxSkinOffice2013WhiteRS25;bindcompfmx;JvNet;FMXTeePro925;JvAppFrm;TeeImport925;dxOfficeCoreRS25;fmx;fmxdae;dxSkinBlueRS25;dxPScxPivotGridLnkRS25;VirtualTreesD;dxSkinDevExpressDarkStyleRS25;JvWizards;FMXTeeLanguage925;IndyCore;FMXTeeDB925;XMLPartner_CR;JvPageComps;NxCollectionRun_dxe;JvDB;dxSkinLiquidSkyRS25;dxPScxExtCommonRS25;cxPivotGridRS25;dxPSdxSpreadSheetLnkRS25;dxSpreadSheetReportDesignerRS25;JclDeveloperTools;dxSkinCoffeeRS25;JvCmp;DBXMySQLDriver;NxInspectorDsgn_dxe;FireDACCommonODBC;dxSkinOffice2010SilverRS25;cxTreeListRS25;LockBoxDR;IndyIPCommon;JvCustom;dxSkinLondonLiquidSkyRS25;dxPScxVGridLnkRS25;dclRave;JvXPCtrls;dxSkinsCoreRS25;dxComnRS25;TeeUI925;dxSkinWhiteprintRS25;FmxTeeUI925;dxSkinVisualStudio2013BlueRS25;madExcept_;dxSkinGlassOceansRS25;dxSkinMetropolisDarkRS25;dxSkinOffice2013DarkGrayRS25;madBasic_;dxSkinSharpPlusRS25;dxSpreadSheetCoreRS25;dxServerModeRS25;dxSkinCaramelRS25;dxPScxPCProdRS25;NxCollectionDsgn_dxe;JvCore;JvCrypt;FireDACPgDriver;dxSkiniMaginaryRS25;cxEditorsRS25;TeePro925;TeeGL925;JvDlgs;JvRuntimeDesign;NxGridDsgn_dxe;vclwinx;dxSkinSevenClassicRS25;RvEngine;madDisAsm_;cxDataRS25;CustomIPTransport;vcldsnap;dxSkinSharpRS25;bindcomp;FMXTree25;dxSkinVisualStudio2013DarkRS25;cxPivotGridChartRS25;dxSkinOffice2010BlackRS25;dxDBXServerModeRS25;dxSkinDevExpressStyleRS25;dxGDIPlusRS25;GW_Crap;VCL_FlexCel_Core;TeeImage925;NxSheetRun_dxe;TeeLanguage925;dsnapxml;IndyProtocols;addict3_;dxSkinSummer2008RS25;JclContainers;NxInspectorRun_dxe;dxSkinXmas2008BlueRS25;fmxase;$(DCC_UsePackage)</DCC_UsePackage>
        <BT_BuildType>Debug</BT_BuildType>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.embarcadero.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>$(BDSlib)\win32\release;$(D3P)\Win32\CommonDCU;$(BDSlib)\win32\release;$(BDSlib)\win32\debug;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <Manifest_File>$(BDS)\bin\default_app.manifest</Manifest_File>
        <DCC_UseMSBuildExternally>false</DCC_UseMSBuildExternally>
        <DCC_BplOutput>$(D3P)\Win32\BPL</DCC_BplOutput>
        <DCC_DcpOutput>$(D3P)\Win32\DCP</DCC_DcpOutput>
        <DCC_Define>madexcept;$(DCC_Define)</DCC_Define>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win64)'!=''">
        <Icon_MainIcon>LNACNF_Project_Icon.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1)'!=''">
        <DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
        <DCC_DebugInformation>0</DCC_DebugInformation>
        <DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
        <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2)'!=''">
        <DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
        <DCC_Optimize>false</DCC_Optimize>
        <DCC_GenerateStackFrames>true</DCC_GenerateStackFrames>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_iOSDevice64)'!=''">
        <BT_BuildType>Debug</BT_BuildType>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=;ProgramID=com.embarcadero.$(MSBuildProjectName)</VerInfo_Keys>
        <DCC_MapFile>3</DCC_MapFile>
        <Debugger_RunParams>/ini=bantestq /test /EP</Debugger_RunParams>
    </PropertyGroup>
    <ItemGroup>
        <DelphiCompile Include="$(MainSource)">
            <MainSource>MainSource</MainSource>
        </DelphiCompile>
        <DCCReference Include="units\LNACNF.pas">
            <Form>Form1</Form>
        </DCCReference>
        <BuildConfiguration Include="Debug">
            <Key>Cfg_2</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
        <BuildConfiguration Include="Base">
            <Key>Base</Key>
        </BuildConfiguration>
        <BuildConfiguration Include="Release">
            <Key>Cfg_1</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
    </ItemGroup>
    <ProjectExtensions>
        <Borland.Personality>Delphi.Personality.12</Borland.Personality>
        <Borland.ProjectType/>
        <BorlandProject>
            <Delphi.Personality>
                <Source>
                    <Source Name="MainSource">LNACNF_Project.dpr</Source>
                </Source>
                <Excluded_Packages>
                    <Excluded_Packages Name="C:\Projects\_Externals\Tokyo\Win32\BPL\LockBox3FMXDD250.bpl">TurboPack LockBox 3 FMX designtime package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcboffice2k250.bpl">Embarcadero C++Builder Office 2000 Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcbofficexp250.bpl">Embarcadero C++Builder Office XP Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dcloffice2k250.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dclofficexp250.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
                </Excluded_Packages>
            </Delphi.Personality>
            <Platforms>
                <Platform value="iOSDevice64">False</Platform>
                <Platform value="Linux64">False</Platform>
                <Platform value="Win32">True</Platform>
                <Platform value="Win64">False</Platform>
            </Platforms>
        </BorlandProject>
        <ProjectFileVersion>12</ProjectFileVersion>
    </ProjectExtensions>
    <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
    <Import Project="$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj" Condition="Exists('$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj')"/>
</Project>
}}}LNACNF.dfm
object Form1: TForm1
  Left = 663
  Top = 328
  Caption = 'LNA Confirm'
  ClientHeight = 194
  ClientWidth = 390
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 390
    Height = 194
    Align = alClient
    TabOrder = 0
    object Button1: TButton
      Left = 128
      Top = 64
      Width = 137
      Height = 49
      Caption = 'Go'
      TabOrder = 0
      OnClick = Button1Click
    end
  end
end
}}}LNACNF
Unit LNACNF;

// This DTCC LNA program merges State-Level change info from Admin System with State-Level requested changes
// (from Broker/Dealers via inbound LNA) and then determines which outbound LNA "confirms" should be sent.
// To do that, it tries to determine if the data change found in Admin System ties to one of the received
// LNA requests from a BD.  If so, we confirm it as such.  If not, any confirm that may end up being produced
// is made on the basis that this data change was Carrier-Originated.
//
//   CHANGE LOG:
//
//   INIT  CHGDATE  TAG      PURPOSE
//   --- ---------- ------   ---------------------------------------------------------------------------
//   GM :2016-04-27 CHG001 - Avoid writing Penn (7977) B5311 cando recd for non-NY business
//   GM :2021-10-07 SY5528 - Sept2020 mod (to move away from SSN, toward NPN) needs more work
//   GM :2022-04-22 SIY6989- Add a check - to ensure ALL FIVE input files are there and available... if not, throw err
//

Interface

Uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler,
  IdIOHandlerStream, adodb, db, DateUtils, ComCtrls, SABUtils, ExtCtrls,
  ulgaini;

Type
  TForm1 = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Procedure Button1Click(Sender: tObject);
  Private
    { Private declarations }
  Public
    { Public declarations }
    log: ttextfileout;
    Function DtNow(DT: tDateTime): AnsiString;
  End;

Var
  Form1: TForm1;

Implementation

{$R *.dfm}

Function TForm1.DtNow(DT: tDateTime): AnsiString;
Begin
  Result := EmptyStr;
  Result := datetostr(DT) + ' ' + timetostr(DT) + ': ';
End;

Function IsStrANumber(Const S: AnsiString): Boolean;
Var
  P: PAnsiChar;
Begin
  P := PAnsiChar(S);
  Result := False;
  While P^ <> #0 Do
  Begin
    If Not (P^ In ['0'..'9']) Then
      Exit;
    Inc(P);
  End;
  Result := True;
End;

//   SUBROUTINES

//        M A I N L I N E

Procedure TForm1.Button1Click(Sender: tObject);
Var
  BMASTOUT, BFINDER, BFINISH, XFINDER, CARRIERO, OCARRIER, CARRIERN, CANDO, SCANDO, CANDOSCANDO,
    FRMADM1, SFRMADM1, FRMADM2, SFRMADM2, myFile, File5301: TextFile;
  openDialog: TOpenDialog;
  workTSL: tStringList;
  CAROTSL: tStringList;
  readcnt, n, rc: Integer;
  records: longint;
  today: tDateTime;
  MISSFILE: AnsiString;
  testit: AnsiString;
  XC7977X, XC7977UB, XC7977RJ, XC7977ML, XC7976X, XC7976UB, XC7976RJ, XC7976ML, XC7977MS, XC7976MS, XC7977ZZ, XC7976ZZ: AnsiString;
  RC7977X, RC7977UB, RC7977RJ, RC7977ML, RC7976X, RC7976UB, RC7976RJ, RC7976ML, RC7977MS, RC7976MS, RC7977ZZ, RC7976ZZ: Integer;
  FNamBM, somejunk, inrec, id, state, zro, ASAV, xinrec, oput, key, dtccpart,
    spac6, spac50, spac300, Arec, Ahead, Ameat, Brec, Bhead, Bmeat, FirstCf, IntrmCf, FinalCf, IntrmSt,
    FinalSt, CARHEAD1, CARHEAD2, DTCCDT, NEED5301, SrtIFils, SrtOFil, fdir: AnsiString;
  CurDt : string;
  // SY5528 MODIFICATION BEGIN   - add a new field
  WKSTRG8 : AnsiString;
  // SY5528 MODIFICATION END

Label
  NEXTREC, WRTSDNOW, ITISAB, MATCH, SETASAV, NOMSKPF, MNOINTBF, MNOFINBF, MNOSKPF, MCLRASAV, INTCFOK, NEXTFA1, NEXTFA2,
    NEXTCD, KEEPIT, KEEPIT2, PUTIT, CHECKIT, SKIPPUT;

Begin
  Button1.Enabled := False;
  fdir := WorkAreaUNC + 'DtccFiles\LNA\';
  zro := '0';
  spac6 := AnsiString(stringofchar(' ', 6));
  spac50 := AnsiString(stringofchar(' ', 50));
  spac300 := AnsiString(stringofchar(' ', 300));
  somejunk := AnsiString(spac300 + '.' + spac300);
  ASAV := spac300;

  DateTimeToString(CurDt, 'yyyymmddhhnnsszz', Now);
  log := ttextfileout.Create(Format('%sLnaConfirm_%s.log', [WorkAreaUNC + 'DtccFiles\Log\', CurDt]));
  log.Write(DtNow(Now) + 'Start LNA Confirm.');
  today := Now;
  CurDt := FormatDateTime('ddddd', today);        // CurDt will now have f format like this:  05/31/2000
  workTSL := tStringList.Create;
  workTSL.Text := StringReplace(CurDt, '/', #13#10, [rfReplaceAll]);  // Split the date value into it's sub-components (all are 'AnsiString' components)
  If Length(workTSL[0]) < 2 Then
    workTSL[0] := zro + workTSL[0];
  If Length(workTSL[1]) < 2 Then
    workTSL[1] := zro + workTSL[1];
  CurDt := workTSL[2] + workTSL[0] + workTSL[1];
  workTSL.Free; // free this work area now so it can be re-used for other things





   // BMASTER presence is checked down below...  but presence of other 4 reqd files is checked now

  MISSFILE := '';

  If Not FileExists(fdir + 'CANDO.TXT') Then MISSFILE := 'CANDO.TXT';
  If Not FileExists(fdir + 'XNSTLWP.txt') Then MISSFILE := 'XNSTLWP.txt';
  If Not FileExists(fdir + 'XNSTL17.txt') Then MISSFILE := 'XNSTL17.txt';
  If Not FileExists(fdir + 'M5301.txt') Then MISSFILE := 'M5301.txt';

  if MISSFILE <> '' then
   begin
     log.Write(DtNow(Now) + fdir + 'HALTING JOB: this required file is missing:' + MISSFILE);
     Application.ProcessMessages;
     ShowMessage('* * CALL SUPPORT * * In Workarea DTCCFILES/LNA, this reqd file is absent:' + MISSFILE);
     Halt(0);
     close;
   end;







  //ShowMessage('Input Master File Name will be asked for next.  If doing a normal run, select BMASTER.txt as the input.');

  // Now, allow user to select the "input" file (a TXT file)
{  openDialog := TOpenDialog.Create(self);
  openDialog.InitialDir := GetCurrentDir;
  openDialog.Options := [ofFileMustExist];
  openDialog.Filter := ' TXT files|*.txt';
  openDialog.Title := 'Select which BMASTER to run with';
  openDialog.FileName := 'BMASTER.txt';
  If openDialog.Execute Then
  Begin
    workTSL := tStringList.Create;
    workTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
    FNamBM := workTSL[workTSL.Count - 1];
    ShowMessage('Selected File:' + FNamBM);
  End
  Else
  Begin
    ShowMessage('File Selection Cancelled; Run Aborted !');
    Halt(0);
  End; }



  If FileExists(fdir + 'BMASTER.TXT') Then
  Begin
    //gm workTSL := tStringList.Create;
    //gm workTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
    //gm FNamBM := workTSL[workTSL.Count - 1];
    //ShowMessage('Selected File:' + FNamBM);
    FNamBM := 'BMASTER.TXT';
  End
  Else
  Begin
    log.Write(DtNow(Now) + fdir + 'HALTING JOB: this required file is missing:BMASTER.txt ');
    Application.ProcessMessages;
    ShowMessage('* * CALL SUPPORT * * In Workarea DTCCFILES/LNA, this reqd file is absent:BMASTER.txt ');
    log.Free;
    Button1.Enabled := True;
    Halt(0);
    close;
  End;




  //
  // AT THIS POINT, WE KNOW OUR 3 INPUTS.
  // 1. BMASTER: this input file was created in a prior run of this program.  It already contains the needed sort header.  This file keeps a list of in-progress state-level actions requested by BD's via inbound LNA.
  // 2. CANDO: this file doesn't have a sort header yet (this pgm will add one). This file is today's additions intended to be included into the BMASTER based on this program's processing.
  // 3. FRMADM1: this file has no sort headers yet (this pgm will add header). This file shows state-level activities of late within the Carrier's admin system.
  //
  // The BMASTER will be rebuilt (adding data, etc) during this run.  When this pgm runs tomorrow, we'll need a "BMASTER" to read in, too... but the output file and the input file cannot have the same name
  // for right now... SO, this next step is to rename the master file to BMASTIN.txt (the 'output' version of this file out of this pgm will be created as "BMASTER.txt").
  //
  If FNamBM <> 'BMASTIN.txt' Then
  Begin
    log.Write(DtNow(Now) + 'Renaming BMASTER.txt to BMASTIN.txt');
    If FileExists(fdir + 'BMASTIN_RENAMED' + CurDt + '.txt') Then
      DeleteFile(fdir + 'BMASTIN_RENAMED' + CurDt + '.txt');
    RenameFile(fdir + 'BMASTIN.txt', fdir + 'BMASTIN_RENAMED' + CurDt + '.txt');
    RenameFile(fdir + FNamBM, fdir + 'BMASTIN.txt');
    FNamBM := fdir + 'BMASTIN.txt';
  End;

  // Now, we need CANDO and FRMADM files to have sort headers just like that which lives on the BMASTER... so we can sort all these files together and then process them.
  // Next step is to create a working version of CANDO and FRMADM files that has the needed sort headers.  The sort-ready version of CANDO.txt will be "SCANDO.txt".  Sort-ready FRMADM1 will be SFRMADM1.
  log.Write(DtNow(Now) + 'Work on William Penn.');
  AssignFile(FRMADM1, fdir + 'XNSTLWP.txt');      // input William Penn file from Admin System
  Reset(FRMADM1);
  AssignFile(SFRMADM1, fdir + 'SFRMADM1.txt'); // output version of the file (recd is the same, but has had a sort header added to the front of each recd)
  ReWrite(SFRMADM1);
  While Not Eof(FRMADM1) Do
  Begin
    Application.ProcessMessages;
    ReadLn(FRMADM1, inrec);
    //
    If Copy(inrec, 1, 9) = 'AAAAAAAAA' Then
    Begin
      CARHEAD1 := inrec;
      Goto NEXTFA1;
    End;

    // we need an actual DTCC participant number as the first 4 bytes of the sort-header... so, determine one to plug in here:
    dtccpart := Copy(inrec, 52, 4);

    // SY5528 MODIFICATION BEGIN
    // set 10-position ID field for use in the key we are constructing    (this should contain agent id in virtually all instances)
    //If Copy(inrec, 56, 9) = Copy(spac300, 1, 9) Then    // SY5528 commented this line out
    If Copy(inrec, 147, 10) = Copy(spac300, 1, 10) Then   // SY5528: See if the NPN field is blank
      id := Copy(inrec, 65, 10) // if the SSN is blank within this FRMADM record, set ID to the value in the NAMEID field
    Else
      id := Copy(inrec, 147, 10); // if npn field is non-blank within this FRMADM rec, set ID to the value in the npn field
    // SY5528 MODIFICATION END

    state := Copy(inrec, 46, 2);                  // grab state code
    key := dtccpart + id + state; // begin constructing key by copying in dtcc participant + id field + 'state' code
    key := key + 'A'; // assume that this FRMADM record is here for an "Appointment" related reason (not a License related reason);
    key := key + 'A';                             // indicate that data source is from an Admin System
    key := key + Copy(inrec, 86, 1);              // pick up Lic/Appt Status indicator
    key := key + Copy(spac300, 1, 33);            // add filler of blanks here
    //
    WriteLn(SFRMADM1, key + ',' + inrec);         // write the comma-separated output record now
    NEXTFA1:
  End;
  CloseFile(FRMADM1);
  CloseFile(SFRMADM1);

  log.Write(DtNow(Now) + 'Work on Banner Life.');
  AssignFile(FRMADM2, fdir + 'XNSTL17.txt');      // input Banner file from Admin System
  Reset(FRMADM2);
  AssignFile(SFRMADM2, fdir + 'SFRMADM2.txt'); // output version of the file (recd is the same, but has had a sort header added to the front of each recd)
  ReWrite(SFRMADM2);
  While Not Eof(FRMADM2) Do
  Begin
    Application.ProcessMessages;
    ReadLn(FRMADM2, inrec);

    If Copy(inrec, 1, 9) = 'AAAAAAAAA' Then
    Begin
      CARHEAD2 := inrec;
      Goto NEXTFA2;
    End;

    // we need an actual DTCC participant number as the first 4 bytes of the sort-header... so, determine one to plug in here:
    dtccpart := Copy(inrec, 52, 4);

    // SY5528 MODIFICATION BEGIN
    // set 10-position ID field for use in the key we are constructing    (this should contain agent id in virtually all instances)
    //If Copy(inrec, 56, 9) = Copy(spac300, 1, 9) Then    //SY5528 Commented out this line
    If Copy(inrec, 147, 10) = Copy(spac300, 1, 10) Then   //SY5528 See if NPN field is blank
      id := Copy(inrec, 65, 10) // if the NPN was blank within this FRMADM record, set ID to the value in the NAMEID field
    Else
      id := Copy(inrec, 147, 10); // if npn field is non-blank within this FRMADM rec, set ID to the value in the npn field
    // // SY5528 MODIFICATION END

    state := Copy(inrec, 46, 2);                  // grab state code
    key := dtccpart + id + state; // begin constructing key by copying in dtcc participant + id field + 'state' code
    key := key + 'A'; // assume that this FRMADM record is here for an "Appointment" related reason (not a License related reason);
    key := key + 'A';                             // indicate that data source is from an Admin System
    key := key + Copy(inrec, 86, 1);              // pick up Lic/Appt Status indicator
    key := key + Copy(spac300, 1, 33);            // add filler of blanks here
    //
    WriteLn(SFRMADM2, key + ',' + inrec);         // write the comma-separated output record now
    NEXTFA2:
  End;
  CloseFile(FRMADM2);
  CloseFile(SFRMADM2);

  log.Write(DtNow(Now) + 'Work on LNA inbound file.');
  Try
    AssignFile(CANDO, fdir + 'CANDO.txt'); // input file from inbound LNA (from our DTCC Broker/Dealer partners)
    Reset(CANDO);
    AssignFile(SCANDO, fdir + 'SCANDO.txt'); // output version of the file (recd is the same, but has had a sort header added to the front of each recd)
    ReWrite(SCANDO);
    AssignFile(File5301, fdir + 'M5301.txt'); // open this "5301" master file so as to be able to append more 5301 record sets onto the end of the file
    Append(File5301);
    log.Write(DtNow(Now) + 'Begin read thru CANDO.txt');
    Try
      readcnt := 0;
      While Not Eof(CANDO) Do
      Begin
        Application.ProcessMessages;
        ReadLn(CANDO, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'CANDO.txt line rec ' + IntToStr(readcnt));
        // SY5528 MODIFICATION BEGIN   -   change prior value of 110 to now be 111
        If Copy(inrec, 111, 5) = 'B5301' Then
          Goto KEEPIT;
        If Copy(inrec, 111, 5) <> 'B5311' Then
          Goto NEXTCD;
        // SY5528 MODIFICATION END

        KEEPIT:
        dtccpart := Copy(inrec, 1, 4);            // set participant

        // SY5528 MODIFICATION BEGIN - chg len values of 9 to be 10, chg 304 to 305, chg 155 to 156, chg 110 to 111
        // set 10-position ID field for use in the key we are constructing    (this should contain agent NPN in virtually all instances)
        If Copy(inrec, 94, 10) = Copy(spac300, 1, 10) Then          //  See if the NPN field is blank
          id := Copy(inrec, 305, 10) // if npn field is blank within this BD record, set this to License Number from this recd
        Else
          id := Copy(inrec, 94, 10); // if npn field is non-blank, use the npn

        state := Copy(inrec, 156, 2);

        key := dtccpart + id + state; // begin constructing by copying dtccparticipant and id and state

        If Copy(inrec, 111, 5) <> 'B5301' Then
          Goto KEEPIT2;
        // SY5528 MODIFICATION END

        key := key + Copy(spac300, 1, 28) + DTCCDT;  // finish building the 'key' for 5301 records     (first byte of the 28 spaces will act as 'data source' field for later sort)
        WriteLn(File5301, key + ',' + inrec); // add the current 5301 record set to the end of this file (will sort this file in a moment...)
        Goto NEXTCD;
        KEEPIT2:
        key := key + 'A'; // for this Carrier, assume this is always an A because whatever is stored/done for licenses also applies to 'appointments'
        key := key + 'B';                         // show that this record came from BD
           // SY5528 MODIFICATION BEGIN - changed 107 to 108
        If Copy(inrec, 108, 1) = 'T' Then
           // SY5528 MODIFICATION END
        Begin // If the BD-submitted transaction is a 'termination' then we should begin watching for a lic/appt status of T
          FinalSt := 'T';
          FinalCf := '      ';
          IntrmSt := ' ';
          IntrmCf := '      ';
          FirstCf := '      ';
        End
        Else
        Begin
          FinalSt := 'A';
          FinalCf := 'ACACFR';
          IntrmSt := 'P';
          IntrmCf := 'ACPSFR';
          FirstCf := 'ACSBFR';
        End;

        If IntrmSt <> 'P' Then
          Goto INTCFOK;

        If (state = 'PA') Or (state = 'MT') Or (state = 'OR') Then
          IntrmCf := 'ACPDFR';

        INTCFOK:
        key := key + FinalSt + FinalCf + IntrmSt + IntrmCf + FirstCf + Copy(spac300, 1, 14);


        // CHG001 - 04/27/2016:  Avoid writing Penn (7977) B5311 cando recd for non-NY business

        testit := Copy(inrec, 46, 4);
        If testit <> '7977' Then
          Goto WRTSDNOW;

        // SY5528 MODIFICATION BEGIN - chg 110 to 111, chg 155 to 156
        testit := Copy(inrec, 111, 5);
        If testit <> 'B5311' Then
          Goto WRTSDNOW;

        testit := Copy(inrec, 156, 2);
        If testit <> 'NY' Then
          Goto NEXTCD;
        // SY5528 MODIFICATION END


        WRTSDNOW:
        WriteLn(SCANDO, key + ',' + inrec);       // write the comma-separated output record now

        NEXTCD:
        If Copy(inrec, 1, 6) = '1TRANS' Then
          DTCCDT := Copy(inrec, 7, 8);
      End;
      CloseFile(File5301);
    Except
      log.Write(DtNow(Now) + 'Exception while processing LNA inbound file.');
      log.Free;
      Button1.Enabled := True;
      close;
    End;
  Finally
    log.Write(DtNow(Now) + 'Finished work on LNA inbound file.');
    CloseFile(CANDO);
    CloseFile(SCANDO);
  End;
  // now, sort the 5301 master
  // SrtIFils := 'M5301.txt+BFINDER.txt';
  // SrtOFil := 'XBFINDER.txt.txt';
  // OtSort(SrtIFils, SrtOFil, 's(#1,c,d)', records, rc);

  //  Now that all the input files have the proper sort header, invoke the sort to put data from all input files into a single work file - and in the proper order for rest of this pgm to work.
  //SrtIFils := 'c:file1.txt+c:file2.txt+c:file3.txt';
  SrtIFils := FNamBM + '+' + fdir + 'SCANDO.txt' + '+' + fdir + 'SFRMADM1.txt' + '+' + fdir + 'SFRMADM2.txt';
  SrtOFil := fdir + 'LNACSRT.txt';
  OtSort(SrtIFils, SrtOFil, 's(#1,c,a)', records, rc);

  // NEXT, we assign and open the 5 output files used by this program.
  log.Write(DtNow(Now) + 'Work on Sorted file LNACSRT.txt');
  Try
    CAROTSL := tStringList.Create;
    AssignFile(BFINDER, fdir + 'BFINDER.txt');
    ReWrite(BFINDER);
    AssignFile(OCARRIER, fdir + 'OCARRIER.txt');
    ReWrite(OCARRIER);
    WriteLn(OCARRIER, CARHEAD1);
    WriteLn(OCARRIER, CARHEAD2);
    AssignFile(CARRIERN, fdir + 'CARRIERN.txt');
    ReWrite(CARRIERN);
    WriteLn(CARRIERN, CARHEAD1);
    WriteLn(CARRIERN, CARHEAD2);
    AssignFile(BFINISH, fdir + 'BFINISH.txt');
    ReWrite(BFINISH);
    AssignFile(BMASTOUT, fdir + 'BMASTER.txt');
    ReWrite(BMASTOUT);
    WriteLn(BMASTOUT, '.');
    AssignFile(myFile, SrtOFil); // input file   (data here came from 4 sources - one of which already had sort-headers, and others had sort headers applied via above logic
    Reset(myFile);

    // SY5528 MODIFICATION BEGIN
    WKSTRG8 := CurDT;                         // SY5528 - move string value to ansistring "WKSTRG8" field
    // SY5528 MODIFICATION END



    // Now that the input data is all sorted together into a single file, process that data, separating the data as needed into various outputs.
    Try
      readcnt := 0;
      While Not Eof(myFile) Do
      Begin
        Application.ProcessMessages;
        ReadLn(myFile, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'LNACSRT.txt line rec ' + IntToStr(readcnt));

        If Copy(inrec, 1, 1) = '.' Then
          Goto NEXTREC;

        If Copy(inrec, 18, 1) <> 'A' Then
          Goto ITISAB; // did this record come from Carrier (via the FRMADM file)?  If no, then branch (it came from LNA inbound)

        If Copy(ASAV, 1, 6) = spac6 Then
          Goto SETASAV; //  if the save-off area doesn't have a real A record in it, just go and save the current A record there.

        oput := Copy(ASAV, 54, Length(ASAV) - 53);
        CAROTSL.Add(Copy(oput, 48, 8));
        WriteLn(OCARRIER, oput); //  write key-less version of the save-off A rec here (recds in this file drive notific of Carrier Originated trxns to BD)

        SETASAV:
        ASAV := inrec;                            //  just save this A record;
        Goto NEXTREC;

        ITISAB:
                                               // SY5528 MODIFICATION BEGIN   -  this code will end up keeping only NEWLY formatted master recds
                                               //"remove SSN" mod done in Sep,2020 added a byte to SSN key fld (which is now used for NPN) via CANDO, so we
        if Copy(inrec, 156, 1) = '|' then      // need to purposely leave behind any B rec (from BMASTER) that is formatted in the old way
          Goto NEXTREC;                        // SY5528 MODIFICATION END


        If Copy(ASAV, 1, 17) + 'B' = Copy(inrec, 1, 18) Then
          Goto MATCH; //  except for 'source' of record the 18-byte keys from the 2 record types do match... so, branch

        If Copy(inrec, 33, 6) = spac6 Then
          Goto NOMSKPF; // if this B recd says there is no 'initial' B Finder needed, skip the finder build

        Move(inrec[33], inrec[39], 6);            //  indicate which confirm type is being done for this B

        // SY5528 MODIFICATION BEGIN
        Move(WKSTRG8[1], inrec[45], 8);           // SY5528 - use the ansistring value to complete inrecd
        //Move(CurDt[1], inrec[45], 8);           // set today's date as the time we last sent a confirm  //SY5528 commented this out
        // SY5528 MODIFICATION END

        WriteLn(BFINDER, inrec); //  write keyed version of this record (need the key since the value at displcmt 40 in that key shows which finder must come out now
        Move(spac6[1], inrec[33], 6); //  blank out this field so initial confirm isn't done over and over

        NOMSKPF:
        WriteLn(BMASTOUT, inrec); //  write the (potentially modified) B record to the output 'B' master file

        If Copy(ASAV, 1, 6) = spac6 Then
          Goto NEXTREC; //  if the save-off version of my A record is just a dummy record, move on to next input record now

        oput := Copy(ASAV, 54, Length(ASAV) - 53);
        CAROTSL.Add(Copy(oput, 48, 8));
        WriteLn(OCARRIER, oput); //  write key-less version of the A rec here (recds in this file drive notific of Carrier Originated trxns to BD)
        ASAV := Copy(spac300, 1, Length(ASAV));   //  blank out the save-off A record now
        Goto NEXTREC;

        MATCH:
        oput := Copy(ASAV, 54, Length(ASAV) - 53);
        WriteLn(CARRIERN, oput); //  write key-less version of the A rec here (recds in this file go nowhere)
        Move(ASAV[101], inrec[99], 4); // fix the in-progress area to carry the carrier participant number of the 'event'... not that of any prevsly seen record for this agent

        If Copy(ASAV, 19, 1) <> Copy(inrec, 26, 1) Then
          Goto MNOINTBF; //  if A-rec save-off 'status' (of LP Lic or Appt) does not match the "interim sought status" in the B rec, branch

        Move(inrec[27], inrec[39], 6);            //  indicate which confirm type is being done for this B
        // SY5528 MODIFICATION BEGIN
        Move(WKSTRG8[1], inrec[45], 8);           // SY5528 - use the ansistring value to complete inrecd
        //Move(CurDt[1], inrec[45], 8);           //  set date as last time a confirm went out for this //SY5528 commented this out
        // SY5528 MODIFICATION END
        Move(spac6[1], inrec[33], 6); //  blank out this field to ensure no more 'initial' confirms can come out
        WriteLn(BFINDER, inrec); //  write keyed version of this record (need the key since the value at displcmt 39 in that key shows which finder must come out now
        WriteLn(BMASTOUT, inrec); //  write the modified B record to the output 'B' master file
        Goto MCLRASAV;

        MNOINTBF:
        If Copy(ASAV, 19, 1) <> Copy(inrec, 19, 1) Then
          Goto MNOFINBF; //  if A-rec save-off 'status' (of LP Lic or Appt) does not match the "final sought status" in the B rec, branch

        Move(inrec[20], inrec[39], 6);            //  indicate which confirm type is being done for this B
        // SY5528 MODIFICATION BEGIN
        Move(WKSTRG8[1], inrec[45], 8);           // SY5528 - use the ansistring value to complete inrecd
        //Move(CurDt[1], inrec[45], 8);           // set date to show when we sent a confirm //SY5528 commented this out
        // SY5528 MODIFICATION END

        //xinrec := inrec;
        If Copy(inrec, 39, 6) <> spac6 Then
          WriteLn(BFINDER, inrec); //  write keyed version of this record (need the key since the value at displcmt 39 in that key shows which finder must come out now
        //inrec := xinrec;

        WriteLn(BFINISH, inrec);                  // write this B recd to final resting place (it can produce no more confirms)
        Goto MCLRASAV;

        MNOFINBF:
        If Copy(inrec, 33, 6) = spac6 Then
          Goto MNOSKPF; // if this B recd says there is no 'initial' B Finder needed, don't do an initial finder now

        Move(inrec[33], inrec[39], 6);            //  indicate which confirm type is being done for this B

        // SY5528 MODIFICATION BEGIN
        Move(WKSTRG8[1], inrec[45], 8);           // SY5528 - use the ansistring value to complete inrecd
        //Move(CurDt[1], inrec[45], 8);           // set date to show when we last sent confirm for this // SY5528 commented this out
        // SY5528 MODIFICATION END
        If Copy(inrec, 39, 6) <> spac6 Then
          WriteLn(BFINDER, inrec); //  write keyed version of this record (need the key since the value at displcmt 39 in that key shows which finder must come out now
        Move(spac6[1], inrec[33], 6); //  blank out this field so initial confirm isn't done over and over

        MNOSKPF:
        WriteLn(BMASTOUT, inrec); //  write the (potentially modified) B record to the output 'B' master file
        oput := Copy(ASAV, 54, Length(ASAV) - 53);
        CAROTSL.Add(Copy(oput, 48, 8));
        WriteLn(OCARRIER, oput); //  write key-less version of the A rec here (recds in this file drive notific of Carrier Originated trxns to BD)

        MCLRASAV:
        ASAV := Copy(spac300, 1, Length(ASAV));   //  blank out the save-off A record now
        Goto NEXTREC;

        NEXTREC:
      End;
    Except
      log.Write(DtNow(Now) + 'Exception while working on Sorted file LNACSRT.txt');
      log.Free;
      close;
    End;
  Finally
    log.Write(DtNow(Now) + 'Finished work on Sorted file LNACSRT.txt');
    CloseFile(myFile);
  End;

  oput := Copy(ASAV, 54, Length(ASAV) - 53);
  If Copy(ASAV, 1, 6) <> spac6 Then
    CAROTSL.Add(Copy(oput, 48, 8));
  WriteLn(OCARRIER, oput); //  if we had an A rec left in core, be sure to write it out once hit EOF on input file

  CloseFile(OCARRIER);
  CloseFile(CARRIERN);
  CloseFile(BFINDER);
  CloseFile(BMASTOUT);
  CloseFile(BFINISH);

  // Banner 7976 and Penn 7977 carriero counters
  RC7976ML := 0;                                  // Merrill Lynch
  RC7976UB := 0;                                  // UBS
  RC7976RJ := 0;                                  // Raymond James
  RC7976MS := 0;                                  // Morgan Stanley
  RC7976ZZ := 0;                                // ALL OTHER
  RC7977ML := 0;                                  // Merrill Lynch
  RC7977UB := 0;                                  // UBS
  RC7977RJ := 0;                                  // Raymond James
  RC7977MS := 0;                                  // Morgan Stanley
  RC7977ZZ := 0;                                // ALL OTHER
  For n := 0 To CAROTSL.Count - 1 Do
  Begin
    Case strtoint(CAROTSL[n]) Of
      79760161: Inc(RC7976ML);
      79770161: Inc(RC7977ML);
      79760015: Inc(RC7976MS);
      79770015: Inc(RC7977MS);
      79760221: Inc(RC7976UB);
      79770221: Inc(RC7977UB);
      79760725: Inc(RC7976RJ);
      79770725: Inc(RC7977RJ);
    Else
      Begin                                     // this else in the CASE is to increment ALL OTHER buckets as needed
        If strtoint(Copy(CAROTSL[n], 1, 4)) = 7976 Then
          Inc(RC7976ZZ);
        If strtoint(Copy(CAROTSL[n], 1, 4)) = 7977 Then
          Inc(RC7977ZZ);
      End;
    End;
  End;
  RC7976X := RC7976ML + RC7976UB + RC7976RJ + RC7976MS + RC7976ZZ;
  RC7977X := RC7977ML + RC7977UB + RC7977RJ + RC7977MS + RC7977ZZ;

  // here, we make an 8-byte 'character' version of each of the above counters...  need this for placing into header
  XC7976X := IntToStr(RC7976X);
  XC7976X := '0000000' + XC7976X;
  XC7976X := Copy(XC7976X, Length(XC7976X) - 7, 8);
  XC7977X := IntToStr(RC7977X);
  XC7977X := '0000000' + XC7977X;
  XC7977X := Copy(XC7977X, Length(XC7977X) - 7, 8);

  XC7976UB := IntToStr(RC7976UB);
  XC7976UB := '0000000' + XC7976UB;
  XC7976UB := Copy(XC7976UB, Length(XC7976UB) - 7, 8);
  XC7977UB := IntToStr(RC7977UB);
  XC7977UB := '0000000' + XC7977UB;
  XC7977UB := Copy(XC7977UB, Length(XC7977UB) - 7, 8);

  XC7976RJ := IntToStr(RC7976RJ);
  XC7976RJ := '0000000' + XC7976RJ;
  XC7976RJ := Copy(XC7976RJ, Length(XC7976RJ) - 7, 8);
  XC7977RJ := IntToStr(RC7977RJ);
  XC7977RJ := '0000000' + XC7977RJ;
  XC7977RJ := Copy(XC7977RJ, Length(XC7977RJ) - 7, 8);

  XC7976ML := IntToStr(RC7976ML);
  XC7976ML := '0000000' + XC7976ML;
  XC7976ML := Copy(XC7976ML, Length(XC7976ML) - 7, 8);
  XC7977ML := IntToStr(RC7977ML);
  XC7977ML := '0000000' + XC7977ML;
  XC7977ML := Copy(XC7977ML, Length(XC7977ML) - 7, 8);

  XC7976MS := IntToStr(RC7976MS);                 // Morgan Stanley
  XC7976MS := '0000000' + XC7976MS;
  XC7976MS := Copy(XC7976MS, Length(XC7976MS) - 7, 8);
  XC7977MS := IntToStr(RC7977MS);
  XC7977MS := '0000000' + XC7977MS;
  XC7977MS := Copy(XC7977MS, Length(XC7977MS) - 7, 8);

  XC7976ZZ := IntToStr(RC7976ZZ);                 // All other
  XC7976ZZ := '0000000' + XC7976ZZ;
  XC7976ZZ := Copy(XC7976ZZ, Length(XC7976ZZ) - 7, 8);
  XC7977ZZ := IntToStr(RC7977ZZ);
  XC7977ZZ := '0000000' + XC7977ZZ;
  XC7977ZZ := Copy(XC7977ZZ, Length(XC7977ZZ) - 7, 8);

  CAROTSL.Free;

  // Now, fix the totals in the carriero headers (there is one header in this file for 7976 and one for 7977)
  log.Write(DtNow(Now) + 'Work on OCARRIER.txt');
  Try
    AssignFile(OCARRIER, fdir + 'OCARRIER.txt'); // input file (the one that has header counts that need to be fixed)
    Reset(OCARRIER);
    AssignFile(CARRIERO, fdir + 'CARRIERO.txt'); // the final 'CARRIERO' (will have counts of detail records correct within headers)
    ReWrite(CARRIERO);
    Try
      readcnt := 0;
      While Not Eof(OCARRIER) Do
      Begin
        Application.ProcessMessages;

        ReadLn(OCARRIER, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'OCARRIER.txt line rec ' + IntToStr(readcnt));

        If (Copy(inrec, 1, 8) = 'AAAAAAAA') And (Copy(inrec, 48, 4) = '7976') Then
          inrec := Copy(inrec, 1, 80) + XC7976X + XC7976UB + XC7976RJ + XC7976ML + XC7976MS + XC7976ZZ
            + Copy(inrec, 129, Length(inrec) - 129 + 1);

        If (Copy(inrec, 1, 8) = 'AAAAAAAA') And (Copy(inrec, 48, 4) = '7977') Then
          inrec := Copy(inrec, 1, 80) + XC7977X + XC7977UB + XC7977RJ + XC7977ML + XC7977MS + XC7977ZZ
            + Copy(inrec, 129, Length(inrec) - 129 + 1);
        WriteLn(CARRIERO, inrec);
      End;
    Except
      log.Write(DtNow(Now) + 'Exception while working on OCARRIER.txt');
      log.Free;
      close;
    End;
  Finally
    log.Write(DtNow(Now) + 'Finish work on OCARRIER.txt');
    CloseFile(CARRIERO);
    CloseFile(OCARRIER);
  End;

  // now, go through BFINDER and M5301 data improving the key just for this one last special purpose, and put work results into XFINDER
  log.Write(DtNow(Now) + 'Go thru BFINDER and M5301');
  Try
    AssignFile(XFINDER, fdir + 'XFINDER.txt');
    ReWrite(XFINDER);

    Try
      log.Write(DtNow(Now) + 'Read BFINDER, write into XFINDER');
      readcnt := 0;
      Reset(BFINDER);
      While Not Eof(BFINDER) Do
      Begin
        Application.ProcessMessages;
        ReadLn(BFINDER, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'BFINDER line rec ' + IntToStr(readcnt));
        key := Copy(inrec, 170, 20);
        WriteLn(XFINDER, key + inrec);
      End;
      CloseFile(BFINDER);
    Except
      log.Write(DtNow(Now) + 'Exception reading thru BFINDER');
      log.Free;
      close;
    End;

    Try
      log.Write(DtNow(Now) + 'Read M5301, write into XFINDER');
      readcnt := 0;
      Reset(File5301);
      While Not Eof(File5301) Do
      Begin
        Application.ProcessMessages;
        ReadLn(File5301, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'M5301 line rec ' + IntToStr(readcnt));
        key := Copy(inrec, 170, 20);
        WriteLn(XFINDER, key + inrec);
      End;
      CloseFile(File5301);
      CloseFile(XFINDER);
    Except
      log.Write(DtNow(Now) + 'Exception reading thru M5301');
      log.Free;
      close;
    End;

    SrtIFils := fdir + 'XFINDER.txt';
    SrtOFil := fdir + 'XFINDER.txt';
    OtSort(SrtIFils, SrtOFil, 's(#1,c,d)', records, rc);

    Try
      log.Write(DtNow(Now) + 'Read XFINDER, write into BFINDER');
      readcnt := 0;
      Reset(XFINDER);
      ReWrite(BFINDER);
      While Not Eof(XFINDER) Do
      Begin
        Application.ProcessMessages;
        ReadLn(XFINDER, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'XFINDER line rec ' + IntToStr(readcnt));
        //inrec := Copy(inrec, 21, Length(inrec)-20);
        If Copy(inrec, 38, 1) = ' ' Then
          Goto CHECKIT; //  if this record is a detail (state-level) record  (which equates to 5311), then indicate we now need a 5301 and then go write this record to output
        NEED5301 := 'Y';
        Goto PUTIT;
        CHECKIT:
        If NEED5301 <> 'Y' Then
          Goto SKIPPUT; //  for this non-state-level record (which makes this a 5301), see if we are currently needing a 5301 to be written out.. if so, show we no longer need one and also go write this one out
        NEED5301 := 'N';
        Goto PUTIT;
        PUTIT:
        WriteLn(BFINDER, inrec);
        SKIPPUT:
      End;
    Except
      log.Write(DtNow(Now) + 'Exception reading thru XFINDER');
      log.Free;
      close;
    End;

  Finally
    log.Write(DtNow(Now) + 'Finish work on BFINDER and M5301');
    CloseFile(BFINDER);
    CloseFile(XFINDER);
  End;

  SrtIFils := fdir + 'BFINDER.txt';
  SrtOFil := fdir + 'BFINDER.txt';
  OtSort(SrtIFils, SrtOFil, 's(#1,c,a)', records, rc);
  //  now, copy the final BFINDER records over to XFINDER and while doing so, chop off that prepended 20-byte area so record is back in proper format
  Try
    log.Write(DtNow(Now) + 'Final copy into XFINDER');
    ReWrite(XFINDER);
    Reset(BFINDER);
    Try
      readcnt := 0;
      While Not Eof(BFINDER) Do
      Begin
        Application.ProcessMessages;
        ReadLn(BFINDER, inrec);
        Inc(readcnt);
        log.Write(DtNow(Now) + 'Final XFINDER copy, line rec ' + IntToStr(readcnt));
        inrec := Copy(inrec, 21, Length(inrec) - 20);
        WriteLn(XFINDER, inrec);
      End;
    Except
      log.Write(DtNow(Now) + 'Exception trying to do final XFINDER copy');
      log.Free;
      close;
    End;
  Finally
    log.Write(DtNow(Now) + 'Finished final copy into XFINDER');
    CloseFile(BFINDER);
    CloseFile(XFINDER);
  End;

  log.Write(DtNow(Now) + 'End of LNA Confirm');
  log.Free;
  Button1.Enabled := True;
  Form1.close;
End;

End.
}}}LNA_INProject.dproj
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <ProjectGuid>{14DD8963-6192-4B70-9BFD-6DA72DF56D2B}</ProjectGuid>
        <MainSource>LNA_INProject.dpr</MainSource>
        <Base>True</Base>
        <Config Condition="'$(Config)'==''">Debug</Config>
        <TargetedPlatforms>1</TargetedPlatforms>
        <AppType>Application</AppType>
        <FrameworkType>VCL</FrameworkType>
        <ProjectVersion>18.4</ProjectVersion>
        <Platform Condition="'$(Platform)'==''">Win32</Platform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Base)'=='true') or '$(Base_Win32)'!=''">
        <Base_Win32>true</Base_Win32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''">
        <Base_Win64>true</Base_Win64>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_1)'!=''">
        <Cfg_1>true</Cfg_1>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''">
        <Cfg_1_Win32>true</Cfg_1_Win32>
        <CfgParent>Cfg_1</CfgParent>
        <Cfg_1>true</Cfg_1>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_2)'!=''">
        <Cfg_2>true</Cfg_2>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='iOSDevice64' and '$(Cfg_2)'=='true') or '$(Cfg_2_iOSDevice64)'!=''">
        <Cfg_2_iOSDevice64>true</Cfg_2_iOSDevice64>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''">
        <Cfg_2_Win32>true</Cfg_2_Win32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base)'!=''">
        <DCC_DcuOutput>dcuout</DCC_DcuOutput>
        <DCC_ExeOutput>exe</DCC_ExeOutput>
        <DCC_UsePackage>vcl;rtl;vclx;indy;vclie;xmlrtl;inetdbbde;inet;inetdbxpress;dbrtl;soaprtl;dsnap;VclSmp;dbexpress;vcldb;dbxcds;inetdb;bdertl;vcldbx;adortl;ibxpress;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOfficeXP;ILCORP50;addict3_d7;addict3db_d7;AUSComponents;PKBOOKMARK;PTCommon;ptEtsPanel;LproComponents;PTZipCodeCityState;Tee97;TeeUI97;TeeDB97;TeePro97;TeeGL97;TeeImage97;TeeLanguage97;TeeWorld97;FlexCel_Report;RESTBackendComponents;CloudService;FlexCel_XlsAdapter;soaprtl;soapmidas;RESTComponents;FlexCel_Pdf;FireDACIBDriver;FireDACCommon;soapserver;FireDACCommonDriver;inet;FireDAC;FireDACSqliteDriver;FlexCel_Core;FlexCel_Render;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_Namespace>Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;System;Xml;Data;Datasnap;Web;Soap;Winapi;Data.Win;Xml.Win;System.Win;Datasnap.Win;Web.Win;Soap.Win;Bde;VCLTee;$(DCC_Namespace)</DCC_Namespace>
        <Icon_MainIcon>$(BDS)\bin\delphi_PROJECTICON.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.LGAmerica.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>units;EXCH;CommonUnits;..\..\_commonvnext;C:\Projects\_Externals\nativexml;DCUOut;CommonUnits\Synapse;$(D3P)\Source;$(BDSlib)\win32\release;$(BDSlib)\win32\Debug;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <DCC_Define>SQL;$(DCC_Define)</DCC_Define>
        <DCC_DcpOutput>$(D3P)\$(Platform)\DCP</DCC_DcpOutput>
        <DCC_BplOutput>$(D3P)\$(Platform)\BPL</DCC_BplOutput>
        <SanitizedProjectName>LNA_INProject</SanitizedProjectName>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win32)'!=''">
        <DCC_UsePackage>DBXSqliteDriver;dxSpreadSheetCoreDialogsRS25;dxSkinOffice2007PinkRS25;dxSkinMcSkinRS25;vclFireDAC;cxExportRS25;dxHttpIndyRequestRS25;tethering;dxPScxCommonRS25;addict3db_;FireDACADSDriver;Kodak_Image_Edit;cxPivotGridOLAPRS25;JvPluginSystem;vcltouch;dxSkinDarkRoomRS25;dxSkinDarkSideRS25;Intraweb;svn;JvBands;JvJans;cxLibraryRS25;JvDotNetCtrls;dxSkinOffice2007SilverRS25;dxSkinBlackRS25;dxSkinOffice2007BlueRS25;dxSkinOffice2007BlackRS25;AcroPDF;XMLPartner_PD;Tee925;dxSkinVS2010RS25;dxSkinFoggyRS25;dxSkinSevenRS25;dxSpreadSheetConditionalFormattingDialogsRS25;dxSkinSpringTimeRS25;TeeWorld925;TeeTree2D25Tee9;VCLRESTComponents;XMLPartner_PR;RvCore;cxPageControlRS25;dxSkinLilianRS25;dxPSLnksRS25;RvCompiler;bindengine;dxFireDACServerModeRS25;JvHMI;FireDACMySQLDriver;dxSkinOffice2013LightGrayRS25;dxSkinMetropolisRS25;dxSkinOffice2016DarkRS25;bindcompdbx;dxSkinBlueprintRS25;dxSkinStardustRS25;IndyIPServer;dxPSdxLCLnkRS25;NxDBGridDsgn_dxe;IndySystem;dxSkinOffice2007GreenRS25;dsnapcon;VirtualTreesR;dxLayoutControlRS25;FireDACMSAccDriver;fmxFireDAC;RvBarcode;vclimg;NxCommonDsgn_dxe;Jcl;NxAddonsRun_dxe;dxPScxTLLnkRS25;RvStandard;dxSkinVisualStudio2013LightRS25;dxSpreadSheetRS25;RvReport;TeeMaker125;cxGridRS25;dxSpreadSheetCoreConditionalFormattingDialogsRS25;dxSkinTheAsphaltWorldRS25;DbxCommonDriver;JvManagedThreads;dxSkinHighContrastRS25;JvTimeFramework;fmxobj;dxPScxGridLnkRS25;D7MStreams;PTExtPanels;DbxClientDriver;dxPSCoreRS25;CodeSiteExpressPkg;dxmdsRS25;JvSystem;JvStdCtrls;dxSkinOffice2016ColorfulRS25;appanalytics;LockBox3DR;IndyIPClient;bindcompvcl;dxThemeRS25;NxDBGridRun_dxe;JvDocking;JvPascalInterpreter;FMXTee925;JclVcl;NxCommonRun_dxe;NxGridRun_dxe;cxVerticalGridRS25;JvControls;JvPrintPreview;dxADOServerModeRS25;dxSkinPumpkinRS25;dxCoreRS25;dxSkinValentineRS25;FMXTeeImport925;DBXInterBaseDriver;RvGraphics;TeeDB925;dxSkinOffice2010BlueRS25;JvGlobus;svnui;dxSkinMoneyTwinsRS25;dxSkinSilverRS25;JvMM;dxSkinOffice2013WhiteRS25;bindcompfmx;JvNet;FMXTeePro925;JvAppFrm;TeeImport925;dxOfficeCoreRS25;fmx;fmxdae;dxSkinBlueRS25;dxPScxPivotGridLnkRS25;VirtualTreesD;dxSkinDevExpressDarkStyleRS25;JvWizards;FMXTeeLanguage925;IndyCore;FMXTeeDB925;XMLPartner_CR;JvPageComps;NxCollectionRun_dxe;JvDB;dxSkinLiquidSkyRS25;dxPScxExtCommonRS25;cxPivotGridRS25;dxPSdxSpreadSheetLnkRS25;dxSpreadSheetReportDesignerRS25;JclDeveloperTools;dxSkinCoffeeRS25;JvCmp;DBXMySQLDriver;NxInspectorDsgn_dxe;FireDACCommonODBC;dxSkinOffice2010SilverRS25;cxTreeListRS25;LockBoxDR;IndyIPCommon;JvCustom;dxSkinLondonLiquidSkyRS25;dxPScxVGridLnkRS25;dclRave;JvXPCtrls;dxSkinsCoreRS25;dxComnRS25;TeeUI925;dxSkinWhiteprintRS25;FmxTeeUI925;dxSkinVisualStudio2013BlueRS25;madExcept_;dxSkinGlassOceansRS25;dxSkinMetropolisDarkRS25;dxSkinOffice2013DarkGrayRS25;madBasic_;dxSkinSharpPlusRS25;dxSpreadSheetCoreRS25;dxServerModeRS25;dxSkinCaramelRS25;dxPScxPCProdRS25;NxCollectionDsgn_dxe;JvCore;JvCrypt;FireDACPgDriver;dxSkiniMaginaryRS25;cxEditorsRS25;TeePro925;TeeGL925;JvDlgs;JvRuntimeDesign;NxGridDsgn_dxe;vclwinx;dxSkinSevenClassicRS25;RvEngine;madDisAsm_;cxDataRS25;CustomIPTransport;vcldsnap;dxSkinSharpRS25;bindcomp;FMXTree25;dxSkinVisualStudio2013DarkRS25;cxPivotGridChartRS25;dxSkinOffice2010BlackRS25;dxDBXServerModeRS25;dxSkinDevExpressStyleRS25;dxGDIPlusRS25;GW_Crap;VCL_FlexCel_Core;TeeImage925;NxSheetRun_dxe;TeeLanguage925;dsnapxml;IndyProtocols;addict3_;dxSkinSummer2008RS25;JclContainers;NxInspectorRun_dxe;dxSkinXmas2008BlueRS25;fmxase;$(DCC_UsePackage)</DCC_UsePackage>
        <BT_BuildType>Debug</BT_BuildType>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.embarcadero.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>$(D3P)\Win32\CommonDCU;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <Manifest_File>$(BDS)\bin\default_app.manifest</Manifest_File>
        <DCC_UseMSBuildExternally>false</DCC_UseMSBuildExternally>
        <DCC_BplOutput>$(D3P)\Win32\BPL</DCC_BplOutput>
        <DCC_DcpOutput>$(D3P)\Win32\DCP</DCC_DcpOutput>
        <DCC_Define>madexcept;$(DCC_Define)</DCC_Define>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win64)'!=''">
        <Icon_MainIcon>LNA_INProject_Icon.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1)'!=''">
        <DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
        <DCC_DebugInformation>0</DCC_DebugInformation>
        <DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
        <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2)'!=''">
        <DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
        <DCC_Optimize>false</DCC_Optimize>
        <DCC_GenerateStackFrames>true</DCC_GenerateStackFrames>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_iOSDevice64)'!=''">
        <BT_BuildType>Debug</BT_BuildType>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=;ProgramID=com.embarcadero.$(MSBuildProjectName)</VerInfo_Keys>
        <DCC_MapFile>3</DCC_MapFile>
        <Debugger_RunParams>/ini=bantest /TEST /EP /CycleDateSetbackDays=1</Debugger_RunParams>
    </PropertyGroup>
    <ItemGroup>
        <DelphiCompile Include="$(MainSource)">
            <MainSource>MainSource</MainSource>
        </DelphiCompile>
        <DCCReference Include="units\LNA_IN.pas">
            <Form>Form1</Form>
        </DCCReference>
        <BuildConfiguration Include="Debug">
            <Key>Cfg_2</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
        <BuildConfiguration Include="Base">
            <Key>Base</Key>
        </BuildConfiguration>
        <BuildConfiguration Include="Release">
            <Key>Cfg_1</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
    </ItemGroup>
    <ProjectExtensions>
        <Borland.Personality>Delphi.Personality.12</Borland.Personality>
        <Borland.ProjectType/>
        <BorlandProject>
            <Delphi.Personality>
                <Source>
                    <Source Name="MainSource">LNA_INProject.dpr</Source>
                </Source>
                <Excluded_Packages>
                    <Excluded_Packages Name="C:\Projects\_Externals\Tokyo\Win32\BPL\LockBox3FMXDD250.bpl">TurboPack LockBox 3 FMX designtime package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcboffice2k250.bpl">Embarcadero C++Builder Office 2000 Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\bcbofficexp250.bpl">Embarcadero C++Builder Office XP Servers Package</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dcloffice2k250.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dclofficexp250.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
                </Excluded_Packages>
            </Delphi.Personality>
            <Platforms>
                <Platform value="iOSDevice64">False</Platform>
                <Platform value="Linux64">False</Platform>
                <Platform value="Win32">True</Platform>
                <Platform value="Win64">False</Platform>
            </Platforms>
        </BorlandProject>
        <ProjectFileVersion>12</ProjectFileVersion>
    </ProjectExtensions>
    <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
    <Import Project="$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj" Condition="Exists('$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj')"/>
</Project>
}}}LNA_IN.dfm
object Form1: TForm1
  Left = 497
  Top = 325
  ClientHeight = 146
  ClientWidth = 277
  Color = clWindow
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  Position = poMainFormCenter
  OnClose = FormClose
  OnCreate = FormCreate
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 277
    Height = 146
    Align = alClient
    TabOrder = 0
    object Button1: TButton
      Left = 102
      Top = 48
      Width = 83
      Height = 25
      Hint = 'really?'
      Caption = 'Go'
      Font.Charset = ANSI_CHARSET
      Font.Color = clWindowText
      Font.Height = -24
      Font.Name = 'Book Antiqua'
      Font.Style = [fsBold, fsItalic]
      ParentFont = False
      ParentShowHint = False
      ShowHint = True
      TabOrder = 0
      OnClick = Button1Click
    end
  end
end
}}}LNA_IN
Unit LNA_IN;

// LNA Inbound - Program One.  Take raw/received DTCC LNA file and put it into a better format.
// CANTDO file is produced to house incoming LNA transactions that this pgm cannot deal with.
// For any such unprocessable transactions, an email is sent to Licensing Depts and to IT.
// CANDO file has all the incoming events that we COULD handle.
// This same processable set of data is also put into a CANDO_TAGFILE... but the format of this
// file is different:  the tag file is one logical field per physical output record.  It is this
// tag based file that is used by the next program in line (to create ALI docs). That next program
// is called LNAPLOT.
//
//CHANGES:
// PROJ#    DATE     DESCRIPTION
// LB1840A  20230806 Allow for specially provided Operator parm allowing to run for a past cycle date
//                    instead of always running with current date as cycle date
// LB1840B  20230807 LGA-requested mod to check incoming participant 0057 AI agent: are they already in
//                    Admin system with "PDB" agent code - and if so, consider this AI to be a "duplicate"

Interface

Uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler,
  IdIOHandlerStream, adodb, db, DateUtils, uDatabaseMail, ComCtrls, usqlconfig,
  ulgaini, sabutils, ExtCtrls,
//LB1840B - added next line      (note: I tested for a time by also including uagtfobj in next line... but found its not needed)
  uAgntobj, uLifepro, uNameObj, System.StrUtils;

Type
  TForm1 = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Procedure Button1Click(Sender: tObject);
    Procedure FormCreate(Sender: tObject);
    Procedure FormClose(Sender: tObject; Var Action: TCloseAction);
    Procedure FormShow(Sender: tObject);
  Private
    { Private declarations }
  Public
    { Public declarations }
    log: ttextfileout;
    Function DtNow(DT: tDateTime): AnsiString;
    Procedure RRCOFix(Const X: Integer; Var WorkTSL: tStringList; Var BLRCTSL: tStringList);
  End;

Var
  Form1: TForm1;

Implementation

{$R *.dfm}

Function TForm1.DtNow(DT: tDateTime): AnsiString;
Begin
  Result := EmptyStr;
  Result := datetostr(DT) + ' ' + timetostr(DT) + ': ';
End;

Function IsStrANumber(Const S: AnsiString): Boolean;
Var
  P: PAnsiChar;
Begin
  P := PAnsiChar(S);
  Result := False;
  While P^ <> #0 Do
  Begin
    If Not (P^ In ['0'..'9']) Then
      Exit;
    Inc(P);
  End;
  Result := True;
End;

// For the suggested Transaction Code, see if we can process it or not.  If so, fill in the answer field.

Procedure LookUp(Var LookType: AnsiString; Var LookValu: AnsiString; Var LookAns: AnsiString);
Begin
  // In this first set are all the Inbound LNA transaction types our company has automation for
  If LookType = 'TRXCD' Then
  Begin
    If LookValu = 'AI' Then
      LookAns := 'LNA APPT REQ; INITL';
    If LookValu = 'AA' Then
      LookAns := 'LNA APPT REQ; ADDTL';
    If LookValu = 'LI' Then
      LookAns := 'LNA LIC REQ; INITL';
    If LookValu = 'LA' Then
      LookAns := 'LNA LIC REQ; ADDTL';
    If LookValu = 'AD' Then
      LookAns := 'LNA ADDRESS CHANGE';
    If LookValu = 'NA' Then
      LookAns := 'LNA NAME CHANGE';
    If LookValu = 'TA' Then
      LookAns := 'LNA TERMINATE APPT';
    If LookValu = 'TR' Then
      LookAns := 'LNA TERMINATE PRDCR';
    If LookValu = 'LC' Then
      LookAns := 'LNA LIC STAT CHANGE';
  End;

  If LookType = 'RESIND' Then
  Begin
    If LookValu = 'N' Then
      LookAns := 'NON-RESIDENT';
    If LookValu = 'Y' Then
      LookAns := 'RESIDENT';
  End;

  If LookType = 'LICTYPE' Then
  Begin
    If LookValu = '00' Then
      LookAns := 'NON-RESIDENT';
    If LookValu = '01' Then
      LookAns := 'BROKER';
    If LookValu = '00' Then
      LookAns := 'AGENCY/FIRM';
    If LookValu = '01' Then
      LookAns := 'TEMPORARY';
  End;

  If LookType = 'LICSTAT' Then
  Begin
    If LookValu = 'AC' Then
      LookAns := 'ACTIVE';
    If LookValu = 'IA' Then
      LookAns := 'INACTIVE';
    If LookValu = 'PD' Then
      LookAns := 'PENDING';
    If LookValu = 'PN' Then
      LookAns := 'PENDING LIC NUM';
    If LookValu = 'RJ' Then
      LookAns := 'REJECTED';
    If LookValu = 'SU' Then
      LookAns := 'SUSPENDED';
    If LookValu = 'TR' Then
      LookAns := 'TERMINATED';
    If LookValu = 'WD' Then
      LookAns := 'WITHDRAWN';
  End;

  If LookType = 'LLOA' Then
  Begin
    If LookValu = 'DS' Then
      LookAns := 'DISAB/HLTH';
    If LookValu = 'FX' Then
      LookAns := 'FIXD ANNU';
    If LookValu = 'LI' Then
      LookAns := 'LIFE';
    If LookValu = 'LT' Then
      LookAns := 'LNGTRMCARE';
    If LookValu = 'LP' Then
      LookAns := 'LTCPARTNSHP';
    If LookValu = 'PN' Then
      LookAns := 'PRNEED/FNRL';
    If LookValu = 'VA' Then
      LookAns := 'VARBL ANNU';
    If LookValu = 'VL' Then
      LookAns := 'VARBL LIFE';
  End;

  If LookType = 'TRXRSN' Then
  Begin
    If LookValu = 'AI' Then
      LookAns := 'AGT INACTV/TERMINATED';
    If LookValu = 'CD' Then
      LookAns := 'INS COMPANY DECISION';
    If LookValu = 'DB' Then
      LookAns := 'DOB INCORRECT';
    If LookValu = 'DE' Then
      LookAns := 'DECEASED';
    If LookValu = 'FC' Then
      LookAns := 'FOR CAUSE';
    If LookValu = 'FR' Then
      LookAns := 'FIRM REQUEST';
    If LookValu = 'HS' Then
      LookAns := 'HOME ST CERT NOT RCVD';
    If LookValu = 'IF' Then
      LookAns := 'INCORRECT FEE';
    If LookValu = 'IP' Then
      LookAns := 'INADEQUATE PRODUCTION';
    If LookValu = 'LN' Then
      LookAns := 'LEGL ENTITY NM MISSNG';
    If LookValu = 'MG' Then
      LookAns := 'MERGER';
    If LookValu = 'MV' Then
      LookAns := 'PRODUCER MOVED';
    If LookValu = 'OP' Then
      LookAns := 'ORIG PAPERWK NOT RCVD';
    If LookValu = 'PN' Then
      LookAns := 'PRODCTS NOT AVL IN ST';
    If LookValu = 'RD' Then
      LookAns := 'RESIDENCE ST DIFFRNC';
    If LookValu = 'TI' Then
      LookAns := 'PRODUCR TAXID INVALID';
    If LookValu = 'TP' Then
      LookAns := 'NO TRADING RELA AGRMT';
    If LookValu = 'TR' Then
      LookAns := 'TM MEMBR INVLD/MISSNG';
    If LookValu = 'VT' Then
      LookAns := 'VOLUNTARY TERMINATION';
    If LookValu = 'ZC' Then
      LookAns := 'ZIP CODE INVALID';
    If LookValu = 'OT' Then
      LookAns := 'OTHER - SEE MESSAGE';
  End;

  If LookType = 'PRDCTYP' Then
  Begin
    If LookValu = '1' Then
      LookAns := 'PERSON';
    If LookValu = '2' Then
      LookAns := 'NON-PERSON';
    If LookValu = '4' Then
      LookAns := 'CORPORATION';
    If LookValu = '7' Then
      LookAns := 'LIMLIAB CRP';
    If LookValu = '8' Then
      LookAns := 'PARTNERSHIP';
    If LookValu = 'E' Then
      LookAns := 'SOLE PROPR';
    If LookValu = 'P' Then
      LookAns := 'LIMLIAB PSHP';
    If LookValu = 'U' Then
      LookAns := 'UNINCRP ASSN';
    If LookValu = 'B' Then
      LookAns := 'BRK GEN AGCY';
  End;

  If LookType = 'PRDCROL' Then
  Begin
    If LookValu = 'AG' Then
      LookAns := 'AGENT';
    If LookValu = 'G1' Then
      LookAns := 'AGENCY';
    If LookValu = 'J8' Then
      LookAns := 'BROKER/DEALER';
    If LookValu = 'BE' Then
      LookAns := 'BANK EMPLOYEE';
    If LookValu = 'ZJ' Then
      LookAns := 'BRANCH';
    If LookValu = 'BK' Then
      LookAns := 'BANK';
    If LookValu = 'BR' Then
      LookAns := 'BROKER';
    If LookValu = 'JY' Then
      LookAns := 'FINAN PLANNER';
    If LookValu = 'GE' Then
      LookAns := 'GENERAL AGENT';
    If LookValu = 'JZ' Then
      LookAns := 'MANAG GEN AGT';
    If LookValu = 'PA' Then
      LookAns := 'PAID AFILIAT';
    If LookValu = '8P' Then
      LookAns := 'PRODUCER';
    If LookValu = 'QO' Then
      LookAns := 'QUALIFNG OFCR';
    If LookValu = 'H1' Then
      LookAns := 'REG INV ADVSR';
    If LookValu = 'H8' Then
      LookAns := 'SERV ONLY AGT';
    If LookValu = 'TM' Then
      LookAns := 'TEAM';
    If LookValu = 'BO' Then
      LookAns := 'BRKR/SALS OFC';
    If LookValu = 'DS' Then
      LookAns := 'DISTRIBUTOR';
    If LookValu = 'EV' Then
      LookAns := 'SELLING AGENT';
    If LookValu = 'EW' Then
      LookAns := 'SERVICNG BRKR';
    If LookValu = 'J3' Then
      LookAns := 'BRKR ASSISTNT';
    If LookValu = 'BG' Then
      LookAns := 'BRKG GEN AGCY';
  End;

  If LookType = 'DCHANL' Then
  Begin
    If LookValu = 'BD' Then
      LookAns := 'BROKER/DEALER';
    If LookValu = 'BK' Then
      LookAns := 'BANK';
    If LookValu = 'FI' Then
      LookAns := 'FINANCIAL INST';
    If LookValu = 'FP' Then
      LookAns := 'FIN PLANG FIRM';
    If LookValu = 'IA' Then
      LookAns := 'INDEP AGENCY';
    If LookValu = 'IP' Then
      LookAns := 'INDEP PLANNER';
    If LookValu = 'RI' Then
      LookAns := 'RG NVSTM ADVSR';
    If LookValu = 'WH' Then
      LookAns := 'WIREHOUSE';
    If LookValu = 'BG' Then
      LookAns := 'BRKRG GEN AGCY';
  End;

  If LookType = 'PRDCTIQ' Then
  Begin
    If LookValu = '34' Then
      LookAns := 'SOCSEC NO';
    If LookValu = 'FI' Then
      LookAns := 'FED TAXID';
    If LookValu = 'SB' Then
      LookAns := 'CAN SSN';
  End;

  If LookType = 'PRDCAIQ' Then
  Begin
    If LookValu = 'BR' Then
      LookAns := 'BRANCH ID';
    If LookValu = 'CR' Then
      LookAns := 'PRDCR CRD';
    If LookValu = 'IN' Then
      LookAns := 'CARRIER ID';
    If LookValu = 'J8' Then
      LookAns := 'BR/DL(FIRM)';
    If LookValu = 'SP' Then
      LookAns := 'SV PROVR ID';
    If LookValu = 'TS' Then
      LookAns := 'TM SPLIT ID';
    If LookValu = 'PN' Then
      LookAns := 'PIN NUMBER';
    If LookValu = 'NP' Then
      LookAns := 'NAT PRD NO';
    If LookValu = 'BG' Then
      LookAns := 'BRKGEN AGCY';
  End;

  If LookType = 'PRDCNMT' Then
  Begin
    If LookValu = 'AL' Then
      LookAns := 'ALIAS';
    If LookValu = 'DB' Then
      LookAns := 'DBA NAME';
    If LookValu = 'FN' Then
      LookAns := 'FORMR NM';
    If LookValu = 'LA' Then
      LookAns := 'LOC AGCY';
    If LookValu = 'LG' Then
      LookAns := 'LEGL NAM';
    If LookValu = 'MD' Then
      LookAns := 'MAIDN NM';
    If LookValu = 'NK' Then
      LookAns := 'NICKNAME';
    If LookValu = 'TM' Then
      LookAns := 'TEAM';
  End;

  If LookType = 'PRDCATP' Then
  Begin
    If LookValu = 'BB' Then
      LookAns := 'BUS MAIL AD';
    If LookValu = 'BR' Then
      LookAns := 'BRANCH ADDR';
    If LookValu = 'BU' Then
      LookAns := 'BUS AD;OVNT';
    If LookValu = 'CM' Then
      LookAns := 'COMM MAIL AD';
    If LookValu = 'HO' Then
      LookAns := 'HMOFF/BKOFF';
    If LookValu = 'PM' Then
      LookAns := 'POL MAIL AD';
    If LookValu = 'RS' Then
      LookAns := 'RESID ADDR';
    If LookValu = 'VA' Then
      LookAns := 'VACA ADDR';
  End;

  If LookType = 'PRDCDMP' Then
  Begin
    If LookValu = 'BB' Then
      LookAns := 'SNDTO BUS ML AD';
    If LookValu = 'BE' Then
      LookAns := 'SNDTO BUS EMAIL';
    If LookValu = 'BF' Then
      LookAns := 'SENDTO BUS FAX';
    If LookValu = 'BR' Then
      LookAns := 'SENDTO BRNCH AD';
    If LookValu = 'BU' Then
      LookAns := 'SNDTO B AD OVNT';
    If LookValu = 'CM' Then
      LookAns := 'SNDTO CM MAILAD';
    If LookValu = 'HO' Then
      LookAns := 'SNDTO HMOF/BKOF';
    If LookValu = 'PM' Then
      LookAns := 'SNDTO POLMAILAD';
    If LookValu = 'RE' Then
      LookAns := 'SNDTO RES EMAIL';
    If LookValu = 'RF' Then
      LookAns := 'SENDTO RES FAX';
    If LookValu = 'RS' Then
      LookAns := 'SENDTO RES ADDR';
    If LookValu = 'VA' Then
      LookAns := 'SENDTO VAC ADDR';
  End;

  If LookType = 'PRDCCNQ' Then
  Begin
    If LookValu = 'BB' Then
      LookAns := 'BUS PHN';
    If LookValu = 'BF' Then
      LookAns := 'BUS FAX';
    If LookValu = 'BR' Then
      LookAns := 'BR PHN';
    If LookValu = 'CL' Then
      LookAns := 'MOB PHN';
    If LookValu = 'HO' Then
      LookAns := 'HO/BO PH';
    If LookValu = 'PG' Then
      LookAns := 'PAGER';
    If LookValu = 'RF' Then
      LookAns := 'RES FAX';
    If LookValu = 'RS' Then
      LookAns := 'RES PHN';
    If LookValu = 'VM' Then
      LookAns := 'VOI MAIL';
  End;

  If LookType = 'PRDCCP' Then
  Begin
    If LookValu = 'BB' Then
      LookAns := 'BUS PHN';
    If LookValu = 'BE' Then
      LookAns := 'BUS EMAIL';
    If LookValu = 'BF' Then
      LookAns := 'BUS FAX';
    If LookValu = 'BR' Then
      LookAns := 'BRCH PHN';
    If LookValu = 'CL' Then
      LookAns := 'MOB PHN';
    If LookValu = 'HO' Then
      LookAns := 'HO/BO PH';
    If LookValu = 'PG' Then
      LookAns := 'PAGER';
    If LookValu = 'RE' Then
      LookAns := 'RES EMAIL';
    If LookValu = 'RF' Then
      LookAns := 'RESID FAX';
    If LookValu = 'RS' Then
      LookAns := 'RESID PHN';
    If LookValu = 'VM' Then
      LookAns := 'VOICEMAIL';
  End;

  If LookType = 'PRDCEMT' Then
  Begin
    If LookValu = '1' Then
      LookAns := 'BUS EMAIL';
    If LookValu = '2' Then
      LookAns := 'PER EMAIL';
  End;

  If LookType = 'LLOASR' Then
  Begin
    If LookValu = 'CE' Then
      LookAns := 'DUE TO CONTINUE EDUC';
    If LookValu = 'DE' Then
      LookAns := 'DECEASED';
    If LookValu = 'FC' Then
      LookAns := 'FOR CAUSE';
    If LookValu = 'HS' Then
      LookAns := 'HM ST CERT NOT RCVD';
    If LookValu = 'IF' Then
      LookAns := 'INCORRECT FEE';
    If LookValu = 'IP' Then
      LookAns := 'INADEQUATE PRODUCTN';
    If LookValu = 'LE' Then
      LookAns := 'LICENSE EXPIRED';
    If LookValu = 'LR' Then
      LookAns := 'LICENSE REVOKED';
    If LookValu = 'MV' Then
      LookAns := 'PRODUCER MOVED';
    If LookValu = 'OP' Then
      LookAns := 'ORIGPAPRWK NOTRCVD';
    If LookValu = 'PN' Then
      LookAns := 'PRDCT NT AVL IN ST';
    If LookValu = 'RD' Then
      LookAns := 'RESID STATE DIFFRNC';
    If LookValu = 'RI' Then
      LookAns := 'REINSTATED';
    If LookValu = 'RN' Then
      LookAns := 'RENEWAL';
    If LookValu = 'VT' Then
      LookAns := 'VOLUNTARY TERMINATN';
    If LookValu = 'OT' Then
      LookAns := 'OTHER; SEE MESSAGE';
  End;

  If LookType = 'SALOA' Then
  Begin
    If LookValu = 'DS' Then
      LookAns := 'DISAB/HLTH';
    If LookValu = 'FX' Then
      LookAns := 'FIXD ANNU';
    If LookValu = 'LI' Then
      LookAns := 'LIFE';
    If LookValu = 'LT' Then
      LookAns := 'LNGTRMCARE';
    If LookValu = 'LP' Then
      LookAns := 'LTCPARTNSHP';
    If LookValu = 'PN' Then
      LookAns := 'PRNEED/FNRL';
    If LookValu = 'VA' Then
      LookAns := 'VARBL ANNU';
    If LookValu = 'VL' Then
      LookAns := 'VARBL LIFE';
  End;

  If LookType = 'SAST' Then
  Begin
    If LookValu = 'AC' Then
      LookAns := 'ACTIVE';
    If LookValu = 'AH' Then
      LookAns := 'ACTV; HOLD COMM';
    If LookValu = 'IA' Then
      LookAns := 'INACTIVE';
    If LookValu = 'PD' Then
      LookAns := 'PEND; CANNOTSELL';
    If LookValu = 'PH' Then
      LookAns := 'PEND; HOLD COMM';
    If LookValu = 'PS' Then
      LookAns := 'PEND; CAN SELL';
    If LookValu = 'RJ' Then
      LookAns := 'REJECTED';
    If LookValu = 'SB' Then
      LookAns := 'SUBMITTED';
    If LookValu = 'SU' Then
      LookAns := 'SUSPENDED';
    If LookValu = 'TR' Then
      LookAns := 'TERMINATED';
    If LookValu = 'WD' Then
      LookAns := 'WITHDRAWN';
  End;

  If LookType = 'SASTRSN' Then
  Begin
    If LookValu = 'BK' Then
      LookAns := 'BACKGROUND CHECK';
    If LookValu = 'CD' Then
      LookAns := 'INSURANCE CO DECISN';
    If LookValu = 'CE' Then
      LookAns := 'DUE TO CONTINUE EDU';
    If LookValu = 'DE' Then
      LookAns := 'DECEASED';
    If LookValu = 'ER' Then
      LookAns := 'APPOINTED IN ERROR';
    If LookValu = 'FC' Then
      LookAns := 'FOR CAUSE';
    If LookValu = 'FR' Then
      LookAns := 'FIRM REQUEST';
    If LookValu = 'HS' Then
      LookAns := 'HM ST CERT NOT RCVD';
    If LookValu = 'IF' Then
      LookAns := 'INCORRECT FEE';
    If LookValu = 'IP' Then
      LookAns := 'INADEQUATE PRODUCTN';
    If LookValu = 'LE' Then
      LookAns := 'LICENSE EXPIRED';
    If LookValu = 'LR' Then
      LookAns := 'LICENSE REVOKED';
    If LookValu = 'MR' Then
      LookAns := 'MISSING REQUIREMENT';
    If LookValu = 'MV' Then
      LookAns := 'PRODUCER MOVED';
    If LookValu = 'OP' Then
      LookAns := 'ORIGPAPRWK NOT RCVD';
    If LookValu = 'PN' Then
      LookAns := 'PRDCT NOT AVL IN ST';
    If LookValu = 'RD' Then
      LookAns := 'RESID STATE DIFFRNC';
    If LookValu = 'RI' Then
      LookAns := 'REINSTATED';
    If LookValu = 'RN' Then
      LookAns := 'RENEWAL';
    If LookValu = 'SN' Then
      LookAns := 'STATE NOTIFICATION';
    If LookValu = 'SR' Then
      LookAns := 'NOT SECURITIES REGSTD';
    If LookValu = 'VT' Then
      LookAns := 'VOLUNTARY TERMINATION';
    If LookValu = 'WT' Then
      LookAns := 'WAITING ON ST APPVL';
    If LookValu = 'OT' Then
      LookAns := 'OTHER - SEE MESSAGE';
  End;
End;

// For the selected (raw) CANDO LNA input record, create a set of Tag-based output records based on rules in TAGRULES file.
// If TAGRULES says to extract the data item AND that data item is non-blank, we create the tag record for it.  Otherwise no.

Procedure TagRecs(Var TAGFile: TextFile; Var TagTSL: tStringList; Var inrec: AnsiString; Var TCWTSL: tStringList;
  Const H1: AnsiString; Const H2: AnsiString; Const H3: AnsiString; Const readcnt: Integer);
Var
  WorkTSL: tStringList;
  V, L, W, DISPL, LEN: Integer;
  COLWIDTH: Integer;                              // the number of characters to be in a selected output column (within the tag record)
  datapres: Boolean; // switch to identify whether we found ANY data to exist in the selected portion of the LNA record for current tag
  TagOut, TxtWork, oneblank, zros10, H4: AnsiString;
  LNAdata: AnsiString;                                // this gets the raw (untranslated) info directly from the LNA record for the field in question
  LNAXdata: AnsiString; // for fields with no required translate, this is set same as LNAdata.  For fields needing translate, this field gets the translated value;

Begin
  zros10 := AnsiString(stringofchar('0', 10));
  H4 := IntToStr(readcnt);
  H4 := Copy(zros10 + H4, Length(H4) + 1, 10);    // build key 4  (the other 3 keys were passed to us as Constants)
  oneblank := ' ';
  WorkTSL := tStringList.Create;
  // First, find the proper section of the in-core TAGRULES data (that portion of the file that deals with curr LNA record type)
  For V := 0 To TagTSL.Count - 1 Do
  Begin
    If Copy(TagTSL[V], 1, 5) <> Copy(inrec, 1, 5) Then
      Continue;
    WorkTSL.Text := StringReplace(TagTSL[V], ',', #13#10, [rfReplaceAll]);
    If WorkTSL[2] = 'N' Then
      Continue;                                   // TAGRULES says to create tag-based record for now?  if not, exit.
    DISPL := StrToInt(Trim(WorkTSL[3]));
    LEN := StrToInt(Trim(WorkTSL[5]));

    datapres := False;
    If WorkTSL[2] <> 'Y' Then
    Begin
      For L := DISPL To DISPL + LEN - 1 Do
      Begin
        If Copy(inrec, L, 1) <> ' ' Then
        Begin
          datapres := True;
          Break;
        End;
      End;
    End;
    If datapres And (WorkTSL[2] <> 'Y') Then
      Continue;

    LNAdata := '    ';                            // assume that no translate  will be needed
    LNAXdata := Copy(inrec, DISPL, LEN);          // capture the data that was present in the LNA record for this tag/field
    If WorkTSL[8] <> EmptyStr Then
    Begin
      LNAdata := LNAXdata;                        // the raw data from the LNA field is actually to be used as input to a 'translate'
      TxtWork := WorkTSL[8];                      // col 9 (8 relative to zero) has the Translate Key encoded into it
      LookUp(TxtWork, LNAdata, LNAXdata); // update LNAXdata to be whatever translate value is available based on the raw data from within the LNA field
      If Length(LNAdata) < 4 Then
        LNAdata := AnsiString(LNAdata + stringofchar(' ', 4 - Length(LNAdata)));
    End;

    TxtWork := '';
    TagOut := '';
    For W := 0 To TCWTSL.Count - 1 Do
    Begin
      COLWIDTH := StrToInt(Trim(TCWTSL[W]));
      If COLWIDTH > 0 Then
      Begin
        TagOut := TagOut + TxtWork + WorkTSL[W];
        TxtWork := ',';
      End;
    End;
    WriteLn(TAGFile, H1 + ',' + H2 + ',' + H3 + ',' + H4 + ',' + TagOut + ',' + LNAdata + ',' + LNAXdata); // write tag rec

  End;
End;

// This routine is for adjusting some of the RR.COL values that are within the TAGRULES info.
//
// If the incoming field has no @ in it AND it is from a column not previously identified to store RR.COL values, we just get out.
//
// If @ DOES exist within the received field, and length of the field is 6 (proper len for a full RR.COL field) - then
// we need to calculate and save a 'NEXTUSE' RR.COL value for fixing subsequent RR.COL values that occur in this column.
//
// If we can see that this field is from a column which we've previously identified to be a RR.COL column - AND the
// field currently just has a "Y" in it (telling us to do the needed RR.COL fix), then we 'correct' the field to an
// improved RR.COL value (and we also update our saved 'NEXTUSE' value).
//

Procedure TForm1.RRCOFix(Const X: Integer; Var WorkTSL: tStringList; Var BLRCTSL: tStringList);
Var
  T, FldCalc: Integer;
  HasAt, rContinue: Boolean;
  TempTSL: tStringList;
  atsign, COLout, zeros2: AnsiString;
Begin
  If Length(WorkTSL[X]) <> 0 Then
  Begin
    zeros2 := '00';
    atsign := '@';
    HasAt := False;                               // indicate that there is NO asterisk in the received field
    rContinue := True;
    For T := 0 To Length(WorkTSL[X]) - 1 Do
    Begin
      If Copy(WorkTSL[X], T, 1) = atsign Then
      Begin
        HasAt := True;
        Break;
      End;
    End;

    If HasAt Then
    Begin
      If Length(WorkTSL[X]) <> 6 Then
      Begin
        log.Write(DtNow(Now) + 'RR.COL col has @ but is not 6 chars in length; Aborting now!');
        close;
      End;
    End
    Else
    Begin
      If (Length(BLRCTSL[X]) = 0)                 // if no NEXTUSE value avl for this col, then this col isnt one we can adj
      Or (WorkTSL[X] <> 'Y')                      // the kinds of fields to be corrected here all have 'Y' in them
      Then
        rContinue := False;
      If rContinue Then
        WorkTSL[X] := BLRCTSL[X];                 // put previously saved NEXTUSE RR.COL value into the field now
    End;

    // at this point, the field has a decent looking RR.COL value in it.. we just need to increment that and save it for next usage...
    If rContinue Then
    Begin
      TempTSL := tStringList.Create;
      FldCalc := StrToInt(Trim(WorkTSL[5]));
      TempTSL.Text := StringReplace(WorkTSL[X], '@', #13#10, [rfReplaceAll]);
      FldCalc := FldCalc + StrToInt(Trim(TempTSL[1]));  // add COL value to Length value to get "next COL value"
      COLout := IntToStr(FldCalc);
      COLout := Copy(zeros2 + COLout, Length(zeros2) + Length(COLout) - 2, 3);
      BLRCTSL[X] := TempTSL[0] + '@' + COLout;    // save the NEXTUSE version of this RR.COL for next go round
      TempTSL.Free;
    End;
  End;

End;



//        M A I N L I N E

Procedure TForm1.Button1Click(Sender: tObject);
Var
  TAGFile, LNAFile, CANDO, CANTDO: TextFile;
  RinProg: AnsiString;                                // switch to indicate whether a CANDO record has at least partially been built
  RinTTxt: AnsiString; // translation of the input Transaction Code (assuming our program really does know how to handle it...)
  readcnt, N, X: Integer;
  inrec: AnsiString;
  HeadSubm, HeadSubL, HeadCont, NewCont, HeadDetl: AnsiString;
  openDialog: TOpenDialog;
  Emsg, Bmsg: AnsiString;
  LCTDOTC: AnsiString;
  Countr: Integer;
  CantTSL, C53TSL, WorkTSL, TagTSL, CTSL, STSL: tStringList;
  InptFNam, InptTrx: AnsiString;
  Arec, Arec2, Arec3, Crec: AnsiString;
  Sa, Sb, Sc, Sd: AnsiString;
  zeros10: AnsiString;
  space50: ShortString;
  space300: AnsiString;
  LookType: AnsiString;
  LookValu: AnsiString;
  LookAns: AnsiString;
  Scount: Integer;
  TCWTSL: tStringList;                            //  This saves the fixed-length col widths for the data from the TAGRULES columns
  TCHTSL: tStringList;                            //  This saves column header info from the TAGRULES info
  BLRCTSL: tStringList;
  Tagkey, TagHeads, TxtWork, WrkColHd: AnsiString;
  WrkColWd: Integer;
  SSN5302, ROL5301, TRX5301, Head3, Head4: AnsiString;
  ol: tdatabasemail;
  ini: tSQLConfigFile;
  { variables added by palcanites }
  dbugStr, fname, fullName: AnsiString;
  sdate : String;
  pFound, processLNA: Boolean;
  pidx, pdate, lRecSeq, j, k: Integer;
  candotag, candotxt, cantdotxt: AnsiString;
  tsl, tslOut: tStringList;
  fOut: ttextfileout;
  //LB1840B - add next 10 lines
  HeadDetlP: AnsiString;
  cycDate : TDateTime;
  setbackdays: Integer;
  TRUESSN: AnsiString;
  Rsult: AnsiString;
  ANL: TAgntList;
  AI: tagntitem;
  Nalk: tNalkItem;
  iCnt: integer;
  DUPCODE: AnsiString;

Label
  NEXTREC, FOOTER, SUBMITHD, CONTRAHD, ISDETAIL, CHECKCAN, INITA, KEEPONA, KEEPONB, KEEPONC, KEEPOND,
    KEEPONE, KEEPONF, KEEPONG, KEEPONH, KEEPONI, KEEPONJ, KEEPONK, ALLFOLKS, MY5311, MY5311X, XY5311,
    XY5311X, TAGINX, NEXTXPLS, NXTNNOW,
  //LB1840B - add next line
    SKIPDUPAICHK;
Begin
  //LB1840B - add next line
  DUPCODE := 'DP';     // code slammed into 5302 Producers Additional Identifier Qualifier -5  field to indicate dup AI encountered
  DateTimeToString(sdate, 'yyyymmddhhnnsszz', Now);
  log := ttextfileout.Create(Format('%sLnaIN_%s.log', [WorkAreaUNC + 'DtccFiles\Log\', sdate]));
  log.Write(DtNow(Now) + 'Start LNA In');
  candotag := WorkAreaUNC + 'DtccFiles\LNA\CANDO_TAGFILE.csv';
  candotxt := WorkAreaUNC + 'DtccFiles\LNA\CANDO.txt';
  cantdotxt := WorkAreaUNC + 'DtccFiles\LNA\CANTDO.txt';
  HeadCont := '    ';
  //LB1840A - begin
  //
  setbackdays := 0;    //  cycledate setback value  (in case a cycle date PRIOR to todays date is required)
  //
  if (findcmdlineswitch('cycledatesetbackdays=1')) or
     (findcmdlineswitch('CycleDateSetbackDays=1')) or
     (findcmdlineswitch('CYCLEDATESETBACKDAYS=1')) then setbackdays := 1;
  if (findcmdlineswitch('cycledatesetbackdays=2')) or
     (findcmdlineswitch('CycleDateSetbackDays=2')) or
     (findcmdlineswitch('CYCLEDATESETBACKDAYS=2')) then setbackdays := 2;
  if (findcmdlineswitch('cycledatesetbackdays=3')) or
     (findcmdlineswitch('CycleDateSetbackDays=3')) or
     (findcmdlineswitch('CYCLEDATESETBACKDAYS=3')) then setbackdays := 3;
  if (findcmdlineswitch('cycledatesetbackdays=4')) or
     (findcmdlineswitch('CycleDateSetbackDays=4')) or
     (findcmdlineswitch('CYCLEDATESETBACKDAYS=4')) then setbackdays := 4;
  if (findcmdlineswitch('cycledatesetbackdays=5')) or
     (findcmdlineswitch('CycleDateSetbackDays=5')) or
     (findcmdlineswitch('CYCLEDATESETBACKDAYS=5')) then setbackdays := 5;
  log.Write(DtNow(Now) + 'Cycle Date Setback Days: ' + IntToStr(setbackdays));
  //
  cycDate := Now;
  if setbackdays > 0 then setbackdays := setbackdays * -1;
  cycDate := IncDay(cycDate, setbackdays);
  //
  //pdate := StrToInt(FormatDateTime('yymmdd', Now));    //LB1840A turned this line into a Comment
  pdate := StrToInt(FormatDateTime('yymmdd', cycDate));
  //
  //if findcmdlineswitch('test') then                    //LB1840A turned these two lines into a Comment
  //  pdate := StrToInt(FormatDateTime('yymmdd', Now - 0.30)); // for those times we are working after midnight and the file name changes
  //
  //LB1840A - end
  pFound := False;
  fname := EmptyStr;

  tsl := tStringList.Create;
  tslOut := tStringList.Create;
//  fOut := ttextfileout.Create(WorkAreaUNC + 'DtccFiles\LNA\InputToday.txt');
  For pidx := 1 To 5 Do
  Begin
    fname := Format('%sDtccFiles\in\%s', [WorkAreaUNC, Format('D%d.P0873.C0%d', [pdate, pidx])]);

    If FileExists(fname) Then
    Begin
      log.Write(DtNow(Now) + 'Input file: ' + fname);
      pFound := True;
      tsl.Clear;
      tsl.LoadFromFile(fname);
      tslOut.AddStrings(TSL);
//      For j := 0 To tsl.Count - 1 Do
//        fOut.Write(tsl.Strings[j]);
    End;
  End;
  tslOut.SaveToFile(WorkAreaUNC + 'DtccFiles\LNA\InputToday.txt', TEncoding.ANSI);
  tsl.Free;
  tslOut.Free;
//  fOut.Free;

  If Not pFound Then
  Begin
    //LB1840A - the log message in next line was somewhat updated via this modification
    log.Write(DtNow(Now) + 'No unprocessed LNA inbound file found for the selected cycle date. Filename sought was:' + WorkAreaUNC +
      'DtccFiles\In\' + fname);
    close;
  End;

  If pFound Then
  Begin
    //InptFNam := filelist.strings[pidx];
    //log.Write(DtNow(Now) + 'Input file: ' + InptFNam);
    InptFNam := WorkAreaUNC + 'DtccFiles\LNA\InputToday.txt';
    readcnt := 0;
    zeros10 := AnsiString(stringofchar('0', 10));
    space50 := AnsiString(stringofchar(' ', 50));
    space300 := AnsiString(stringofchar(' ', 300));
    CantTSL := tStringList.Create;
    C53TSL := tStringList.Create;

    //  Now it's a good time to do a pre-delete of this program's output files:
    If FileExists(candotag) Then
      DeleteFile(candotag);
    If FileExists(candotxt) Then
      DeleteFile(candotxt);
    If FileExists(cantdotxt) Then
      DeleteFile(cantdotxt);

    // The next section of this program is to get the output TAG file to be started up.
    TagTSL := tStringList.Create;
    TagTSL.LoadFromFile('TAGRULES.csv');          { this file needs to be in the folder where the exe is located in Prod }

    { Note that this While routine repeatedly removes record zero from a TSL...
      when you do that, the record that used to be 'record one' is now record zero...  }
    TCWTSL := tStringList.Create;                 //   this will house the column width values from the 'numerical header' rec atop TAGRULES
    TCWTSL.Delimiter := ',';

    TCHTSL := tStringList.Create; //   this will house the textual column header values (one per bucket) from the TAGRULES text header row
    TCHTSL.Delimiter := ',';
    Tagkey := Copy(TagTSL[0], 2, 2);
    While Tagkey <> '53' Do
    Begin
      If Copy(Tagkey, 1, 1) = '*' Then
        TagTSL.Delete(0)
      Else
        If IsStrANumber(Copy(TagTSL[0], 1, 1)) = False Then
        Begin
          TCHTSL.DelimitedText := TagTSL[0];
//          TCHTSL.Text := StringReplace(TagTSL[0], ',', #13#10, [rfReplaceAll]); // put each textual col header into it's own cell
          TagTSL.Delete(0);
        End
        Else
        Begin
          TCWTSL.DelimitedText := TagTSL[0];
//          TCWTSL.Text := StringReplace(TagTSL[0], ',', #13#10, [rfReplaceAll]); // put each Col Width value into it's own cell
          TagTSL.Delete(0);
        End;
      Tagkey := Copy(TagTSL[0], 2, 2);
    End;

    AssignFile(TAGFile, candotag);                // TAGFILE has the same data on it as the CANDO file... but in a tag-based format
    ReWrite(TAGFile);
    TagHeads := '';
    TxtWork := '';
    For N := 0 To TCWTSL.Count - 1 Do
    Begin
      WrkColWd := StrToInt(Trim(TCWTSL[N]));
      If WrkColWd > 0 Then
      Begin
        // First, create a version of the cell header that is of a len that is at least no greater than the allowed col width
        WrkColHd := TCHTSL[N];
        If Length(WrkColHd) > WrkColWd Then
          WrkColHd := Copy(WrkColHd, 1, WrkColWd);
        TagHeads := TagHeads + TxtWork + Copy(WrkColHd + space300, 1, WrkColWd);
        TxtWork := ',';
      End;
    End;
    TagHeads := TagHeads + ',PXLT,VALUE';         // our output tag-based record will have 2 appended fields on right side of ea recd
    WriteLn(TAGFile, 'SUBMIT HEAD INFO,CONTRA HEAD INFO,LNA RECD HEADER,REC COUNTR,' + TagHeads);  // now, write out our header onto the output tag-based file

    //  NOW - FOR THE IN-CORE TAGRULES: NEED LENGTH ADJS TO THE DATA ITEMS TO ENSURE CONSISTENT LENGTH
    WorkTSL := tStringList.Create;
    WorkTSL.StrictDelimiter := True;
    BLRCTSL := tStringList.Create;
    While BLRCTSL.Count < TCWTSL.Count Do
      BLRCTSL.Add('');
    For N := 0 To TagTSL.Count - 1 Do
    Begin
      WorkTSL.Clear;
      WorkTSL.Delimiter := ',';
      WorkTSL.DelimitedText := TagTSL[N];
//      WorkTSL.Text := StringReplace(TagTSL[N], ',', #13#10, [rfReplaceAll]); // Break the selected TagRule record into chunks
      For X := 0 To TCWTSL.Count - 1 Do
      Begin
        WrkColWd := StrToInt(Trim(TCWTSL[X]));
        RRCOFix(X, WorkTSL, BLRCTSL);             // Correct RR.COL flag if set to < 6 bytes in length
        // might could just call a routine here called RRCOFIX and it take care of ALL stuff needed in my other two possbl ifs
        // if data here includes an @, then go update current baseline RR.COL value to continue with for this column
        If (WrkColWd = 0) Or (Length(WorkTSL[X]) = WrkColWd) Then
          Application.ProcessMessages
        Else
          If Length(WorkTSL[X]) > WrkColWd Then
            WorkTSL[X] := Copy(WorkTSL[X], 1, WrkColWd)
          Else
            If Length(WorkTSL[X]) < WrkColWd Then
            Begin
              // if N = a column we've seen a @ in, go set RR.COL info to use in place of data I curr have, then goto NEXTXPLS
              If (Length(WorkTSL[X]) = 0) or (IsStrANumber(WorkTSL[X]) = False)  Then
                WorkTSL[X] := Copy(WorkTSL[X] + space50, 1, WrkColWd)
              Else
                WorkTSL[X] := Copy(zeros10 + WorkTSL[X], Length(zeros10) + Length(WorkTSL[X]) - WrkColWd +
                  1,
                  WrkColWd);
            End;
      End;
      TagTSL[N] := StringReplace(WorkTSL.Text, #13#10, ',', [rfReplaceAll]);
    End;
    WorkTSL.Free;

    //  Now that the TAGRULES stuff is all set up, here are some more key output files.
    //  The CANTDO file is just a copy of the input records when data type is one we cannot deal with yet.
    //  The CANDO file is a file with selected processable data items from the input file.

    HeadSubL := space50;

    AssignFile(CANDO, candotxt);
    ReWrite(CANDO);
    AssignFile(CANTDO, cantdotxt);
    ReWrite(CANTDO);

    CTSL := tStringList.Create;
    STSL := tStringList.Create;
    RinProg := 'N';                               // indicate that a CANDO record is NOT currently underway
    readcnt := 0;
    AssignFile(LNAFile, InptFNam);
    Reset(LNAFile);

    log.Write(DtNow(Now) + 'Begin process of LNA file');
    While Not Eof(LNAFile) Do
    Begin
      processLNA := True;
      ReadLn(LNAFile, inrec);
      Inc(readcnt);
      Head3 := IntToStr(readcnt);
      Head3 := Copy(zeros10 + Head3, Length(Head3) + 1, 10); // build this readcnt key for use in CANDO output key

      If Copy(inrec, 1, 3) = 'B53' Then
        lRecSeq := StrToInt(Trim(Copy(inrec, 2, 4)))
      Else
        If Copy(inrec, 1, 3) = 'B50' Then         // submitting header
        Begin
          HeadSubm := Copy(inrec, 4, 44);
          If HeadSubL = space50 Then HeadSubL := HeadSubm;
          WriteLn(CANTDO, inrec);
          processLNA := False;
        End
        Else
          If Copy(inrec, 1, 3) = 'B52' Then       // contra header
          Begin
            NewCont := Copy(inrec, 4, 36);
            WriteLn(CANTDO, inrec);
            processLNA := False;
            If HeadCont = '    ' Then
              HeadCont := NewCont;
          End
          Else
            If Copy(inrec, 1, 3) = 'H03' Then     // footer
            Begin
              WriteLn(CANTDO, inrec);
              processLNA := False;
            End
            Else
              If Copy(inrec, 1, 1) = 'C' Then     // test from ML contained C recs, ignore these
              Begin
                C53TSL.Add(inrec);
                processLNA := False;
              End
              Else
                If Copy(inrec, 20, 3) = 'IPS' Then
                Begin
                  processLNA := False;            // copy only the first datatrack header for the day to CANDO and CANTDO
                  If readcnt = 1 Then
                  Begin
                    WriteLn(CANDO, inrec);
                    WriteLn(CANTDO, inrec);
                  End
                End
                Else
                Begin
                  log.Write(DtNow(Now) + 'Halting Now due to unknown rec type: ' + inrec);
                  close;
                End;

      If processLNA Then
      Begin
        inrec := Copy(inrec + space300, 1, 300);  // ensure that the input detail record is 300 bytes long as all of them should be
        //LB1840B - added the next line and also added the Comment info on the subsequent line
        HeadDetlP := HeadDetl;                    // save the PRIOR value before updating the real HeadDetl field
        HeadDetl := Copy(inrec, 1, 27);           // update the "real" HeadDetl field here...
        If Copy(inrec, 1, 5) <> 'B5301' Then
          Goto KEEPONA;

        //If (Copy(inrec, 1, 5) = 'B5301') And (RinProg = 'Y') Then
        If (lRecSeq = 5301) And (RinProg = 'Y') Then
        Begin
          Head4 := SSN5302 + '|' + ROL5301 + '|' + TRX5301;
          Arec := Copy(Arec + space300, 1, 300);
          Arec2 := Copy(Arec2 + space300, 1, 300);
          Arec3 := Copy(Arec3 + space300, 1, 300);
          Arec := Arec + '|' + Arec2 + '|' + Arec3; // the Arecord becomes the 5301 + 5302 + 5303 all together in one physical record
          WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Arec);

          For N := 0 To CTSL.Count - 1 Do         // Now, write out all the saved 5304 and 5305 records
            WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + CTSL[N]);
          CTSL.Free;                              // free this work area now so it can be re-created fresh for next usage
          CTSL := tStringList.Create;             // re-allocate this TSL for use in building the next CANDO record

          Scount := 0;
          Sa := '';
          Sb := '';
          Sc := '';
          Sd := '';
          For N := 0 To STSL.Count - 1 Do
          Begin                                   // Now, write out all the saved 5311,12,13,14 records (grouped as a single record)
            If Copy(STSL[N], 1, 5) = 'B5311' Then
            Begin
              If Scount > 0 Then
              Begin
                Sa := Copy(Sa + space300, 1, 300);
                Sb := Copy(Sb + space300, 1, 300);
                Sc := Copy(Sc + space300, 1, 300);
                Sd := Copy(Sd + space300, 1, 300);
                WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Sa + '|' + Sb
                  +
                  '|' + Sc + '|' + Sd);
              End;
              Scount := 1;
              Sa := STSL[N];
              Sb := '';
              Sc := '';
              Sd := '';
            End
            Else
            Begin
              Inc(Scount);
              If Copy(STSL[N], 1, 5) = 'B5312' Then
                Sb := STSL[N];
              If Copy(STSL[N], 1, 5) = 'B5313' Then
                Sc := STSL[N];
              If Copy(STSL[N], 1, 5) = 'B5314' Then
                Sd := STSL[N];
            End;
          End;
          If Scount > 0 Then
          Begin
            Sa := Copy(Sa + space300, 1, 300);
            Sb := Copy(Sb + space300, 1, 300);
            Sc := Copy(Sc + space300, 1, 300);
            Sd := Copy(Sd + space300, 1, 300);
            WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Sa + '|' + Sb + '|'
              + Sc + '|' + Sd);
          End;
          STSL.Free;                              // free this work area now so it can be re-created fresh for next usage
          STSL := tStringList.Create;             // re-allocate this TSL for use in building the next CANDO record
          //
          RinProg := 'N';                         // indicate that there is no in-progress CANDO record at this time
          Arec := '';                             // initialize the Agent level record
          Arec2 := '';                            // initialize this part of the A record also (the 5302 part)
          Arec3 := '';                            // initialize this part of the A record too  (the 5303 part)
          Crec := '';                             // initialize the Contact record
          HeadCont := NewCont;
        End;

        //If (Copy(inrec, 1, 5) = 'B5301') Then
        If (lRecSeq = 5301) Then
        Begin
          //LB1840B - added the next line
          Rsult := '';                            // indicate that this is NOT a duplicate AI that should be trashed
          ROL5301 := Copy(inrec, 107, 2);         // will use this Role Code as part of the key when writing CANDO records
          TRX5301 := Copy(inrec, 48, 2);          // will use this Trx Code as part of key when writing CANDO records

          LookType := 'TRXCD'; // tell the lookup routine that we need to translate transaction code (and see if we know how to do one of these transaction types)
          LookValu := Copy(inrec, 48, 2);         // copy the input transaction type to this lookup field
          LookAns := '';                          // default the answer to "No, we cannot handle this incoming transaction type"
          LookUp(LookType, LookValu, LookAns);    // go and see if we know how to handle this incoming transaction type
          If LookAns = '' Then
          Begin
            WriteLn(CANTDO, inrec);               //  otherwise, just write this 5301 to the CANTDO file and go get next record
            CantTSL.Add(LookValu);                //  add this 5301 trx code to the list of trxns recvd that we cannot handle
            processLNA := False;                  // Goto NEXTREC;
          End;
        End;

        If (processLNA) Then
        Begin
          RinTTxt := LookAns;                     // save the returned lookup answer (may need to put this on some output some time)
          RinProg := 'Y';                         // we have found a 5301 with a trx type that we can handle, so indicate a CANDO is in progress
          Arec := inrec; // save the received 5301 as the 'A' record (5302 and 5303 will be appended to right side of this A-record as needed)
          //LB1840B - the immediately below line (which writes out the 5301) was moved via this mod to be down closer to where 5302 is written
          //TagRecs(TAGFile, TagTSL, inrec, TCWTSL, HeadSubm, HeadCont, HeadDetl, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          processLNA := False;                    //Goto NEXTREC;
        End;

        If (processLNA) Then
        Begin
          KEEPONA:
          If RinProg = 'Y' Then
            Goto KEEPONB; // are we currently building a CANDO set or not?  if no, then just write this non-5301 detail record to CANTDO
          WriteLn(CANTDO, inrec);
          Goto NEXTREC;
          KEEPONB:
          If Copy(inrec, 1, 5) <> 'B5302' Then
            Goto KEEPONC;
          SSN5302 := Copy(inrec, 159, 10);          // save off the tax id from each 5302// NO TAX ID - USE NPN
          //LB1840B - save off the SSN (will need this when we check Admin system for preexisting EDJ PDB agent code for this AI)
          TRUESSN := Copy(inrec, 28, 9);            // save the ssn now
//          SSN5302 := Copy(inrec, 28, 9);          // save off the tax id from each 5302// NO TAX ID - USE NPN
          Arec2 := inrec;
          //LB1840B - begin       (check for preexisting PDB agent code for this EDJ AI transaction)
          if TRX5301 <> 'AI' Then goto SKIPDUPAICHK;
          if Copy(inrec, 8, 4) <> '0057' then goto SKIPDUPAICHK;

          ANL := TAgntList.Create(lpro);
          Nalk := tNalkItem.Create(Lpro);

          ANL.findssn(TRUESSN);

          for iCnt := 0 to ANL.Count - 1 do
            begin
              AI := tAgntItem(ANL.Items[iCnt]);
              if AI.namerec.SOC_SEC_NUMBER.SSN = TRUESSN Then
                 begin
                   Nalk.Clear;
                   if Nalk.Read(AI.NameID, 'ABA', False) Then
                      begin
                        if AnsiLeftStr(upperCase(AI.agent_number), 3) = 'PDB' Then
                           begin
                             Rsult := upperCase(AI.agent_number);
                             Break;
                           end;
                      end;
                 end;
            end;

          ANL.Free;
          Nalk.Free;

          if Rsult <> '' then
           begin
            WriteLn(CANTDO, Arec);                //  indicate that CANTDO this duplicate AI
            CantTSL.Add(TRX5301);                 //  add this 5301 trx code
            //
            Move(Rsult[1], Arec2[127], Length(Rsult));       // copy the N (len of Rsult) bytes in field Rsult to Inrec+127
            Move(DUPCODE[1], Arec2[147], 2);                    // copy this into the 2-byte 5302 field to indicate Dup AI encountered
            //
           end;

         SKIPDUPAICHK:
          readcnt := readcnt - 1;
          if Rsult = '' then TagRecs(TAGFile, TagTSL, Arec, TCWTSL, HeadSubm, HeadCont, HeadDetlP, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          readcnt := readcnt + 1;

          if Rsult <> '' then
           begin
            WriteLn(CANTDO, inrec);               //  for duplicate AI - indicate that CANTDO this duplicate AI   (5302)
            CantTSL.Add(TRX5301);                 //  add this 5301 trx code
           end;
          //LB1840B - end
          //LB1840B - make the following create of Tag records occur only if the curr DTCC trx is not an EDJ duplilcate AI
          if Rsult = '' then TagRecs(TAGFile, TagTSL, Arec2, TCWTSL, HeadSubm, HeadCont, HeadDetl, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          Goto NEXTREC;
          KEEPONC:
          If Copy(inrec, 1, 5) <> 'B5303' Then
            Goto KEEPOND;
          Arec3 := inrec;
          //LB1840B - if it is a duplicate AI, then places this onto CANTDO
          if Rsult <> '' then
           begin
            WriteLn(CANTDO, Arec3);               //  indicate that CANTDO this duplicate AI   (5302)
            CantTSL.Add(TRX5301);                 //  add this 5301 trx code
           end;
          //LB1840B - make the following create of Tag records occur only if the curr DTCC trx is not an EDJ duplilcate AI
          if Rsult = '' then TagRecs(TAGFile, TagTSL, Arec3, TCWTSL, HeadSubm, HeadCont, HeadDetl, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          Arec3 := inrec;
          Goto NEXTREC;
          KEEPOND:
          If Copy(inrec, 1, 5) > 'B5305' Then
            Goto KEEPONE;
          //LB1840B - make the following create of Tag records occur only if the curr DTCC trx is not an EDJ duplilcate AI
          if Rsult = '' then TagRecs(TAGFile, TagTSL, inrec, TCWTSL, HeadSubm, HeadCont, HeadDetl, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          CTSL.Add(inrec);
          Goto NEXTREC;
          KEEPONE:
          If Copy(inrec, 1, 5) <> 'B5306' Then
            Goto KEEPONF;
          WriteLn(CANTDO, inrec);                 // even if it comes inside a trxn type we understand... we dont know how to handle 5306 yet
          Goto NEXTREC;
          KEEPONF:
          If Copy(inrec, 1, 5) <> 'B5307' Then
            Goto KEEPONG;
          WriteLn(CANTDO, inrec);                 // even if it comes inside a trxn type we understand... we dont know how to handle 5307 yet
          Goto NEXTREC;
          KEEPONG:
          If Copy(inrec, 1, 5) <> 'B5308' Then
            Goto KEEPONH;
          WriteLn(CANTDO, inrec);                 // for now, we dont know how to handle 5308 yet - but it will go into a C record soon...
          Goto NEXTREC;
          KEEPONH:
          If Copy(inrec, 1, 5) <> 'B5309' Then
            Goto KEEPONI;
          WriteLn(CANTDO, inrec);                 // even if it comes inside a trxn type we understand... we dont know how to handle 5309 yet
          Goto NEXTREC;
          KEEPONI:
          If Copy(inrec, 1, 5) <> 'B5310' Then
            Goto KEEPONJ;
          WriteLn(CANTDO, inrec);                 // even if it comes inside a trxn type we understand... we dont know how to handle 5310 yet
          Goto NEXTREC;
          KEEPONJ:
          If Copy(inrec, 1, 5) > 'B5314' Then
            Goto KEEPONK;
          //LB1840B - make the following create of Tag records occur only if the curr DTCC trx is not an EDJ duplilcate AI
          if Rsult = '' then TagRecs(TAGFile, TagTSL, inrec, TCWTSL, HeadSubm, HeadCont, HeadDetl, readcnt); // Go make tag recd outputs for this CANDO LNA rec
          STSL.Add(inrec);
          Goto NEXTREC;
          KEEPONK:
          WriteLn(CANTDO, inrec);                 // all 53 records higher than 5314 are not understood... so, just write them to CANTDO
          Goto NEXTREC;
        End;
        NEXTREC:
        HeadSubL := HeadSubm;
      End;

    End;
    CloseFile(LNAFile);
    log.Write(DtNow(Now) + 'End process of LNA file');

    //If RinProg = 'N' Then Goto ALLFOLKS; // if no CANDO record was in progress, branch to this other label
    If RinProg <> 'N' Then
    Begin
      Head4 := SSN5302 + '|' + ROL5301 + '|' + TRX5301;
      Arec := Copy(Arec + space300, 1, 300);
      Arec2 := Copy(Arec2 + space300, 1, 300);
      Arec3 := Copy(Arec3 + space300, 1, 300);
      Arec := Arec + '|' + Arec2 + '|' + Arec3;   // the Arecord becomes the 5301 + 5302 + 5303 all together in one physical record
      WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Arec);

      For N := 0 To CTSL.Count - 1 Do             // Now, write out all the saved 5304 and 5305 records
        WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + CTSL[N]);
      CTSL.Free;                                  // free this work area now

      Scount := 0;
      Sa := '';
      Sb := '';
      Sc := '';
      Sd := '';
      For N := 0 To STSL.Count - 1 Do
      Begin                                       // Now, write out all the saved 5311,12,13,14 records (grouped as a single record)
        If Copy(STSL[N], 1, 5) = 'B5311' Then     // Goto XY5311;
        Begin
          If Scount > 0 Then
          Begin
            Sa := Copy(Sa + space300, 1, 300);
            Sb := Copy(Sb + space300, 1, 300);
            Sc := Copy(Sc + space300, 1, 300);
            Sd := Copy(Sd + space300, 1, 300);
            WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Sa + '|' + Sb + '|'
              + Sc + '|' + Sd);
          End;
          Scount := 1;
          Sa := STSL[N];
          Sb := '';
          Sc := '';
          Sd := '';
        End
        Else
        Begin
          Inc(Scount);
          If Copy(STSL[N], 1, 5) = 'B5312' Then
            Sb := STSL[N];
          If Copy(STSL[N], 1, 5) = 'B5313' Then
            Sc := STSL[N];
          If Copy(STSL[N], 1, 5) = 'B5314' Then
            Sd := STSL[N];
        End;
      End;
      If Scount > 0 Then
      Begin
        Sa := Copy(Sa + space300, 1, 300);
        Sb := Copy(Sb + space300, 1, 300);
        Sc := Copy(Sc + space300, 1, 300);
        Sd := Copy(Sd + space300, 1, 300);
        WriteLn(CANDO, HeadSubL + '|' + HeadCont + '|' + Head3 + '|' + Head4 + '|' + Sa + '|' + Sb + '|' +
          Sc
          + '|' + Sd);
      End;
      STSL.Free;                                  // free this work area now
    End;
    //
    CloseFile(CANDO);
    CloseFile(CANTDO);
    CloseFile(TAGFile);

    // The C53TSL stringlist contains any "C" records that were on the incoming data file.
    // Those are records that had previously gone OUT from the carrier to DTCC but were found to be in error...
    // and as such, they are coming back to the carrier for fixing, as needed.  For any such records found on
    // the file, just place them into an email and send to IT and to Licensing manager.
    Emsg := '';
    If C53TSL.Count > 0 Then
    Begin
      For N := 0 To C53TSL.Count - 1 Do
      Begin
        Emsg := Emsg + Copy(C53TSL[N], 1, 60) + #13#10;
      End;
      ol := tdatabasemail.Create;
      ini := tSQLConfigFile.Create('operationsemailgroups');
      WorkTSL := tStringList.Create;
      Try
        ol.Subject := 'DTCC LNA: Reject C Records Found From Previously Sent Outbound File.';
        ol.Body.Add(Emsg);
        If findcmdlineswitch('TEST') Then
          ol.addRecipient('gmarbach')
        Else
        Begin
          ini.ReadSectionValues('LNA_CANTDO', WorkTSL);
          For N := 0 To WorkTSL.Count - 1 Do
            ol.addRecipient(WorkTSL.ValueFromIndex[N])
        End;
        ol.Sendemail;
      Finally
        WorkTSL.Free;
        ini.Free;
        ol.Free;
      End;
      log.Write(DtNow(Now) + 'C Rejects email sent.');
    End;
    C53TSL.Free;

    // sort the CantTSL and count each type of trx that we could not handle.
    // then, produce an email message indicating the count of each type we could not handle.
    // then, send the email
    CantTSL.Sorted := True;                       //  Sort the list of transaction codes we could not handle
    Emsg := 'Transactions we could not handle today include: ';
    Bmsg := Emsg;
    LCTDOTC := '';
    Countr := 0;
    For N := CantTSL.Count - 1 Downto 0 Do
    Begin
      If CantTSL[N] = LCTDOTC Then
        Inc(Countr)
      Else
        If LCTDOTC = '' Then
        Begin
          LCTDOTC := CantTSL[N];
          Countr := 1;
        End
        Else
        Begin
          Emsg := Emsg + IntToStr(Countr) + ' ' + LCTDOTC + ' transactions; ';
          LCTDOTC := CantTSL[N];
          Countr := 1;
        End;
    End;
    CantTSL.Free;

    If LCTDOTC <> '' Then
      Emsg := Emsg + IntToStr(Countr) + ' ' + LCTDOTC + ' transactions.';
    If Emsg <> Bmsg Then
    Begin
      //ShowMessage(Emsg);
      ol := tdatabasemail.Create;
      ini := tSQLConfigFile.Create('operationsemailgroups');
      WorkTSL := tStringList.Create;
      Try
        ol.Subject := 'DTCC LNA: Some Incoming LNA Transactions Not Handled.';
        ol.Body.Add(Emsg);
        If findcmdlineswitch('TEST') Then
          ol.addRecipients('gmarbach')
        Else
        Begin
          ini.ReadSectionValues('LNA_CANTDO', WorkTSL);
          For N := 0 To WorkTSL.Count - 1 Do
            ol.addRecipient(WorkTSL.ValueFromIndex[N])
        End;
        ol.Sendemail;
      Finally
        WorkTSL.Free;
        ini.Free;
        ol.Free;
      End;
      log.Write(DtNow(Now) + 'Error email sent.');
    End;
    {If Not findcmdlineswitch('TEST') Then
    Begin
      renamefile(InptFNam, InptFNam + '.done');
      log.Write(DtNow(Now) + 'LNA file renamed to ' + InptFNam + '.done');
    End;}
  End;

  log.Write(DtNow(Now) + 'End of LNA In');
  log.Free;
  close;
End;

Procedure TForm1.FormCreate(Sender: tObject);
Begin
  //
End;

Procedure TForm1.FormClose(Sender: tObject; Var Action: TCloseAction);
Begin
  Action := cafree;
End;

Procedure TForm1.FormShow(Sender: tObject);
Begin
  //
End;

End.
}}}LNAPLOT.dfm
object Form1: TForm1
  Left = 412
  Top = 190
  Caption = 'LNA Image Plotter'
  ClientHeight = 197
  ClientWidth = 295
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  OnClose = FormClose
  OnCreate = FormCreate
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 295
    Height = 197
    Align = alClient
    TabOrder = 0
    object Label1: TLabel
      Left = 24
      Top = 112
      Width = 37
      Height = 13
      Caption = 'Status'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clWindowText
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = [fsBold, fsUnderline]
      ParentFont = False
    end
    object lStatus: TLabel
      Left = 24
      Top = 136
      Width = 100
      Height = 13
      Caption = 'Status Message here'
    end
    object Button1: TButton
      Left = 104
      Top = 48
      Width = 75
      Height = 25
      Caption = 'Run'
      TabOrder = 0
      OnClick = Button1Click
    end
  end
end
}}LNAPLOT
Unit LNAPLOT;

// This pgm takes in the CANDO_TAGFILE (which is a tag-record view of data in "CANDO" file) and produces
// a couple of sequential outputs and also some 'grid' (document) type outputs.  The documents that come
// out are indexed to agent records via ALI.
//
//   CHANGE LOG:
//
//   INIT  CHGDATE  TAG      PURPOSE
//   --- ---------- ------   ---------------------------------------------------------------------------
//   GM :2021-10-25 SY6355 - add participant 0057 [Ed Jones] to LGA LNA
//   GM :2021-10-25 SY5366 - Mass Agent Load - LNA based [to be used first with Edward Jones]
//   GM :2022-03-12 SY6355 - Updates to have LNAPLOT help with automatic application of incoming trxns
//   GM :2022-03-12 SY6355 - Update to QP parms so that page-2 font for output pdfs is like page-1 font
//   GM :2022-03-25 SY6977/6978 - deal with EDJ data that is more diverse than thought
//   GM :2022-04-05 SY6355 - Change usage of Dbenu such that entire page (via string list) is used at once for doc build
//   GM :2022-04-06 SY6355 -  In phs1 of pgm (building Grid1, Grid2, FC, FS files), build into Stringlists, instd of wrt line-by-line to txt files
//   GM :2023-04-25 SY6355 -  In GRID routine: when asked to plot into a grid, just exit if the grid (page) you were to upd has already over-flowed


Interface

Uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler,
  IdIOHandlerStream, adodb, db, DateUtils, ComCtrls, SABUtils, uLGAini, RunAFile,
  uOutlookEmail, ExtCtrls, DebenuPDFLibrary, uPDFtoTIF;

Type
  TForm1 = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Label1: tLabel;
    lStatus: tLabel;
    Procedure Button1Click(Sender: tObject);
    Procedure FormCreate(Sender: tObject);
    Procedure FormClose(Sender: tObject; Var Action: TCloseAction);
    Procedure FormShow(Sender: tObject);
  Private
    { Private declarations }
  Public
    { Public declarations }
    log: ttextfileout;
    s, pfilenm, tfilenm: AnsiString;
    x: Integer;
    Function DtNow(DT: tDateTime): AnsiString;
    Procedure ToTIF(Const workdir: AnsiString; Const TIFPARMS: AnsiString);
  End;

Var
  Form1: TForm1;

Implementation

{$R *.dfm}

//    FUNCTIONS

Function TForm1.DtNow(DT: tDateTime): AnsiString;
Begin
  Result := EmptyStr;
  Result := datetostr(DT) + ' ' + timetostr(DT) + ': ';
End;

Function IsStrANumber(Const s: AnsiString): Boolean;
Var
  P: PAnsiChar;
Begin
  P := PAnsiChar(s);
  Result := False;
  While P^ <> #0 Do
  Begin
    If Not (P^ In ['0'..'9']) Then
      Exit;
    Inc(P);
  End;
  Result := True;
End;

//   SUBROUTINES

// Manage the creation/completion of a grid.  A grid has 99 records, each being 999 bytes wide.

Procedure Grid(Var myFileTSL: TStringList; Const CHPN: AnsiString; Const CURpNUM: AnsiString; Const CURfl: AnsiString; Const TROKAY: AnsiString;
  Const SETNO: Integer; Const KYTRXCD: AnsiString; Const ROW: Integer; Const COL: Integer; Const CURda: AnsiString; Const
  CURdb: AnsiString; Const LABL: AnsiString; Var GridTSL: tStringList; Const CURkey: AnsiString; Var LASTkey: AnsiString; Var
  SWOK: AnsiString; Var POSTS: Integer; Var PCN: Integer; Var OBL: AnsiString; Const COLRUL: AnsiString; Const USELBL:
  AnsiString; Const USEXLT: AnsiString; Const spac1000: AnsiString; Var WRTSETNO: AnsiString; Var OFSETNO: Integer;
  Const HIGHOFSN: Integer);
Var
  N: Integer;
  TokTSL: tStringList;
  WRTCOUNT: Integer;
  Data: AnsiString;
  DOPRINT: AnsiString;
  wrec: AnsiString;
  myROW: Integer;
  BUMPR: Integer;
  zros10: AnsiString;
  KYSETNO: AnsiString;
  FNBRNO: AnsiString;                                 // wrk fld to show the row num of the first non-blank recd in the grid
  LNBRNO: AnsiString;                                 // wrk fld to show row num of LAST non-blank row in the grid
  KYGRECNO: AnsiString;
  myTRXCD: AnsiString;
  TokTOGO: AnsiString;
  useCURda: AnsiString;
  useCURdb: AnsiString;
  BDNM: AnsiString;
  iBDNM: Integer;
  wrkfld: AnsiString;
  wrkrest: AnsiString;
  sbtext: AnsiString;
Label
  KEEPON, ONWARD, SKIPPRT, DATASET1, CRULDONE, ULNOTI, ULYES, TRYNOW, GEXIT, NOT07A, LEFTOK;
Begin
  //
  useCURda := CURda;
  useCURdb := CURdb;
  //
  zros10 := '0000000000';
  KYSETNO := IntToStr(SETNO);
  KYSETNO := Copy(zros10 + KYSETNO, Length(zros10) + Length(KYSETNO) - 9, 10); // set AnsiString version of set numbr for use in Key
  //
  myTRXCD := Copy(KYTRXCD, 1, 2);                 // this trx code comes in as 4 bytes long when I really only want first 2 bytes
  //
  KYGRECNO := '  ';
  //
  FNBRNO := '  ';
  //
  WRTCOUNT := 0;
  //
  if HIGHOFSN = SETNO + 1 then GOTO GEXIT;        // if same overflowed doc has been rqsted to add more to: just skip the request and exit
  //
  If Length(LASTkey) = 0 Then
    LASTkey := 'Z';
  //
  If (CURkey <> 'B530107A') And (CURkey <> 'ZZZZZZZZ') Then
    Goto ONWARD;                                  // if not 'starting a grid' or handling EOF, then branch
  //
  If CURkey <> 'B530107A' Then
    Goto NOT07A;                                  // if starting a grid now, update the values we'll use as CURda and CURdb to include the BD id
  useCURda := CURpNUM + useCURda;
  BDNM := CURpNUM;
  //
  //
  sbtext := ' - ' + Copy(CHPN, 1, 2);             //  This special Morgan Stanley name qualifier is used in the 0015 name translate below
  //
  //  SY6355 MODIFICATION - added 0057 to the below
  Case StrToInt(BDNM) Of
    0015: BDNM := 'MORGAN STANLEY (' + Trim(BDNM) + sbtext + ')'; //  Include special Morgan Stanley name qualifier here
    0057: BDNM := 'EDWARD JONES (' + Trim(BDNM) + ')';
    0161: BDNM := 'MERRILL LYNCH (' + Trim(BDNM) + ')';
    0221: BDNM := 'UBS (' + Trim(BDNM) + ')';
    0671: BDNM := 'MERRILL LYNCH (' + Trim(BDNM) + ')';
  End;
  useCURdb := useCURdb + ' - ' + BDNM;
  NOT07A:
  //
  If POSTS = 0 Then
    Goto ONWARD;                                  // if nothing has been placed in current grid, branch
  //
  TokTSL := tStringList.Create;
  TokTSL.Delimiter := ',';
  TokTSL.StrictDelimiter := True;
  TokTSL.DelimitedText := TROKAY;
  TokTOGO := 'N';
  For N := 0 To TokTSL.Count - 1 Do
  Begin
    If myTRXCD = TokTSL[N] Then
    begin
      TokTOGO := 'Y';
      Break;
    end;
  End;
  TokTSL.Free;
  //
  //Go through the Grid 'forwards' and build as much of the key as you can
  //
  For N := 0 To 98 Do
  Begin
    KYGRECNO := IntToStr(N);
    If Length(KYGRECNO) = 1 Then
      KYGRECNO := '0' + KYGRECNO;
    If (FNBRNO = '  ') And (GridTSL[N] <> Copy(spac1000, 1, 999)) Then
      FNBRNO := KYGRECNO;
    GridTSL[N] := KYSETNO + SWOK + KYGRECNO + FNBRNO + '  ' + myTRXCD + ',' + GridTSL[N];
  End;
  //
  //Now, go through the Grid 'backwards' and build ALMOST all of the rest of the key
  //
  FNBRNO := '  ';
  LNBRNO := '  ';
  For N := GridTSL.Count - 1 Downto 0 Do
  Begin
    wrec := GridTSL[N];
    KYGRECNO := IntToStr(N);
    If Length(KYGRECNO) = 1 Then
      KYGRECNO := '0' + KYGRECNO;
    If Copy(wrec, 14, 2) = '  ' Then
      Move(FNBRNO[1], wrec[14], 2);
    If Copy(wrec, 14, 2) <> '  ' Then
      FNBRNO := Copy(wrec, 14, 2);
    If (LNBRNO = '  ') And (Copy(wrec, Length(wrec) - 998, 999) <> Copy(spac1000, 1, 999)) Then
      LNBRNO := KYGRECNO;
    Move(LNBRNO[1], wrec[16], 2);
    GridTSL[N] := wrec;
  End;
  //
  // Now that Key fields are mostly fixed up, go ahead and do our Write loop
  //
  LNBRNO := '  ';
  For N := 0 To 98 Do
  Begin
    wrec := GridTSL[N];
    If Copy(wrec, 16, 2) = '  ' Then
      Move(LNBRNO[1], wrec[16], 2);
    If Copy(wrec, 16, 2) <> '  ' Then
      LNBRNO := Copy(wrec, 16, 2);
    If WRTCOUNT = PCN Then
      Goto SKIPPRT;
    DOPRINT := 'Y';
    If (OBL = 'Y') And (wrec = Copy(spac1000, 1, 999)) Then
      DOPRINT := 'N';
    If (DOPRINT = 'Y') And (TokTOGO = 'Y') Then
    Begin
      WRTSETNO := Copy(wrec, 1, 10);              // when we actually upd grid file, upd this field w set number
      myFileTSL.Add(wrec);
      WRTCOUNT := WRTCOUNT + 1;
    End;
    SKIPPRT:
    GridTSL[N] := Copy(spac1000, 1, 999);
  End;
  POSTS := 0;
  //
  ONWARD:
  If CURkey = 'ZZZZZZZZ' Then
    Goto GEXIT;
  Data := useCURda;                               // first step here is to isolate the data we want to add to the grid
  If Data = '    ' Then
  Begin
    Data := useCURdb;
    Goto DATASET1;
  End;
  If USEXLT = 'Y' Then
    Data := useCURdb;
  DATASET1:
  If USELBL = 'Y' Then
    Goto ULYES;
  If USELBL <> 'I' Then
    Goto ULNOTI;
  If Length(Data) = 0 Then
    Goto ULNOTI;
  If Data = Copy(spac1000, 1, Length(Data)) Then
    Goto ULNOTI;
  ULYES:
  Data := TrimRight(LABL) + ':' + Data;
  ULNOTI:
  //
  myROW := ROW;                                   // get a copy of the input row value
  If Length(COLRUL) = 0 Then
    Goto CRULDONE;                                // now, see if there is a collision rule... if not, just branch
  If COLRUL = '     ' Then
    Goto CRULDONE;                                // if collision rule empty that equals no collision rule...
  BUMPR := 1;                                     // assume that our amount-to-skip (if collision) is = 1 row
  If COLRUL = 'SKIP2' Then
    BUMPR := 2;                                   // correct assumption now
  TRYNOW:
  If Copy(GridTSL[myROW], COL, Length(Data)) = Copy(spac1000, 1, Length(Data)) Then
    Goto CRULDONE;
  myROW := myROW + BUMPR;
  If myROW < 99 Then
    Goto TRYNOW;
  SWOK := '  * Grid Row Max Of 99 Rows Exceeded !  ';
  CRULDONE:
  wrec := GridTSL[myROW];                         // get a work copy of the gridrow
  Move(Data[1], wrec[COL], Length(Data));
  If CURfl <> 'Y' Then
    Goto LEFTOK; // does this switch indicate that we should reserve left side of the record when it had previously been blank?  branch if no.
  wrkfld := Copy(wrec, 1, COL - 1);
  wrkrest := Copy(wrec, COL, Length(wrec) - Length(wrkfld));
  If wrkfld = Copy(spac1000, 1, Length(wrkfld)) Then
    wrkfld := StringReplace(wrkfld, ' ', #160, [rfReplaceAll]);
  wrec := wrkfld + wrkrest;
  LEFTOK:
  GridTSL[myROW] := wrec;
  //
  If myROW > 76 Then
    OFSETNO := SETNO + 1;                         // If we are about to plot data into a row that is off the printed page, communic this set no
  //
  POSTS := POSTS + 1;
  GEXIT:
End;

// Manage the creation/completion of records that are going to the FC sequential output file.
  // SY5366 MODIFICATION START
  // SY5366 Modification Note: 9/28/2021: into the left side of the under-construction recd, insert an indicator of the PDF filename that goes with this seq recd

Procedure BuildSeq(Var myFileTSL: TStringList; Const CURpNUM: AnsiString; Const COL: Integer; Const Data: AnsiString; Var
  recd: AnsiString; Const CURkey: AnsiString; Var LASTkey: AnsiString; Var SWOK: AnsiString; Const SETNO: Integer; Const CurDt: AnsiString; Const RcvrPN: AnsiString; Const spac1000: AnsiString);
Var
  // SY5366 MODIFICATION END
  useCOL: Integer;
  // SY5366 MODIFICATION START
  MYSETNO: ansistring;
  zros10: ansistring;
  MY44: ansistring;
  MYXTRABYTES: ansistring;
  // SY5366 MODIFICATION END
Label
  KEEPON;
Begin
  useCOL := COL;
  // SY5366 MODIFICATION START      SY5366: steal 20 of the bytes near far left of the record - to implant an indicator of filename of the associated output pdf
  MYSETNO := IntToStr(SETNO + 1);
  zros10 := '0000000000';
  MYXTRABYTES := AnsiString(stringofchar(' ', 20));                             // will use this to get 20 bytes of buffer space near left side of record
  MYSETNO := Copy(zros10 + MYSETNO, Length(zros10) + Length(MYSETNO) - 9, 10); // set ansistring version of set numbr for use in this sequential recd
  MY44 := ansistring(RcvrPN + SWOK + CurDt + '_' + MYSETNO + MYXTRABYTES);
  // SY5366 MODIFICATION END
  If Length(LASTkey) = 0 Then
    LASTkey := 'Z';
  //
  If CURkey > LASTkey Then
    Goto KEEPON;
  //                                it is time to write the sequential record now (assuming, of course, that there is data in it)
  If recd <> spac1000 Then
    BEGIN
  // SY5366 MODIFICATION START      SY5366: steal 20 of the bytes near far left of the record - to implant an indicator of filename of the associated output pdf
  //MYSETNO := IntToStr(SETNO);
  //zros10 := '0000000000';
  //MYSETNO := Copy(zros10 + MYSETNO, Length(zros10) + Length(MYSETNO) - 9, 10); // set ansistring version of set numbr for use in this sequential recd
  //MY44 := ansistring(RcvrPN + SWOK + CurDt + '_' + MYSETNO);
  // SY5366 MODIFICATION END
  // SY5366 MODIFICATION START      SY5366: steal 20 of the bytes near far left of the record - to implant an indicator of filename of the associated output pdf
  //  If MY44 <> ANSIstring(Copy(recd, 5, 24)) Then
  //     recd := ansistring(copy(recd, 1, 4) + MY44 +  copy(recd, 29, length(recd)-28));  // insert special 20-byte pdf file identifier to left side of seq recd
  // SY5366 MODIFICATION END
    myFileTSL.Add(recd);
    //WriteLn(myFile, recd);
    END;
  //
  If useCOL = 1 Then
  Begin
    //recd := spac1000;
    recd := CURpNUM + Copy(spac1000, 1, Length(spac1000) - Length(CURpNUM));  // set first 4 bytes of any sequential output record to be the participant number of the Broker/Dealer
    //Move(CURpNUM, recd[1], 4);
  End
  Else
  Begin
  // SY5366 MODIFICATION START (where you see 28 here, the number used USED to be 4)
    useCOL := useCOL + 28 + Length(MYXTRABYTES); // adjust column based on decision to implant stuff in left side of record
    Move(spac1000[1], recd[useCOL], (Length(recd) - useCOL));
    useCOL := useCOL - 28 - Length(MYXTRABYTES);
  End;
  //
  KEEPON:
  LASTkey := CURkey;
  recd := ansistring(copy(recd, 1, 4) + MY44 +  copy(recd, 49, length(recd)-48));   // ensure left side of record has proper key
  useCOL := useCOL + 28 + Length(MYXTRABYTES); // adjust column based on decision to implant data in first 28 bytes of created sequential recd
  // SY5366 MODIFICATION END
  Move(Data[1], recd[useCOL], Length(Data));
End;

// Determine which (carrier) participant number should get the current Grid document

Procedure GDocCo(Var AnswrPN: AnsiString; Const GSetByCo: tStringList; Const FSetNo: AnsiString);
Var
  N: Integer;
Begin
  For N := GSetByCo.Count - 1 Downto 0 Do
  Begin
    If FSetNo = Copy(GSetByCo[N], 1, 10) Then
      AnswrPN := Copy(GSetByCo[N], 11, 4);
  End;
End;

// Convert PDF file to TIF file

Procedure TForm1.ToTIF(Const workdir: AnsiString; Const TIFPARMS: AnsiString);
Var
  Dir: AnsiString;
Var
  RF: TRunAFile;
Begin
  GetDir(0, Dir);
  ChDir(workdir);
  RF := TRunAFile.Create(Nil);
  Try
    Screen.Cursor := crHourGlass;
    //
    RF.Params.WaitUntilDone := True;
    RF.Params.ProcParameters := TIFPARMS;
    RF.Params.ProcFileName := LGAIni.ReadString('Doc2Tif', 'Location', '');
    //
    { When debugging/Running in the IDE, don't hide the console window }
    If findcmdlineswitch('TEST') Then
      RF.Params.WindowType := wtNormal
    Else
      RF.Params.WindowType := wthide;

    If Not RF.Launch Then
      Raise Exception.Create('Cannot launch ' + RF.Params.ProcFileName);

    log.Write(DtNow(Now) + 'Created TIF: ' + tfilenm);

    DeleteFile(pfilenm);
    log.Write(DtNow(Now) + 'Deleted PDF: ' + pfilenm);
  Finally
    RF.Free;
    ChDir(Dir);
  End;
End;

//        M A I N L I N E

Procedure TForm1.Button1Click(Sender: tObject);
Var
  TAGFileTSL, FCFileTSL, FSFileTSL, P1FileTSL, P2FileTSL, GRIDFileTSL: TStringList;
  FCFileName, FSFileName, P1FileName, P2FileName: String;
  readcnt: Integer;
  N: Integer;
  inrec: AnsiString;
  openDialog: TOpenDialog;
  OFTSL, FworkTSL, WorkTSL, Grid1TSL, Grid2TSL, GSetByCo: tStringList;
  Page1TSL, Page2TSL: tStringList;
  InptFNam: AnsiString;
  DOCLAND: AnsiString;
  spac4: AnsiString;
  spac6: AnsiString;
  spac50: ShortString;
  spac1000: AnsiString;
  wrecfs: AnsiString;
  wrecfc: AnsiString;
  SKPing: AnsiString;                           // switch to indicate whether skipping is in progress
  SKPseqnc: AnsiString;                         // when skipping is in progress, shows which CURseqnc we are skipping
  WRTCT: Integer;
  DOPRT: AnsiString;
  CHPN: AnsiString;                                   // To be able to pass the participant number from the Contra Header to grid-build
  LRcvrPN: AnsiString;                                // LNA participant number of the Carrier who received the prior transaction
  CURpNUM: AnsiString;                                // LNA participant number of the requesting Broker/Dealer
  CRcvrPN: AnsiString;                                // LNA participant number of the Carrier who received this transaction
  CURseqnc: AnsiString;                               // LNA 53xx sequence from original LNA file
  CURrtyp: AnsiString;                                // Has data like B53xx
  CURfid: AnsiString;                                 // Has 3-byte field ID
  CURkey: AnsiString;                                 // key is made up of the B53xx + field ID
  CURfloc: AnsiString;                                // location within the 53xx recd where data came from
  CURflen: AnsiString;                                // len of the data taken from the 53xx record
  CURffmt: AnsiString;                                // dtcc-specified format of the data from the LNA 53xx rec
  CURfnam: AnsiString;                                // field label/name
  CURdtyp: AnsiString;                                // data type (A: agt level;  C: contact info;   S: state levl)
  CURrcf: AnsiString;                                 // RR.COL value for FC (sequential) output file
  CURrcs: AnsiString;                                 // RR.COL value for the FS (sequential) output file
  CURrpa: AnsiString;                                 // RR.COL value for the plotter / page-painter (grid) oput file #1
  CURcra: AnsiString;                                 // Collision Rule
  CURula: AnsiString;                                 // sw saying whether to include field label in grid oput
  CURuxa: AnsiString;                                 // sw saying whether to use transltn result field in grid oput
  CURfla: AnsiString;                                 // sw saying to reserve left side of line (make it unusable) when it is currently set to blanks
  CURrpb: AnsiString;                                 // RR.COL value for grid 2
  CURcrb: AnsiString;                                 // grid 2 collision rule
  CURulb: AnsiString;                                 // grid 2 'use label' switch
  CURuxb: AnsiString;                                 // grid 2 'use translation result' switch
  CURflb: AnsiString; // grid 2 sw saying to reserve left side of line (make it unusable) when it is currently set to blanks
  CURda: AnsiString;                                  // pre-translate (raw data) from the dtcc LNA 53xx record
  CURdb: AnsiString;                                  // translated value (if no translate applies, then this field has the raw data from the LNA rec)
  Data: AnsiString;
  FCOL, SCOL, P1COL, P2COL, P1ROW, P2ROW: Integer;
  G1POSTS: Integer;                               // num of updates made to Grid1 with something other than 'blanks' in the posted data field
  G2POSTS: Integer;                               // num of updates made to Grid2 with something other than 'blanks' in the posted data field
  SswOK, FswOK, P1swOK, P2swOK: AnsiString;
  P2LSTkey, P1LSTkey, FLSTkey, SLSTkey: AnsiString;
  G1PC, G2PC: AnsiString;
  G1PCN, G2PCN: Integer;
  G1OBL, G2OBL: AnsiString;
  LSTseqnc: AnsiString;
  WRTSETNO: AnsiString;
  SETNO: Integer;
  TRXCD: AnsiString;
  LSTTRXCD: AnsiString;
  TROKTOGO: AnsiString;
  G1TROKAY: AnsiString;                               // the set of LNA transactions acceptable to be processed into Grid 1
  G2TROKAY: AnsiString;                               // the set of LNA transactions acceptable to be processed into Grid 2
  records: longint;
  rc: Integer;
  SrtIFils, SrtOFil: AnsiString;
  today: tDateTime;
  CurDt: String;
  QP: TDebenuPDFLibrary;
  CURDOCNO: AnsiString;
  AnswrPN: AnsiString;
  LSTDOCNO: AnsiString;
  workdir, tifdir, xtifdir: AnsiString;
  TIFPARMS: AnsiString;
  OTEXT: AnsiString;
  RECNO: AnsiString;
  LRECWD: AnsiString;
  OFSETNO: Integer;
  HIGHOFSN: Integer;
  Emsg: AnsiString;
  workosn: AnsiString;
  zros10: AnsiString;
  LusedOF: AnsiString;
  ol: toutlookmail;
  fontID1, I: Integer;
  strg : AnsiString;

Label
  ADDTOTSL, LFDONE, NEXTREC, NOTHEAD, SKIPPRT1, ONWARDG1, SKIPPRT2, ONWARDG2, NEXTONE, NOPAGE2A, NOPAGE2X, NOPAGE2Z, NOT07A;

Begin
  lStatus.Caption := 'LNA Plotter started';
  Application.ProcessMessages;
  Button1.Enabled := False;
  //G1TROKAY := 'AI,AA,LI,LA,LC,TA,TR,NA,AD';           // this is probably the set we'd actually want to go with for grid 1   (the other G1TROKAY value here is just for testing)
  G1TROKAY := 'AI,AA,LI,LA,LC,TR,NA,AD';
  G2TROKAY := 'AI,AA,LI,LA,LC,TA';

  // OutPutfilepdf := IncludeTrailingBackSlash(WorkAreaUNC) + 'FacultativeDocuments\Temp\' + FileNameMVR + '.pdf';
  // ChDir(IncludeTrailingBackSlash(WorkAreaUNC) + 'FacultativeDocuments\Temp\');
  //
  // set Grid print control parameter defaults
  G1PC := '   ';
  G2PC := '   ';
  G1PCN := 99;
  G2PCN := 99;
  G1OBL := 'N';
  G2OBL := 'N';
  G1POSTS := 0;
  G2POSTS := 0;

  SKPing := '';                          // switch to indicate whether skipping is in progress
  SKPseqnc := '';                        // when skipping is in progress, shows which CURseqnc we are skipping

  SETNO := -1;
  TRXCD := '  ';
  LSTTRXCD := '  ';
  LSTseqnc := '';
  LRcvrPN := '    ';                              // default this participant number field to blanks
  zros10 := '0000000000';

  OFTSL := tStringList.Create;                    // create the TSL for storing 'set number' of any grid that encounters a print overflow condition
  GSetByCo := tStringList.Create;                 // create the TSL that will track which grid set goes with which receiving participant num

  P1swOK := '1';                                  //  indicate that the Grid-oriented (plotter) output file is in fine status currently
  P2swOK := '2';
  FswOK := 'F';                                   //  indicate that the FC output (sequential) file is in fine status currently
  SswOK := 'S';                                   //  indicate that the FS output (sequential) file is fine
  spac4 := AnsiString(stringofchar(' ', 4));
  spac6 := AnsiString(stringofchar(' ', 6));
  spac50 := AnsiString(stringofchar(' ', 50));
  spac1000 := AnsiString(stringofchar(' ', 1000));

  DateTimeToString(CurDt, 'yyyymmddhhnnsszz', Now);
  //
  // with parameters like /MASS, we may need to run multiple jobs at once.. so, build log in proper corresp workarea folder
  //
  If findcmdlineswitch('MASS') Then
   begin
    log := ttextfileout.Create(Format('%sLnaPLOT_%s.log', [WorkAreaUNC + 'MASS\Log\', CurDt]));
    GOTO LFDONE;
   end;
  //
  If findcmdlineswitch('MASS1') Then
   begin
    log := ttextfileout.Create(Format('%sLnaPLOT_%s.log', [WorkAreaUNC + 'MASS1\Log\', CurDt]));
    GOTO LFDONE;
   end;
  //
  If findcmdlineswitch('MASS2') Then
   begin
    log := ttextfileout.Create(Format('%sLnaPLOT_%s.log', [WorkAreaUNC + 'MASS2\Log\', CurDt]));
    GOTO LFDONE;
   end;
  //
  log := ttextfileout.Create(Format('%sLnaPLOT_%s.log', [WorkAreaUNC + 'DtccFiles\Log\', CurDt]));
  //
  LFDONE:
  //
  log.Write(DtNow(Now) + 'Begin Plotter program.');
  today := Now;
  CurDt := FormatDateTime('ddddd', today);        // CurDt will now have f format like this:  05/31/2000
  WorkTSL := tStringList.Create;
  WorkTSL.Text := StringReplace(CurDt, '/', #13#10, [rfReplaceAll]); // Split the date value into it's sub-components (all are 'AnsiString' components)
  If Length(WorkTSL[0]) < 2 Then
    WorkTSL[0] := '0' + WorkTSL[0];
  If Length(WorkTSL[1]) < 2 Then
    WorkTSL[1] := '0' + WorkTSL[1];
  CurDt := WorkTSL[2] + WorkTSL[0] + WorkTSL[1];     // CurDt will now have format like this: 20000531
  WorkTSL.Free;
  //
  {
  openDialog := TOpenDialog.Create(self);
  openDialog.InitialDir := GetCurrentDir;
  openDialog.Options := [ofFileMustExist];
  openDialog.Filter := ' CSV files|*.csv';
  workdir := openDialog.InitialDir;             //   THE VALUE OF workdir WILL NEED TO CHANGE ONCE WE ARE BEYOND UNIT TESTING
  if openDialog.Execute then
    begin
     FworkTSL := TStringList.Create;
     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
     InptFNam := FworkTSL[FworkTSL.Count - 1];
     Showmessage('Selected File:' + InptFNam);
    end
   else
    begin
     ShowMessage('File Selection Cancelled; Run Aborted !');
     Halt(0);
    end;
  }
  workdir := WorkAreaUNC + 'DtccFiles\LNA\';
  tifdir := WorkAreaUNC + 'DtccFiles\LNA\';        // tifdir will change at create of PDF/TIF
  //
  If findcmdlineswitch('MASS') Then                // set folder based on execution parameter
   begin
    workdir := WorkAreaUNC + 'MASS\';
    tifdir := WorkAreaUNC + 'MASS\';
   end;
  //
  If findcmdlineswitch('MASS1') Then               // set folder based on execution parameter
   begin
    workdir := WorkAreaUNC + 'MASS1\';
    tifdir := WorkAreaUNC + 'MASS1\';
   end;
  //
  If findcmdlineswitch('MASS2') Then               // set folder based on execution parameter
   begin
    workdir := WorkAreaUNC + 'MASS2\';
    tifdir := WorkAreaUNC + 'MASS2\';
   end;
  //
  If Not FileExists(workdir + 'CANDO_TAGFILE.CSV') Then
  Begin
    log.Write(DtNow(Now) + 'File missing ' + workdir + 'CANDO_TAGFILE.CSV');
    ShowMessage('REQUIRED FILE (CANDO_TAGFILE) NOT FOUND IN ' + workdir + ' Run Aborted !');
    close;
  End
  Else
  Begin
    InptFNam := workdir + 'CANDO_TAGFILE.CSV';
    Grid1TSL := tStringList.Create;
    Grid2TSL := tStringList.Create;
    //
    While Grid1TSL.Count < 99 Do                  // initialize grids with blank records
    Begin
      Grid1TSL.Add(Copy(spac1000, 1, 999));
      Grid2TSL.Add(Copy(spac1000, 1, 999));
    End;
    //
    readcnt := 0;
    wrecfs := spac1000;                           // now, initialize the work record for FS file
    wrecfc := spac1000;                           // now, initialize the work record for FC file
    TAGFileTSL := TStringList.Create;
    TAGFileTSL.LoadFromFile(InptFNam);
    //
    FCFileTSL := TStringList.Create;
    FSFileTSL := TStringList.Create;
    P1FileTSL := TStringList.Create;
    P2FileTSL := TStringList.Create;
    //
    FCFileName := workdir + 'LNA_SEQ_FC.txt';
    FSFileName := workdir + 'LNA_SEQ_FS.txt';
    P1FileName := workdir + 'LNA_GRID1.txt';
    P2FileName := workdir + 'LNA_GRID2.txt';
    //
    lStatus.Caption := 'Working on ' + InptFNam;
    log.Write(DtNow(Now) + 'Working on ' + InptFNam);
    Application.ProcessMessages;
    x := 0;

    for inrec in TAGFileTSL do

    Begin
      Inc(x);
      lStatus.Caption := 'TagFile line: ' + IntToStr(x);
      //log.Write(DtNow(Now) + 'TagFile line: ' + IntToStr(x));
      Application.ProcessMessages;

      OFSETNO := 0; // indicate that the upcoming data item was NOT plotted into a row that is beyond end of printed page

      WRTSETNO := Copy(spac1000, 1, 10);          // default this to say no grid has just been written to grid1 or grid2 file
      WorkTSL := tStringList.Create;
      readcnt := readcnt + 1;                     // if it is a detail record, go process detail record
      //
      WorkTSL.Text := StringReplace(inrec, ',', #13#10, [rfReplaceAll]);
      //
      if SKPing = 'Y' then                        // enable a skip of an input record set
        begin
           if WorkTSL[3] = SKPseqnc then
             begin
                Goto NEXTREC;
             end
           else
             begin
                SKPing := 'N';
             end
        end;
      //
      //if readcnt > 1 then GOTO NOTHEAD;
      Strg := AnsiString(Copy(inrec, 4, 1));
      If IsStrANumber(Strg) = True Then
        Goto NOTHEAD;                             // a non-numeric in byte 4 of any input record means that this is a detail record (not a header rec)
      //
      // For "Grid" type outputs, the header label is to be either GR.COL or GR.OBL.    (but, read on...)
      // COL means standard grid processing (where if ANY bytes of the grid are filled in, we write the entire grid to output).
      // OBL means when writing the grid to output, only actually write the grid rows that have some non-blank character in the row.
      // BUT - a hybrid of each of the two options (COL and OBL) DOES exist:
      //       for instance, C65 (in place of COL) would mean to process as if it was COL, but limit output count to 65 at max);
      //       and O53 would mean to only write non-blank lines AND limit the output count to no more than 53 writes.
      //
      For N := 0 To WorkTSL.Count - 1 Do
      Begin
        If (Length(WorkTSL[N]) = 6) And (Copy(WorkTSL[N], 1, 3) = 'GR.') Then
        Begin
          If G1PC = '   ' Then
            G1PC := Copy(WorkTSL[N], 3, 3)
          Else
            If G2PC = '   ' Then
              G2PC := Copy(WorkTSL[N], 3, 3);
        End;
      End;
      //
      If IsStrANumber(Copy(G1PC, 2, 1)) = True Then
        G1PCN := StrToInt(Copy(G1PC, 2, 2));
      If IsStrANumber(Copy(G2PC, 2, 1)) = True Then
        G2PCN := StrToInt(Copy(G2PC, 2, 2));
      //
      If Copy(G1PC, 1, 1) = 'O' Then
        G1OBL := 'Y';
      If Copy(G2PC, 1, 1) = 'O' Then
        G2OBL := 'Y';
      //
      Goto NEXTREC;
      //
      NOTHEAD:
      //
      CURpNUM := Copy(WorkTSL[0], 1, 4);          // get this Broker/Dealer's participant number
      //
      CRcvrPN := Copy(WorkTSL[1], 1, 4);          // get recipient carrier participant number for this incoming data item
      CHPN := Copy(WorkTSL[1], 5, 4);             // Grab the sender participant number from Contra Header
      //
      CURseqnc := WorkTSL[3];                     // This is a count field from when the raw LNA input file was first seen (part of our key)
      CURrtyp := WorkTSL[4];                      // Has data like B53xx
      CURfid := WorkTSL[5];                       // Has 3-byte field ID
      CURkey := CURrtyp + CURfid;                 // key is made up of the B53xx + field ID
      CURfloc := WorkTSL[6];                      // location within the 53xx recd where data came from
      CURflen := WorkTSL[7];                      // len of the data taken from the 53xx record
      CURffmt := WorkTSL[8];                      // dtcc-specified format of the data from the LNA 53xx rec
      CURfnam := WorkTSL[9];                      // field label/name
      CURdtyp := WorkTSL[10];                     // data type (A: agt level;  C: contact info;   S: state levl)
      CURrcf := WorkTSL[11];                      // RR.COL value for FC (sequential) output file
      CURrcs := WorkTSL[12];                      // RR.COL value for the FS (sequential) output file
      CURrpa := WorkTSL[13];                      // RR.COL for gridA
      CURcra := WorkTSL[14];                      // Collision Rule for gridA
      CURula := WorkTSL[15];                      // sw saying whether to include field label - gridA
      CURuxa := WorkTSL[16];                      // sw saying whether to use transltn result - gridA
      CURfla := WorkTSL[17];                      // sw saying that currently-blank 'left side' of record should be made unusable - gridA
      CURrpb := WorkTSL[18];                      // RR.COL for gridB
      CURcrb := WorkTSL[19];                      // Collision Rule for gridB
      CURulb := WorkTSL[20];                      // sw saying whether to include field label - gridB
      CURuxb := WorkTSL[21];                      // sw saying whether to use transltn result - gridB
      CURflb := WorkTSL[22];                      // sw saying that currently-blank 'left side' of record should be made unusable - gridB
      CURda := WorkTSL[23];                       // pre-translate (raw data) from the dtcc LNA 53xx record
      CURdb := WorkTSL[24];                       // translated value (or raw data if no translate was done)
      //
      if (CURkey = 'B531206A') and (Length(CURda) < 2) then   // skip recordset 5312 if first field is empty
        begin
          SKPseqnc := CURseqnc;
          SKPing := 'Y';
          Goto NEXTREC;
        end;
      //
      If (CURrtyp = 'B5301') And (LSTseqnc <> CURseqnc) Then
      Begin                                       // see if we are starting a new 'set'
        SETNO := SETNO + 1;
        LSTTRXCD := TRXCD;
        TRXCD := '  ';
      End;
      //
      If CURkey = 'B530107A' Then
        TRXCD := CURda;                           // set the LNA trx code here
      //
      //
      If (Trim(CURfnam) = 'PRD.TAXID') and (Length(CURdb) < 9) then              // if DTCC-provided SSN is less than 9 long, make it be 9 long
       Begin
        CURdb := Copy(zros10 + CURdb, Length(zros10) + Length(CURdb) - 8, 9);
       End;
      //
      //
      If CURda = '    ' Then
        Data := CURdb                             // Isolate the data that actually came to us in the 53xx
      Else
        Data := CURda;
      //   SY5366 MODIFICATION START
      // Change an uppercase L to lower case L in some instances
      if (TRXCD = 'AI  ') and (Trim(CURfnam) = 'LIC.LOA') and (copy(Data, 1, 2) = 'LI') then    // to help in LNADA sort
       move (AnsiString(SysUtils.LowerCase(copy(Data, 1, 1)))[1], Data[1], 1);
      if (TRXCD = 'AA  ') and (Trim(CURfnam) = 'LIC.LOA') and (copy(Data, 1, 2) = 'LI') then    // to help in LNADA sort
       move (AnsiString(SysUtils.LowerCase(copy(Data, 1, 1)))[1], Data[1], 1);
      //   SY5366 MODIFICATION END
      If (CURrcf <> spac6) And (FswOK = 'F') Then
      Begin
        WorkTSL.Free;
        WorkTSL := tStringList.Create;
        WorkTSL.Text := StringReplace(CURrcf, '@', #13#10, [rfReplaceAll]);
        FCOL := StrToInt(WorkTSL[1]);
        // SY5366 MODIFICATION START (send extra parameters to the subroutine)
        BuildSeq(FCFileTSL, CHPN, FCOL, Data, wrecfc, CURkey, FLSTkey, FswOK, SETNO, CurDt, CRcvrPN, spac1000);
        // SY5366 MODIFICATION END
        If FswOK <> 'F' Then
        Begin
          s := 'Error Processing FC (Sequential) file: ' + FswOK +
            '.  But, will attempt to finish any other in-process files.';
          log.Write(DtNow(Now) + s);
        End;
      End;
      //
      If (CURrcs <> spac6) And (SswOK = 'S') Then
      Begin
        WorkTSL.Free;
        WorkTSL := tStringList.Create;
        WorkTSL.Text := StringReplace(CURrcs, '@', #13#10, [rfReplaceAll]);
        SCOL := StrToInt(WorkTSL[1]);
        // SY5366 MODIFICATION START (send extra parameters to the subroutine)
        BuildSeq(FSFileTSL, CHPN, SCOL, Data, wrecfs, CURkey, SLSTkey, SswOK, SETNO, CurDt, CRcvrPN, spac1000);
        // SY5366 MODIFICATION END
        If SswOK <> 'S' Then
        Begin
          s := 'Error Processing SC (Sequential) file: ' + SswOK +
            '.  But, will attempt to finish any other in-process files.';
          log.Write(DtNow(Now) + s);
        End;
      End;
      //
      If (Length(CURrpa) = 6) And (CURrpa <> spac6) And (P1swOK = '1') Then
      Begin
        WRTSETNO := Copy(spac1000, 1, 10);        // default this to say no grid has just been written to grid1 or grid2 file
        WorkTSL.Free;
        WorkTSL := tStringList.Create;
        WorkTSL.Text := StringReplace(CURrpa, '@', #13#10, [rfReplaceAll]);
        P1ROW := StrToInt(WorkTSL[0]);
        P1COL := StrToInt(WorkTSL[1]);
        Grid(P1FileTSL, CHPN, CURpNUM, CURfla, G1TROKAY, SETNO, LSTTRXCD, P1ROW, P1COL, CURda, CURdb, CURfnam,
          Grid1TSL,
          CURkey, P1LSTkey, P1swOK, G1POSTS, G1PCN, G1OBL, CURcra, CURula, CURuxa, spac1000, WRTSETNO,
          OFSETNO, HIGHOFSN);
        If OFSETNO <> 0 Then
        Begin
          workosn := IntToStr(OFSETNO);
          HIGHOFSN := OFSETNO;
          OFTSL.Add(Copy(zros10 + workosn, Length(zros10) + Length(workosn) - 9, 10));
        End;
        If WRTSETNO <> Copy(spac1000, 1, 10) Then
          GSetByCo.Add(WRTSETNO + LRcvrPN);
        If P1swOK <> '1' Then
        Begin
          s := 'Error Processing P1 (Grid) file:' + P1swOK +
            '.  But, will attempt to finish any other in-process files.';
          log.Write(DtNow(Now) + s);
        End;
      End;
      //
      If (Length(CURrpb) = 6) And (CURrpb <> spac6) And (P2swOK = '2') Then
      Begin
        WRTSETNO := Copy(spac1000, 1, 10);        // default this to say no grid has just been written to grid1 or grid2 file
        WorkTSL.Free;
        WorkTSL := tStringList.Create;
        WorkTSL.Text := StringReplace(CURrpb, '@', #13#10, [rfReplaceAll]);
        P2ROW := StrToInt(WorkTSL[0]);
        P2COL := StrToInt(WorkTSL[1]);
        Grid(P2FileTSL, CHPN, CURpNUM, CURflb, G2TROKAY, SETNO, LSTTRXCD, P2ROW, P2COL, CURda, CURdb, CURfnam,
          Grid2TSL,
          CURkey, P2LSTkey, P2swOK, G2POSTS, G2PCN, G2OBL, CURcrb, CURulb, CURuxb, spac1000, WRTSETNO,
          OFSETNO, HIGHOFSN);
        If OFSETNO <> 0 Then
        Begin
          workosn := IntToStr(OFSETNO);
          HIGHOFSN := OFSETNO;
          OFTSL.Add(Copy(zros10 + workosn, Length(zros10) + Length(workosn) - 9, 10));
        End;
        If WRTSETNO <> Copy(spac1000, 1, 10) Then
          GSetByCo.Add(WRTSETNO + LRcvrPN);
        If P2swOK <> '2' Then
        Begin
          s := 'Error Processing P2 (Grid) file:' + P2swOK +
            '.  But, will attempt to finish any other in-process files.';
          log.Write(DtNow(Now) + s);
        End;
      End;
      //
      If CURkey = 'B530107A' Then
        LRcvrPN := CRcvrPN; //  after finishing processing of a 530107A, then set this field to what carrier PN just got put into grid
      //
      NEXTREC:
      LSTseqnc := CURseqnc;
      WorkTSL.Free;
    End;
    //
    TAGFileTSL.Free;

    If wrecfs <> spac1000 Then
      FSFileTSL.Add(wrecfs);

    FSFileTSL.SaveToFile(FSFileName,Tencoding.ANSI);
    FSFileTSL.Free;

    If wrecfc <> spac1000 Then
      FCFileTSL.Add(wrecfc);

    FCFileTSL.SaveToFile(FCFileName,Tencoding.ANSI);
    FCFileTSL.Free;

    //
    SETNO := SETNO + 1;
    CURkey := 'ZZZZZZZZ';                         // send this special key value when we are going for our final trip
    WRTSETNO := Copy(spac1000, 1, 10);            // default this to say no grid has just been written to grid1 or grid2 file
    Grid(P1FileTSL, CHPN, CURpNUM, CURfla, G1TROKAY, SETNO, TRXCD, P1ROW, P1COL, CURda, CURdb, CURfnam, Grid1TSL,
      CURkey, P1LSTkey, P1swOK, G1POSTS, G1PCN, G1OBL, CURcra, CURula, CURuxa, spac1000, WRTSETNO, OFSETNO, HIGHOFSN);
    If OFSETNO <> 0 Then
    Begin
      workosn := IntToStr(OFSETNO);
      HIGHOFSN := OFSETNO;
      OFTSL.Add(Copy(zros10 + workosn, Length(zros10) + Length(workosn) - 9, 10));
    End;
    If WRTSETNO <> Copy(spac1000, 1, 10) Then
      GSetByCo.Add(WRTSETNO + LRcvrPN);
    WRTSETNO := Copy(spac1000, 1, 10);            // default this to say no grid has just been written to grid1 or grid2 file
    Grid(P2FileTSL, CHPN, CURpNUM, CURflb, G2TROKAY, SETNO, TRXCD, P2ROW, P2COL, CURda, CURdb, CURfnam, Grid2TSL,
      CURkey, P2LSTkey, P2swOK, G2POSTS, G2PCN, G2OBL, CURcrb, CURulb, CURuxb, spac1000, WRTSETNO, OFSETNO, HIGHOFSN);
    If OFSETNO <> 0 Then
    Begin
      workosn := IntToStr(OFSETNO);
      HIGHOFSN := OFSETNO;
      OFTSL.Add(Copy(zros10 + workosn, Length(zros10) + Length(workosn) - 9, 10));
    End;
    If WRTSETNO <> Copy(spac1000, 1, 10) Then
      GSetByCo.Add(WRTSETNO + LRcvrPN);
    P1FileTSL.SaveToFile(P1FileName,TEncoding.ANSI);
    P2FileTSL.SaveToFile(P2FileName,TEncoding.ANSI);
    P1FileTSL.Free;
    P2FileTSL.Free;
    //
    // Each input record 'set' can only go with ONE receiver (carrier) dtcc participant...  the GSetByCo TSL is used to
    // keep track of which of our participant numbers each input set (of transaction data) went with.  (it relates only to Grid
    // type outputs...not 'sequential' outputs).  the routine that is about to run will skinny down the GSetByCo TSL such that each
    // written Grid entry will tie to only ONE of the carrier particpant numbers. (format of each entry is record-set-num
    // (for 10bytes) followed by carrier-participant (for 4 bytes)).  These 14-byte entries will later be used to help us know
    // which ALI queue (Banner or Penn) to put each plotted document to.
    //
    For N := GSetByCo.Count - 1 Downto 0 Do
    Begin
      If N > 0 Then
      Begin
        If GSetByCo[N] = GSetByCo[N - 1] Then
          GSetByCo.Delete(N);
      End;
    End;
    //
    //   Now, sort all created grids into a single output grid
    //
    //SrtIFils := 'c:file1.txt+c:file2.txt+c:file3.txt';
    SrtIFils := Format('%sLNA_GRID1.txt+%sLNA_GRID2.txt', [workdir, workdir]);
    SrtOFil := workdir + 'LNA_GRIDS.txt';
    OtSort(SrtIFils, SrtOFil, 's(#1,c,a)', records, rc);
    //
    //   Form this point, all that should be left is creating the image files that are destined for the new "DTCC queue" in ALI
    //
    lStatus.Caption := 'Begin creating images';
    Application.ProcessMessages;
    // SY5366 MODIFICATION BEGIN
    log.Write(DtNow(Now) + 'Creating Output Documents.');
    // SY5366 MODIFICATION END
    GRIDFileTSL := TStringList.Create;
    GRIDFileTSL.LoadFromFile(SrtOFil);
    pfilenm := '';
    //
    TDebenuPDFLibrary.Create;  // intentional memory leak - to load this DLL
    QP := TDebenuPDFLibrary.Create;
    QP.UnlockKey('jm7ci9co4a43jx53o5co5nb7y');
    fontID1 := QP.AddStandardFont(1);       // 0=Courier 1=CourierBold 2=CourierBoldOblique 3=? 4=Helvetica 5=HelveticaBold
    QP.SelectFont(fontID1);
    QP.SetTextSize(10);
    QP.SetOrigin(1);
    LSTDOCNO := '';
    //
    Page1TSL := tStringList.Create;
    Page2TSL := tStringList.Create;
    //
    DOCLAND := 'packageinDTCChold\';
    If findcmdlineswitch('MASS') Then DOCLAND := 'packageinDTCCmass\';
    If findcmdlineswitch('MASS1') Then DOCLAND := 'packageinDTCCmass1\';
    If findcmdlineswitch('MASS2') Then DOCLAND := 'packageinDTCCmass2\';
    //
    x := 0;
    Try

      for inrec in GRIDFileTSL do

       Begin
        Inc(x);
        lStatus.Caption := 'GridFile line: ' + IntToStr(x);
        Application.ProcessMessages;
        //
        CURDOCNO := Copy(inrec, 1, 10);                                       // doc number is first 10 bytes of the GRIDS recd
        //
        if x = 1 then
         begin
          pfilenm := CurDt + '_' + Copy(inrec, 1, 11) + '.pdf';               // set filename of FIRST pdf we will create
          AnswrPN := '????';
          GDocCo(AnswrPN, GSetByCo, CURDOCNO);                                // set AnswrPN to either 7976 or 7977 (penn)
          Case StrToInt(AnswrPN) Of
            7976: tifdir := LGAIni.ReadString('Banner', 'Agentimagearea', '') + DOCLAND;
            7977: tifdir := LGAIni.ReadString('Penn', 'Agentimagearea', '') + DOCLAND;
          End;
          pfilenm := tifdir + pfilenm;                                        // finish setting the filename
         end;
        //
        if CURDOCNO = LSTDOCNO then goto ADDTOTSL;                            // if still on same doc, branch.  Otherwise wrt existing one and then start over
        //
        if Page1TSL.count > 0 then
         begin
          QP.DrawTextBox(0, 15, 847, 1070, Page1TSL.text, 1);
         end;
        //
        if Page2TSL.count > 0 then
         begin
          QP.NewPages(1);
          fontID1 := QP.AddStandardFont(1);       // 0=Courier 1=CourierBold 2=CourierBoldOblique 3=? 4=Helvetica 5=HelveticaBold
          QP.SelectFont(fontID1);
          QP.SetTextSize(10);
          QP.SetOrigin(1);
          QP.DrawTextBox(0, 15, 847, 1070, Page2TSL.text, 1);
         end;
        //
        QP.SaveToFile(pfilenm);
        QP.Free;
        QP := TDebenuPDFLibrary.Create;
        QP.UnlockKey('jm7ci9co4a43jx53o5co5nb7y');
        fontID1 := QP.AddStandardFont(1);       // 0=Courier 1=CourierBold 2=CourierBoldOblique 3=? 4=Helvetica 5=HelveticaBold
        QP.SelectFont(fontID1);
        QP.SetTextSize(10);
        QP.SetOrigin(1);
        Page1TSL.Clear;
        Page2TSL.Clear;
        //
        pfilenm := CurDt + '_' + Copy(inrec, 1, 11) + '.pdf';                 // set filename of NEXT pdf we will create
        AnswrPN := '????';
        GDocCo(AnswrPN, GSetByCo, CURDOCNO);                                  // set AnswrPN to either 7976 or 7977 (penn)
        Case StrToInt(AnswrPN) Of
          7976: tifdir := LGAIni.ReadString('Banner', 'Agentimagearea', '') + DOCLAND;
          7977: tifdir := LGAIni.ReadString('Penn', 'Agentimagearea', '') + DOCLAND;
        End;
        pfilenm := tifdir + pfilenm;                                          // finish setting the filename
        //
       ADDTOTSL:
        //
        if Copy(inrec, 11, 1) = '1' then
         begin
          Page1TSL.add(Copy(inrec, 21, 120));        // take these 100 bytes from this GRIDS recd to make it part of pg1
         end
        else
         begin
          Page2TSL.add(Copy(inrec, 21, 120));        // take these 100 bytes from this GRIDS recd to make it part of pg2
         end;
        //
        LSTDOCNO := CURDOCNO;
       end;
       //
       if Page1TSL.count > 0 then
        begin
         QP.DrawTextBox(0, 15, 847, 1070, Page1TSL.text, 1);
        end;
       //
       if Page2TSL.count > 0 then
        begin
         QP.NewPages(1);
         fontID1 := QP.AddStandardFont(1);       // 0=Courier 1=CourierBold 2=CourierBoldOblique 3=? 4=Helvetica 5=HelveticaBold
         QP.SelectFont(fontID1);
         QP.SetTextSize(10);
         QP.SetOrigin(1);
         QP.DrawTextBox(0, 15, 847, 1070, Page2TSL.text, 1);
        end;
        //
        QP.SaveToFile(pfilenm);
        Page1TSL.Free;
        Page2TSL.Free;
        //
    Finally
      QP.Free;
      GRIDFileTSL.Free;
      log.Write(DtNow(Now) + 'Finished creating document files.');
    End;
  End;
  GSetByCo.Free;                                  // end processing CANDO_TAGFILE.CSV

  //  HERE IS WHERE WE SEND THE EMAIL FOR GRID PAGE-2 (STATE) OVERFLOW SITUATIONS

  If OFTSL.Count > 0 Then
  Begin
    Emsg := '';
    LusedOF := '';
    For N := 0 To OFTSL.Count - 1 Do              //    Emsg will contain the 'body' of the email
    Begin
      If LusedOF <> OFTSL[N] Then
        Emsg := Emsg + CurDt + '_' + OFTSL[N] + #13#10;
      LusedOF := OFTSL[N];
    End;
    ol := toutlookmail.Create;
    ol.Subject := 'DTCC LNA ALI DOC BUILD: The Listed Doc(s) May Have Overflowed.';
    ol.Body.Add(Emsg);
    If findcmdlineswitch('TEST') Then
    //SY5366 MODIFICATION START   - send test email to gary, not Pia
      ol.addRecipient('gmarbach')
    //SY5366 MODIFICATION END
    Else
      ol.addRecipient('LNA_CANTDO');
    ol.Sendemail;
    ol.Free;
    log.Write(DtNow(Now) + 'LNA ALI State Page Overflow email sent.');
  End;
  OFTSL.Free;

  log.Write(DtNow(Now) + 'Finished Plotter program.');
  log.Free;
  close;

End;

Procedure TForm1.FormCreate(Sender: tObject);
Begin
  //
End;

Procedure TForm1.FormClose(Sender: tObject; Var Action: TCloseAction);
Begin
  //
End;

Procedure TForm1.FormShow(Sender: tObject);
Begin
  Button1.Enabled := True;
End;

End.

}}}LNADA.dfm
object Form1: TForm1
  Left = 412
  Top = 190
  Caption = 'LNA Automation Request Data Arranger'
  ClientHeight = 197
  ClientWidth = 618
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  OnClose = FormClose
  OnCreate = FormCreate
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 618
    Height = 197
    Align = alClient
    TabOrder = 0
    object Label1: TLabel
      Left = 24
      Top = 112
      Width = 37
      Height = 13
      Caption = 'Status'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clWindowText
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = [fsBold, fsUnderline]
      ParentFont = False
    end
    object lStatus: TLabel
      Left = 24
      Top = 136
      Width = 100
      Height = 13
      Caption = 'Status Message here'
    end
    object Button1: TButton
      Left = 280
      Top = 72
      Width = 75
      Height = 25
      Caption = 'Run'
      TabOrder = 0
      OnClick = Button1Click
    end
  end
end
}}}LNADA
Unit LNADA;

// This pgm enables systematic handling of DTCC-requested (LNA) data events.   It matches
// Automation Requests (a 'row' from a control spreadsheet) to the incoming LNA data for the day.  In
// this program, we match the parameters of these automation requests to the LNA transactitons/events
// that came in from DTCC - and we create a "data change packet" for each automation request that
// has some related LNA data.  For those LNA transactions we cannot handle via automation - these will
// still go the 'old' way [we copy the LNAPLOT document to the normal Licensing indexing queue - and
// Licensing team handles them via ALI].  A note about the Automation Requests control/input spreadsheet:
// this input needs to be found in the regular WORKAREA DTCCFILES/LNA folder.   Within this CSV file,
// a row is considered to be a 'comment' if the FIRST byte of the row is an asterisk.  So - that means
// that 'comments' are allowed in that file... and we used comments (as well as notes within column
// headers, etc) within that file to describe what each column/field is for. UPDATE 2/22/2022: Adding
// /MASS command line switch - because this program needs to be able to run the "normal" way (as part
// of LNA cycle) - AND - it also needs to be able to run in support of the Mass Load - which is
// spreadsheet based (and which works not in DTCCFILES folder of workarea, but in MASS folder instead).
//
// CHANGE LOG:
//
// INIT  CHGDATE  TAG      PURPOSE
// --- ---------- ------   -----------------------------------------------------------------------------------------------------
// GM :2021-11-05 SY5366 - Arrange auto-handleable LNA data into "packets" for handling by a subsequent process (program origin)
// GM :2021-11-28 SY5366 - add a lookup of the AI transaction agent [based on SSN] in LifePRO database, and if present, record NID
// GM :2021-12-07 SY5366 - for any LNA event that we CANNOT handle programmatically: send the LNAPLOT pdf over to the Lic index queue
// GM :2021-12-29 SY5366 - change to re-order S LOA records so that the LI/AC one always comes in first [based on sort done in this pgm]
// GM :2022-02-25 SY6355 - Add EDJ; add Company processing, Backup handling, \MASS exec parm so can use this pgm with sprdsht load
// GM :2022-03-12 SY6355 - Add support for "AA" (additional appointment)
// GM :2022-03-24 SY6964 - Change sort to handle mult States on an LNA AI and also update Lic array handling for same
// GM :2022-05-06 SY7206 - in the "AI" routine, save EDJ actual "first agt num" suggested for each 30-org... then compare
// GM :2022-05-24 SY7199 - Add a Try/Except to the SQL INSERT so can continue processing if insert fails (and send email for aborted packet build)
// GM :2022-04-20 SY6355 - when exec parm of "\movedocsbyco" exists, MoveDocs rtn to handle ONLY the docs that go with the Co for which this run pertains to.
// GM :2023-07-07 ?????? - Performance changes made in common unites (ULifepro) require addition of a .CREATE for the LPRO object, now + 1 update to this
// GM :2023-08-25 LB1840B- Log.Logit has started ommitting some of the messages sent to log files when Log Cache = true - so, turning off caching of logs
//
Interface

Uses
  Windows, Messages, SysUtils, Variants, StrUtils, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler, SABUtils, uGWobj,
  System.types, System.IOUtils, ulogfile,
  IdIOHandlerStream, adodb, db, DateUtils, ComCtrls, uLGAini,
  ExtCtrls, DebenuPDFLibrary, Ulifepro, unameobj, uagntcpy, cobutl32, ShellApi, BTRCONST;

Type
  TForm1 = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Label1: tLabel;
    lStatus: tLabel;
    Procedure Button1Click(Sender: tObject);
    Procedure FormCreate(Sender: tObject);
    Procedure FormClose(Sender: tObject; Var Action: TCloseAction);
    Procedure FormShow(Sender: tObject);
  Private
    { Private declarations }
//    Lpro: tLifepro;                                  This is commented out (as of 7/7/2023) based on Dan W's advice on best use of Performance mods
    srchagnt: fagntmst_struct;
    BannerData: TADOConnection;
    procedure SendAbortPacketEmail(Const CurDt: AnsiString;
    Const AR_OBARID: AnsiString; Const PLogMsg: AnsiString;
      Const COMPANY: AnsiString; Var EM_RC: Integer);
    Procedure MoveDocs(Const COMPANY: AnsiString; Const MDBCPARMEXISTS: AnsiString;
      Const workdir: AnsiString);
    Procedure SETFA(Var FAKEY: AnsiString; Var FAVALU: AnsiString;
      Var X: Integer; CONST AIFATSL: TStringList);
    Procedure LoadDatabase;
    Procedure CreateL(Var licenseTSL: TStringList; Var PREC_LIC: AnsiString;
      Var L: Integer);
    Procedure DoAgtNum(Var DAN_RC: Integer; Var PREC_AGT: AnsiString;
      Var post: AnsiString; Const pre: AnsiString; Const lo: AnsiString;
      Const cla: AnsiString; Const currCO: AnsiString;
      Const maxagtn: AnsiString; Const SQLupdTN: AnsiString;
      Const AR_OBARID: AnsiString; Const CurDt: AnsiString);
    Procedure ChPk2AI(Var CP2_RC: Integer; Var HeadRecScnt: Integer;
      Var HeadRecFcnt: Integer; Var PFileName: AnsiString;
      Var PLogMsg: AnsiString; Var FANSugg: AnsiString;
      Const HeadRecB: AnsiString; Const AR_OBARID: AnsiString;
      Const PCRTSL: TStringList; Const workdir: AnsiString;
      Const CurDt: AnsiString);
    Procedure ChPk2AA(Var CP2_RC: Integer; Var HeadRecScnt: Integer;
      Var HeadRecFcnt: Integer; Var PFileName: AnsiString;
      Var PLogMsg: AnsiString; Const HeadRecB: AnsiString;
      Const AR_OBARID: AnsiString; Const PCRTSL: TStringList;
      Const workdir: AnsiString; Const CurDt: AnsiString);
    Procedure ChPk1(Var HeadRecScnt: Integer; Var HeadRecFcnt: Integer;
      Const HeadRecB: AnsiString; Const AR_OBARID: AnsiString;
      Const AR_OBROKA: AnsiString; Const AR_FROMPN: AnsiString;
      Const AR_TOPN: AnsiString; Const AR_TRXCD: AnsiString;
      Const AR_FIID: AnsiString; Const AR_RAWSR: AnsiString;
      Const PCRTSL: TStringList; Const workdir: AnsiString);
    Procedure PCRedit(Var PCRTSL: TStringList; Var PCRbadRule: AnsiString;
      Var PCRbadValue: AnsiString);
    Procedure SetViaPCR(Const PCRTSL: TStringList; Const RULE: AnsiString;
      Var VALUE: AnsiString);
    Procedure Move2Bkup(CONST workdir: AnsiString; CONST FNpattern: AnsiString);

  Public
    { Public declarations }
    log: TAppLogFile;
    s, pfilenm, tfilenm: AnsiString;
    X: Integer;
  End;

Var
  Form1: TForm1;
  ReadOnly: Boolean;

Implementation

{$R *.dfm}
// FUNCTIONS



Function IsStrANumber(Const s: AnsiString): Boolean;
Var
  P: PAnsiChar;
Begin
  P := PAnsiChar(s);
  Result := False;
  While P^ <> #0 Do
  Begin
    If Not(P^ In ['0' .. '9']) Then
      Exit;
    Inc(P);
  End;
  Result := True;
End;







// SUBROUTINES

// ==============================================================================
// procedure SendAbortPacketEmail lets identified persons know about the need to
// abort LNADA processing of a given Packet.
// ==============================================================================
Procedure TForm1.SendAbortPacketEmail(Const CurDt: AnsiString;
  Const AR_OBARID: AnsiString; Const PLogMsg: AnsiString; Const COMPANY: AnsiString; Var EM_RC: Integer);

Var
  Gw: TGWObj;
  Recip: AnsiString;

Begin
  EM_RC := 0;
  //
  // IT suggested that Business supply email address for such notices to go to.
  // They responded by creating one that is really ONLY for Edward Jones
  // (which is a bad idea, since we'd need to make more programming changes later).
  // So, commenting out this program's usage of the general (Banner) email address:
  //
  Recip := 'EDJlicensing@lgamerica.com';
  //
  //Recip := 'agentlicensing@bannerlife.com';
  //If COMPANY = 'WP' then
  // Recip := 'wp_agent_licensing@lgamerica.com';
  //
  Gw := TGWObj.Create();
  Gw.Subject := 'DTCC LNA DataArranger Error: ' + CurDt + ' Build of Automation_Request packet ' +
    AR_OBARID + ' aborted for CO ' + COMPANY;
  Gw.BodyText.Add(PLogMsg);
  //
  // if attachments
  // Gw.Attachments.Add(ChangeFileExt(tfilerec(lv.Selected.Data).FileName, '.TIF'));
  //
  Gw.Recipients.Add(Recip);                       //gary
  Gw.CC.Add('GMarbach@lgamerica.com; MWaas@lgamerica.com; MAbrams@lgamerica.com; NCarlson@lgamerica.com');
  //
  if not Gw.SendMessage then
  begin
    EM_RC := 1;
  end;
  Freeandnil(Gw);
end;

// ==============================================================================
// procedure MoveDocs - after all Automation Requests are processed, this routine
// moves to Licensing indexing queues any LNAPLOT docs that we won't be auto-handling.
// NEW MOD: If \movedocsbyco execution parm exists, then this move of remaining
// LNAPLOT documents to indexqueue should be done ONLY for the company that this
// current run pertains to.
// ==============================================================================
Procedure TForm1.MoveDocs(Const COMPANY: AnsiString; Const MDBCPARMEXISTS: AnsiString; Const workdir: AnsiString);

Var
  WORKIN: TextFile;
  spac1000: AnsiString;
  I: Integer;
  QP: tDebenuPDFLibrary;
  Rslt: Boolean;
  readcnt: Integer;
  convtcnt: Integer;
  Result: Integer;
  DOCPATH: AnsiString;
  TOPN: AnsiString;
  INPATH: AnsiString;
  LASTKEY: AnsiString;
  DocNam: AnsiString;
  filenm: AnsiString;
  InptFNam: AnsiString;
  inrec: AnsiString;
Label
  GETNEXT, PROCDOC;

Begin
  spac1000 := AnsiString(stringofchar(' ', 1000));
  InptFNam := workdir + 'WORKFCFS.txt';
  // in a few odd cases, the WORKFCFS may have been renamed to _ORIG without another WORKFCFS being created to take it's place, so...
  if not FileExists(workdir + 'WORKFCFS.txt') Then
    InptFNam := workdir + 'WORKFCFS_ORIG.txt';
  //
  readcnt := 0;
  convtcnt := 0;
  TOPN := '';
  DOCPATH := '';
  INPATH := '';
  LASTKEY := '';
  DocNam := '';
  filenm := '';
  //
  QP := tDebenuPDFLibrary.Create;
  QP.UnlockKey('jm7ci9co4a43jx53o5co5nb7y');
  QP.SetOrigin(1);
  //
  AssignFile(WORKIN, InptFNam);                                                 // data that still remains in WORKFCFS tells us which PDFs to move
  Reset(WORKIN);
  //
  log.Logit('For non-auto-handled LNAPLOT docs: moving them to Lic index queues now');
  lStatus.Caption :=
    'Moving non-automated LNAPLOT pdfs to Licensing index folders now';
  Application.ProcessMessages;
  //
  While Not Eof(WORKIN) Do
  Begin
    ReadLn(WORKIN, inrec);
    readcnt := readcnt + 1;
    //
    if LASTKEY = Copy(inrec, 10, 19) then
      goto GETNEXT;                                             // if curr rec is for same key as last rec, branch
    //
    // okay, now convert and move the pdf file - and then delete the source pdf
    //
    DocNam := Copy(inrec, 10, 19);                              // shows "most" of the pdf filename [a one-byte value is appended, below]
    TOPN := Copy(inrec, 5, 4);                                  // target participant [is either 7797/penn or 7976/banner]
    //
    //
    // MAY 2022 MODIFICATION: NEW INPUTS PASSED IN TO THIS SUBROUTINE WILL BE COMPANY AND MDBCPARMEXISTS (which
    // indicates whether there was an execution parameter for this run saying we should move only the docs
    // that go with COMPANY that we are currently running this job for).  WITH THESE ADDITIONAL PARAMETERS,
    // WE CAN LIMIT "WHICH" DOCS ARE TO GET MOVED TO THE LICENSING ALI INDEXING QUEUE VIA THIS SUBROUTINE AND JOB.
    //
    // So, here is the modification logic: Check to see if mdbcparmexists is "Y" (it is set to Y if user provided an exec parm
    // of "/movedocsbyco") - and if so, then check to see if the current input record has a TOPN value (7977 is penn, 7976 is
    // Banner) that matches whatever company we are running the job for. If so, then it is ok to process the current record...
    // and move the related LNAPLOT doc to Lic indexing queue... BUT - if it does not match to that company code, then simply
    // skip past this input record (and dont attempt to move the related LNAPLOT doc). NOTE: if mdbcparmexists = "N", then
    // move ALL the leftover LNAPLOT docs to proper licensing queues - regardless of which company they are for.
    //
    if MDBCPARMEXISTS = 'N' then GOTO PROCDOC;                  // if "movedocsbyco" exec parm not provided, process all remaining recds
    //
    if (COMPANY = '17') and (TOPN = '7976') then
      GOTO PROCDOC;                                             // movedocsbyco was provided - so, see if company matches... and process if so
    if (COMPANY = 'WP') and (TOPN = '7977') then
      GOTO PROCDOC;                                             // movedocsbyco was provided - so, see if company matches... and process if so
    //
    GOTO GETNEXT;                                               // movedocsbyco was provided - but company doesn't match this recd... so, skip this recd
    //
   PROCDOC:
    //
    Case StrToInt(TOPN) Of                                      // set FROM and TO conversion paths based on recipient company [participant num]
      7976:
        DOCPATH := LGAIni.ReadString('Banner', 'Agentimagearea', '') +
          'packageinDTCC\';
      7977:
        DOCPATH := LGAIni.ReadString('Penn', 'Agentimagearea', '') +
          'packageinDTCC\';
    End;
    //
    Case StrToInt(TOPN) Of
      7976:
        INPATH := LGAIni.ReadString('Banner', 'Agentimagearea', '') +
          'packageinDTCChold\';
      7977:
        INPATH := LGAIni.ReadString('Penn', 'Agentimagearea', '') +
          'packageinDTCChold\';
    End;
    //
    If findcmdlineswitch('MASS') Then
    begin
      Case StrToInt(TOPN) Of
        7976:
          INPATH := LGAIni.ReadString('Banner', 'Agentimagearea', '') +
            'packageinDTCCmass\';
        7977:
          INPATH := LGAIni.ReadString('Penn', 'Agentimagearea', '') +
            'packageinDTCCmass\';
      End;
    end;
    //
    If findcmdlineswitch('MASS1') Then
    begin
      Case StrToInt(TOPN) Of
        7976:
          INPATH := LGAIni.ReadString('Banner', 'Agentimagearea', '') +
            'packageinDTCCmass1\';
        7977:
          INPATH := LGAIni.ReadString('Penn', 'Agentimagearea', '') +
            'packageinDTCCmass1\';
      End;
    end;
    //
    If findcmdlineswitch('MASS2') Then
    begin
      Case StrToInt(TOPN) Of
        7976:
          INPATH := LGAIni.ReadString('Banner', 'Agentimagearea', '') +
            'packageinDTCCmass2\';
        7977:
          INPATH := LGAIni.ReadString('Penn', 'Agentimagearea', '') +
            'packageinDTCCmass2\';
      End;
    end;
    //
    filenm := DocNam + '1.pdf';
    if not FileExists(INPATH + filenm) then
      filenm := DocNam + '2.pdf';
    Result := QP.LoadFromFile(INPATH + filenm, EmptyStr);
    //
    if Result <> 1 then
    begin
      Log.LogIt('Looked in ' + INPATH + '...');
      log.LogIt(' and file ' + DocNam + ' could not be loaded.');
      lStatus.Caption := 'File ' + DocNam + ' could not be loaded.';
      Application.ProcessMessages;
      goto GETNEXT;
    end;
    //
    convtcnt := convtcnt + 1; // bump counter of docs converted and moved
    //
    // use debenu to convert to TIF - saving the result into the licensing index queue
    //
    tfilenm := DOCPATH + Copy(filenm, 1, Length(filenm) - 4) + '.tif';          // set filename, including path
    I := QP.PageCount; // set page count for the Debenu call
    I := QP.RenderAsMultipageTIFFToFile(200, '1-' + IntToStr(I), 1, 0, tfilenm);
    //
    DeleteFile(INPATH + filenm);                                                // the orginal PDF of this doc is no longer needed, so delete it                                                          // delete the source PDF now
    //
    Log.LogIt('moving TIF version of ' + filenm + ' to ' + TOPN +
      ' indexing queue');
    lStatus.Caption := 'moved TIF version of ' + filenm + ' to ' + TOPN +
      ' indexing queue';
    Application.ProcessMessages;
    //
  GETNEXT:
    LASTKEY := Copy(inrec, 10, 19);                                             // update last-seen key value
  End;
  //
  CloseFile(WORKIN);
  //
  Log.LogIt('Finished moving ' + IntToStr(convtcnt) +
    ' docs to Licensing index queues');
  lStatus.Caption := 'Have moved ' + IntToStr(convtcnt) +
    ' docs to Licensing index queues';
  Application.ProcessMessages;
End;




// ==============================================================================
// set the next FAKEY and FAVALUE to work with
// (to check resulting "First Agent Number" for agent adds which should be numerically in-sync across affected hierarchies)
// ==============================================================================
Procedure TForm1.SETFA(Var FAKEY: AnsiString; Var FAVALU: AnsiString;
  Var X: Integer; CONST AIFATSL: TStringList);

Var
  THISKEY: AnsiString;
  THISVALU: AnsiString;
  workTSL: TStringList;
  Y: Integer;
Label
  EXITNOW;

Begin

  if X >= AIFATSL.Count then
    goto EXITNOW;

  For Y := X to AIFATSL.Count - 1 do

  begin

    workTSL := TStringList.Create;
    workTSL.text := StringReplace(AIFATSL[Y], '/', #10, [rfReplaceAll]);        // split the data into key and value
    //
    THISKEY := workTSL[1] + '/' + workTSL[2] + '/' + workTSL[3] + '/' +
      workTSL[4];
    THISVALU := workTSL[5];
    //
    workTSL.Free;
    //
    if FAKEY <> THISKEY then
    begin
      FAKEY := THISKEY;
      FAVALU := THISVALU;
      break;
    end;
  end;

  X := Y;

EXITNOW:

End;





// ==============================================================================
// procedure LoadDataBase connects this program to Admin System data - so that
// this program will be able to consider that policy or agent data in it's work
// ==============================================================================
Procedure TForm1.LoadDatabase;
Begin
  Try
    Log.LogIt('attempting to connect to LifePRO, now');
//    Lpro := tLifepro.Create();                              This was commented out on 7/7 along with an LPRO line near top of this program (Performance Mods)
    Lpro.OpenDataBases(DataAreaUNC, ReadOnly);
  Except
    On E: Exception Do
    Begin
      Log.LogIt('cannot reach LifePRO database, RESOLVE WITH ONCALL BEFORE CONTINUING!');
      ShowMessage('cannot reach LifePRO database, RESOLVE WITH ONCALL BEFORE CONTINUING!');
    End;
  End;
End;


// ==============================================================================
// procedure CreateL picks up the useful data bits regarding State Licenses
// [which came from the DTCC LNA data] so that those bits can be placed into
// the Change Packet "S" records for this LNA data event.  The data is plucked
// from a TstringList - and the consumed TstringList entries will be cleared
// by the calling routine.
// ==============================================================================
Procedure TForm1.CreateL(Var licenseTSL: TStringList; Var PREC_LIC: AnsiString;
  Var L: Integer);

Var
  spac1000: AnsiString;
  Lappendage: AnsiString;
  THISSTATE: AnsiString;
  M: Integer;
  X: Integer;
Label
  EXITNOW;
Begin
  spac1000 := AnsiString(stringofchar(' ', 1000));
  Lappendage := '';
  //
  THISSTATE := Copy(licenseTSL[L + 1], 6, 2);                                   // capture license state we are currently working on  (max of 8 types of S recds could exist)
  //
  M := L + 2;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 3;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 4;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 5;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 6;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 7;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 8;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
  M := L + 9;
  if M > 99 then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) = Copy(spac1000, 1, 2) then
    GOTO EXITNOW;
  if Copy(licenseTSL[M], 6, 2) <> THISSTATE then
    GOTO EXITNOW;
  Lappendage := Lappendage + Copy(licenseTSL[M], 56, 5);
  //
EXITNOW:
  PREC_LIC := licenseTSL[0] + licenseTSL[L + 1] + Lappendage;
  PREC_LIC := PREC_LIC + Copy(spac1000, 1, 1000 - (Length(PREC_LIC)));
  //
  M := M - 1;                                                                   // now, clear the just-used entries from the work array
  for X := L TO M Do
  Begin
    if X > 0 then
      licenseTSL[X] := Copy(spac1000, 1, 154);
  End;
  L := M;
End;



// ==============================================================================
// procedure DoAgtNum develops a "suggested agent number" to use for this AI trxn,
// and then saves that into whatever SQL table that this Automation Request said to.
// ==============================================================================
Procedure TForm1.DoAgtNum(Var DAN_RC: Integer; Var PREC_AGT: AnsiString;
  Var post: AnsiString; Const pre: AnsiString; Const lo: AnsiString;
  Const cla: AnsiString; Const currCO: AnsiString; Const maxagtn: AnsiString;
  Const SQLupdTN: AnsiString; Const AR_OBARID: AnsiString;
  Const CurDt: AnsiString);

Var
  query: tADOQuery;
  postn: Integer;
  zros10: AnsiString;
  fagnt: Integer;
  PN: AnsiString;
  ACTUALPN: AnsiString;
  //
Label
  NEXTANO1, ANDONE;
Begin
  //
  zros10 := '0000000000';
  DAN_RC := 0; // pre-set return code to zero
  fagnt := Lpro.Files.FindFile('FAGNTMST.DAT', True);                           // set file number of the agent master file
  //
  PN := Copy(PREC_AGT, 1, 4);                                                   // dtcc participant num from the LNA event
  ACTUALPN := PN;
  if (PN = 'MS  ') or (PN = 'SB  ') then
    ACTUALPN := '0015';                                                         // dtcc-registered pn is 0015 for these
  //
NEXTANO1:
  postn := StrToInt(post) + 1;                                                  // set numeric value/portion of the next sought agent number
  post := IntToStr(postn);                                                      // turn the incremented post value back into a string
  post := Copy(zros10 + post, Length(zros10) + Length(post) - Length(maxagtn) + 1, Length(maxagtn));
  //
  if post = maxagtn then
  begin
    DAN_RC := 2;                                                                // let invoker know that we hit max agt num avail and could not continue
    GOTO ANDONE; // exit now
  end;
  //
  Log.LogIt('will now see if this agt num is okay to use:' + pre + post);
  Application.ProcessMessages;
  // FillChar(srchagnt, SizeOf(srchagnt), #00);
  Lpro.Files.SetKey(fagnt, 0);
  StoA(Copy(currCO, 1, 2), srchagnt.company_code);
  //
  StrToArray(Copy(pre, 1, Length(pre)) + post, srchagnt.agent_number);
  Lpro.Files.DoBtrieve(fagnt, b_get_equal, srchagnt);
  //
  If Lpro.Files.getstatus(fagnt) = 0 Then
    GOTO NEXTANO1;                                                              // if this agt num alrdy used, try next
  //
  // OKAY, We have found a suggested agent number to use for this AI event, so save that as a row into SQL table
  //
  //LB1840B - START
  Log.LogIt('USING THIS AGENT NUMBER: ' + pre + post);
  Application.ProcessMessages;
  //LB1840B - END
  query := tADOQuery.Create(self);
  //
  Try
    query.Connection := BannerData;
    query.Connection.ConnectionString := uLGAini.SQLDataConnectionString;
    query.Connection.Connected := True;
    //
    query.SQL.Add('Insert into ' + SQLupdTN);
    //
    query.SQL.Add
      ('([PACKETID], [CYCLEDATE], [AGENTSSN], [AGENTNPN], [FROMPN],');
    query.SQL.Add(' [FROMACTUALPN], [AGENTNUMBERLEFT], [AGENTNUMBERSEQUENCE],');
    query.SQL.Add(' [CLASSIFICATION], [LEADORG])');
    //
    query.SQL.Add
      (' Values (:PACKETID, :CYCLEDATE, :AGENTSSN, :AGENTNPN, :FROMPN,');
    query.SQL.Add(' :FROMACTUALPN, :AGENTNUMBERLEFT, :AGENTNUMBERSEQUENCE,');
    query.SQL.Add(' :CLASSIFICATION, :LEADORG)');
    //
    query.Parameters.ParamByName('PACKETID').VALUE := AR_OBARID;
    query.Parameters.ParamByName('CYCLEDATE').VALUE := CurDt;
    query.Parameters.ParamByName('AGENTSSN').VALUE := Copy(PREC_AGT, 109, 9);
    query.Parameters.ParamByName('AGENTNPN').VALUE := Copy(PREC_AGT, 142, 10);
    query.Parameters.ParamByName('FROMPN').VALUE := PN;
    query.Parameters.ParamByName('FROMACTUALPN').VALUE := ACTUALPN;
    query.Parameters.ParamByName('AGENTNUMBERLEFT').VALUE := pre;
    query.Parameters.ParamByName('AGENTNUMBERSEQUENCE').VALUE := post;
    query.Parameters.ParamByName('CLASSIFICATION').VALUE := cla;
    query.Parameters.ParamByName('LEADORG').VALUE := lo;
    //

    try                                                                         // catch any failure when Insert is tried
      query.ExecSQL;
    except
      DAN_RC := 3;
    end;

    //
  Finally
    query.Connection.close();
    Freeandnil(query);
  End;
ANDONE:
End;



// ==============================================================================
// procedure ChPk2AI handles process for LNA "AI" events.  It takes in RAW packet data
// [which was gathered and working txt file by ChPk1 routine] and organizes the data
// such that there is exactly ONE "F" record and one-S-record-per-impacted-State
// for any "S" records.  Resulting data is then ready for a subsequent program
// to process.  In that subsequent process, we'll programattically update the Admin
// System [do whatever automation is needed to accomplish each LNA data event].
// ==============================================================================
Procedure TForm1.ChPk2AI(Var CP2_RC: Integer; Var HeadRecScnt: Integer;
  Var HeadRecFcnt: Integer; Var PFileName: AnsiString; Var PLogMsg: AnsiString;
  Var FANSugg: AnsiString; Const HeadRecB: AnsiString;
  Const AR_OBARID: AnsiString; Const PCRTSL: TStringList;
  Const workdir: AnsiString; Const CurDt: AnsiString);

Var
  DAN_RC: Integer;                                                              //  return code field which is to be set by the call to procedure DoAgtNum
  WORKPCKT: TextFile;
  PACKET: TextFile;
  licenseTSL: TStringList;
  PREC_AGT: AnsiString;
  PREC_LIC: AnsiString;
  spac1000: AnsiString;
  svAgentEmail: AnsiString;
  svAgentRSAddr: AnsiString;
  svAgentBPhn: AnsiString;
  inrec: AnsiString;
  currKEY: AnsiString;
  currCO: AnsiString;
  LASTKEY: AnsiString;
  blanks154: AnsiString;
  zros10: AnsiString;
  strCount: AnsiString;
  Lcount: Integer;
  MyNID: Integer;
  MyNIDstr: AnsiString;
  CPRawFcnt: Integer;
  CPRawScnt: Integer;
  N: Integer;
  L: Integer;
  R: Integer;
  lvAgents: TListView;
  MySSN: AnsiString;
  NameList: TNameList;
  DOINGAN: AnsiString;                                                          // switch for whether DataArranger should bother with agent number preassignment
  fagnt: Integer;
  postn: Integer;
  rbytes: AnsiString;
  maxagtn: AnsiString;
  post: AnsiString;
  pre: AnsiString;
  cla: AnsiString;
  lo: AnsiString;
  SQLupdTN: AnsiString;
  //
Label
  ENDOFCP2, SKIPAN1, SKIPAN2, SKIPAN3, NEXTANO1, NEXTANO2, BUILDMOR, NEXTRECD,
  MOREL1, MOREL2, HANDLST;
Begin
  // ===============================
  // initialize a bunch of stuff
  // ===============================
  LASTKEY := '';
  //
  CP2_RC := 0;                                                                  // pre-set this routine's return code to zero
  //
  fagnt := Lpro.Files.FindFile('FAGNTMST.DAT', True);                           // set file number of the agent master file
  //
  DOINGAN := 'Y';                                                               // default this to "yes, this pgm will determine agt nums"
  //
  SetViaPCR(PCRTSL, 'FIRSTAGENTNUM', post);
  If IsStrANumber(post) = False Then
    DOINGAN := 'N';
  //
  SetViaPCR(PCRTSL, 'SQLUPDT', SQLupdTN);                                       // SQL table name this pgm should wrt suggested agt numbers to
  //
  SetViaPCR(PCRTSL, 'RIGHTBYTES', rbytes);
  if rbytes = '' then
    DOINGAN := 'N';
  //
  SetViaPCR(PCRTSL, 'CLASSIFICATION', cla);                                     // set field cla to whatever is in PCR field CLASSIFICATION
  //
  SetViaPCR(PCRTSL, 'LEADORG', lo);                                             // set field lo to whatever is in PCR field LEADORG
  //
  if DOINGAN = 'N' then
  begin
    lStatus.Caption := 'for Packet ' + AR_OBARID +
      ', DA is not setting Agt Nums';
    Log.LogIt('for packet ' + AR_OBARID +
      ': DataArranger is not preassigning agt nums');
    Application.ProcessMessages;
  end
  else
  begin
    R := StrToInt(rbytes);                                                      // indicates length in bytes of numeric part of agent number
    maxagtn := AnsiString(stringofchar('9', R));                                // string version of longest available 'numeric' part of agt num
    postn := StrToInt(post);                                                    // make numeric version of field 'post'
    if postn < 1 then
      postn := 1;                                                               // normalize field 'post'
    postn := postn - 1;                                                         // subtract 1 [because just before search in LP, we add 1)
    post := IntToStr(postn);                                                    // turn the updated post back into a string
    post := Copy(zros10 + post, Length(zros10) + Length(post) - R - 1, R);      // set post to num part of next sought agt num
    BannerData := TADOConnection.Create(Nil);                                   // create base connection - to reach BannerData or PennData
  end;
  //
  currCO := '';
  zros10 := '0000000000';
  blanks154 := AnsiString(stringofchar(' ', 154));
  licenseTSL := tStringList.Create;                                             // each entry in this work array is to be 154 bytes in length
  for N := 0 to 99 Do
  begin
    licenseTSL.Add(blanks154);                                                  // initialize the license work array now
  end;
  //
  spac1000 := AnsiString(stringofchar(' ', 1000));
  svAgentEmail := copy(spac1000, 1, 60);                                        // save agent email addr is 60 bytes
  svAgentRSAddr := copy(spac1000, 1, 150);                                      // save residence addr is 150 bytes
  svAgentBPhn := copy(spac1000, 1, 10);                                         // save agent business phn# is 10 bytes
  PREC_AGT := spac1000;
  //
  CPRawFcnt := HeadRecFcnt;     // save the number of Raw F records that went into the building of this packet
  CPRawScnt := HeadRecScnt;     // save the number of Raw S records that went into building this packet
  HeadRecFcnt := 0;             // re-init this F counter [will use it again in next routine]
  HeadRecScnt := 0;             // re-init this S counter [will use it again in next routine]
  //
  // ===============================
  // get files ready
  // ===============================
  PFileName := '_' + AR_OBARID + '_' + 'PACKET' + '_' + CurDt + '.txt';
  If FileExists(workdir + PFileName) Then
    DeleteFile(workdir + PFileName);                 // delete packet file if present
  //
  AssignFile(WORKPCKT, workdir + 'WORKPCKT.txt');    //  LNA data change requests captured for use in this packet
  Reset(WORKPCKT);
  AssignFile(PACKET, workdir + PFileName);           //  this is Packet file... will be used by the pgm that updts LP
  ReWrite(PACKET);
  //
  // Now, process every record from the RAW packet
  //
  While Not Eof(WORKPCKT) Do
  Begin
    ReadLn(WORKPCKT, inrec);                          // get next record from incoming raw packet data
    //
    currKEY := Copy(inrec, 10, 19);
    if LASTKEY = currKEY then
      GOTO BUILDMOR;                                  // if it is for same rec set as alrdy working on, branch
    //
    currCO := '17';
    if Copy(inrec, 5, 4) = '7977' then
      currCO := 'WP';                                 // set LifePRO company code that goes with this LNA event
    //
    if DOINGAN = 'Y' then
    begin
      SetViaPCR(PCRTSL, 'BANLEFT', pre);              // set left part of agent number here
      if currCO = 'WP' then
        SetViaPCR(PCRTSL, 'PENLEFT', pre);
    end;
    //
    // NOW, WRT ANY HELD TRX RECORD, AND THEN INIT THE WORK AREAS SO WE CAN GET GOING WITH THE NEWLY ARRIVED RECORD SET
    //
    if PREC_AGT <> Copy(spac1000, 1, length(PREC_AGT)) then     // if the Agent Add trx rec has data, write it out
     begin
      if svAgentBPhn <> copy(spac1000, 1, 10) then
       begin
        move (svAgentBPhn[1], PREC_AGT[534], 10);               // save off business phone number
       end;
      if svAgentEmail <> copy(spac1000, 1, 60) then
       begin
        move(svAgentEmail[1], PREC_AGT[556], 60);               // add in this extra data if we have it
       end;
      if svAgentRSAddr <> copy(spac1000, 1, 150) then
       begin
        move(svAgentRSAddr[1], PREC_AGT[645], 150);             // add in this extra data if we have it
       end;
      //
      //// DETERMINE WHETHER THIS 'new' AGENT MAY ALREADY HAVE A NAME RECD IN ADMIN SYS
      ////
      //MySSN := copy(PREC_AGT, 109, 9);                           // get the SSN value we'll need
      //NameList := TNameList.Create(Lpro);                        // prepare a "name list" area
      ////
      //try
      //    if NameList.FindSSN(MySSN) > 0 then                    // see if the sought SSN exists in Admin System
      //       Begin
      //        MyNID := tnameitem(NameList.items[0]).nameid;       // capture the pre-existing name-id
      //        MyNIDstr := IntToStr(MyNID);                        // make a 10-position STRING version of Name ID
      //        MyNIDstr := Copy(zros10 + MyNIDstr, Length(zros10) + Length(MyNIDstr) - 9, 10);
      //        move(MyNIDstr[1], PREC_AGT[29], Length(MyNIDstr));  // put the Name ID value into the outbound recd
      //        lStatus.Caption := 'For pckt ' + AR_OBARID + ', SSN ' + MySSN + ' has preexist N.ID of ' + MyNIDstr;
      //        Log.LogIt('For pckt ' + AR_OBARID + ', SSN ' + MySSN + ' has preexist N.ID of ' + MyNIDstr);
      //        Application.ProcessMessages;
      //        //
      //       End;
      //finally
      //  NameList.Free;
      //end;
      //
      // NOW - IF HAVE BEEN INSTRUCTED BY AR CONTROL SPRDSHT TO DO SO - WE SUGGEST AN AGT NUM TO USE
      //
      if DOINGAN = 'Y' then
      begin
        DAN_RC := 0;
        DoAgtNum(DAN_RC, PREC_AGT, post, pre, lo, cla, currCO, maxagtn,
          SQLupdTN, AR_OBARID, CurDt);
        if FANSugg = '' then
          FANSugg := post;
        //
        If DAN_RC = 2 then
        begin
          lStatus.Caption :=
            'MAX AGENT NUMBER REACHED FOR THIS PACKET/AGENCY - Packet Recd Key:' + currKEY;
          Log.LogIt('MAX AGENT NUM REACHED FOR PACKET/AGENCY');
          Log.LogIt(' Packet Record:' + Copy(PREC_AGT, 1, 175));
          Application.ProcessMessages;
          PLogMsg := '--- AI packet NOT completed due to max agt num being reached ---';
          CP2_RC := DAN_RC;
          CloseFile(WORKPCKT);
          GOTO ENDOFCP2;
        end;
        //
        If DAN_RC = 3 then
        begin
          lStatus.Caption := 'INSERT INTO SQL TABLE FAILED for Packet Recd Key:' + currKEY;
          Log.LogIt('INSERT INTO SQL TABLE FAILED');
          Log.LogIt(' Packet Record:' + Copy(PREC_AGT, 1, 175));
          Application.ProcessMessages;
          PLogMsg := '--- AI packet NOT completed due to SQL INSERT failure ---';
          CP2_RC := DAN_RC;
          CloseFile(WORKPCKT);
          GOTO ENDOFCP2;
        end;

      end;
      //
      PREC_AGT := AnsiString(Uppercase(PREC_AGT));             // ensure upper case
      WriteLn(PACKET, PREC_AGT);                               // write the agent (F) record
      HeadRecFcnt := HeadRecFcnt + 1;
      svAgentEmail := copy(spac1000, 1, 60);                   // re-init save agent email addr
      svAgentRSAddr := copy(spac1000, 1, 150);                 // re-init residence addr
      svAgentBPhn := copy(spac1000, 1, 10);                    // re-init bus phn num
      PREC_AGT := spac1000;                                    // re-init the agent record now that it has been written
      if licenseTSL[0] <> blanks154 then
      begin
        PREC_LIC := spac1000;
        L := 0;
      MOREL1:
        CreateL(licenseTSL, PREC_LIC, L);
        if Copy(PREC_LIC, 160, 10) <> Copy(spac1000, 1, 10) then
        begin
          PREC_LIC := AnsiString(Uppercase(PREC_LIC));         // ensure upper case
          WriteLn(PACKET, PREC_LIC);
          HeadRecScnt := HeadRecScnt + 1;
        end;
        PREC_LIC := spac1000;
        if (licenseTSL[L] <> Copy(spac1000, 1, 10)) and (L < 99) then
          GOTO MOREL1;
      end;
    end;
    for N := 0 to 99 Do
    begin
      licenseTSL[N] := blanks154;
    end;
  BUILDMOR:
    if Copy(inrec, 9, 1) = 'S' then
      GOTO HANDLST;                                             // if this is an "S" record, branch
    //
    // SAVE OFF A FIELD OR TWO FROM THIS "F" RECORD
    //
    if Copy(inrec, 364, 2) = 'BB' then
    begin
      PREC_AGT := inrec;
      GOTO NEXTRECD;
    end;
    if (Copy(inrec, 364, 1) = 'B') and (Copy(inrec, 638, 1) = '1') and
      (Copy(inrec, 556, 10) <> Copy(spac1000, 1, 10)) then
    begin
      svAgentEmail := Copy(inrec, 556, 60);
    end;
    if (Copy(inrec, 364, 2) = 'RS') and
      (Copy(inrec, 376, 10) <> Copy(spac1000, 1, 10)) then
    begin
      svAgentRSAddr := Copy(inrec, 376, 150);
    end;
    if (Copy(inrec, 554, 1) = 'B') and
      (Copy(inrec, 534, 10) <> Copy(spac1000, 1, 10)) then
    begin
      svAgentBPhn := Copy(inrec, 534, 10);
    end;
    //
    GOTO NEXTRECD;
    //
    // USE DATA FROM THIS "S" REC TO UPDATE THE licenseTSL [data in licenseTSL will be used later]
    //
  HANDLST:
    if Copy(inrec, 420, 1) = 'l' then                           // if this byte is a lower case L, make it an upper case L
      move(AnsiString(SysUtils.Uppercase(Copy(inrec, 420, 1)))[1],
        inrec[420], 1);
    if licenseTSL[0] = Copy(spac1000, 1, 154) then
    begin
      licenseTSL[0] := Copy(inrec, 1, 154);
      licenseTSL[1] := Copy(inrec, 364, 154);
      GOTO NEXTRECD;
    end;
    for N := 2 to 99 Do
    begin
      if licenseTSL[N] = Copy(spac1000, 1, 154) then
      begin
        licenseTSL[N] := Copy(inrec, 364, 154);
        break;
      end;
    end;
  NEXTRECD:
    LASTKEY := currKEY;                                          // update last seen key value now
  End;
  CloseFile(WORKPCKT);
  RenameFile(workdir + 'WORKPCKT.txt', workdir + '_' + AR_OBARID + '_' +
    'WORKPCKT' + '_' + CurDt + '.txt');
  //
  // REACHED END OF RAW PACKET INPUT FILE, BUT MAY HAVE RESIDUAL RECORD IN MEMORY THAT NEEDS WRITTEN
  //
  if PREC_AGT <> Copy(spac1000, 1, Length(PREC_AGT)) then        // if the main (Agent) trx record has data, write it out
   begin
    if svAgentBPhn <> Copy(spac1000, 1, 10) then
      move(svAgentBPhn[1], PREC_AGT[534], 10);                   // add in this extra data
    if svAgentEmail <> Copy(spac1000, 1, 60) then
      move(svAgentEmail[1], PREC_AGT[556], 60);
    if svAgentRSAddr <> Copy(spac1000, 1, 150) then
      move(svAgentRSAddr[1], PREC_AGT[645], 150);                // add in this extra data if we have it
    //
    /// / DETERMINE WHETHER THIS 'new' AGENT MAY ALREADY HAVE A NAME RECD IN ADMIN SYS
    /// /
    // NameList := TNameList.Create(Lpro);                       // prepare a "name list" area
    // MySSN := copy(PREC_AGT, 109, 9);                          // get the SSN value we'll need
    // try
    // if NameList.FindSSN(MySSN) > 0 then                       // see if the sought SSN exists in Admin System
    // Begin
    // MyNID := tnameitem(NameList.items[0]).nameid;       // capture the pre-existing name-id
    // MyNIDstr := IntToStr(MyNID);                        // make a 10-position STRING version of Name ID
    // MyNIDstr := Copy(zros10 + MyNIDstr, Length(zros10) + Length(MyNIDstr) - 9, 10);
    // move(MyNIDstr[1], PREC_AGT[29], Length(MyNIDstr));  // put the Name ID value into the outbound recd
    // lStatus.Caption := 'For pckt ' + AR_OBARID + ', SSN ' + MySSN + ' has preexist N.ID of ' + MyNIDstr;
    // Log.LogIt('For pckt ' + AR_OBARID + ', SSN ' + MySSN + ' has preexist N.ID of ' + MyNIDstr);
    // Application.ProcessMessages;
    // //
    // End;
    // finally
    // NameList.Free;
    // end;
    //
    // IF INSTRUCTED TO DO SO BY Automation_Requests, SUGGEST AN AGENT NUM TO USE
    //
    if DOINGAN = 'Y' then
     begin
      DAN_RC := 0;
      DoAgtNum(DAN_RC, PREC_AGT, post, pre, lo, cla, currCO, maxagtn, SQLupdTN, AR_OBARID, CurDt);
      if FANSugg = '' then
        FANSugg := post;
      //
      If DAN_RC = 2 then
       begin
        lStatus.Caption := 'MAX AGENT NUMBER REACHED FOR THIS PACKET/AGENCY - Packet Recd Key:' + currKEY;
        Log.LogIt('MAX AGENT NUM REACHED FOR PACKET/AGENCY');
        Log.LogIt(' Packet Record:' + Copy(PREC_AGT, 1, 175));
        Application.ProcessMessages;
        PLogMsg := '--- AI packet NOT completed due to max agt num being reached --';
        CP2_RC := DAN_RC;
        CloseFile(WORKPCKT);
        GOTO ENDOFCP2;
       end;
      //
      If DAN_RC = 3 then
       begin
        lStatus.Caption := 'INSERT INTO SQL TABLE FAILED for Packet Recd Key:' + currKEY;
        Log.LogIt('INSERT INTO SQL TABLE FAILED');
        Log.LogIt(' Packet Record:' + Copy(PREC_AGT, 1, 175));
        Application.ProcessMessages;
        PLogMsg := '--- AI packet NOT completed due to SQL INSERT failure --';
        CP2_RC := DAN_RC;
        CloseFile(WORKPCKT);
        GOTO ENDOFCP2;
       end;

     end;
  //
  PREC_AGT := AnsiString(Uppercase(PREC_AGT));                   // ensure upper case
  WriteLn(PACKET, PREC_AGT);
  HeadRecFcnt := HeadRecFcnt + 1;
  //
  if licenseTSL[0] <> Copy(spac1000, 1, Length(licenseTSL[1])) then
    begin
      PREC_LIC := spac1000;
      L := 0;
    MOREL2:
      CreateL(licenseTSL, PREC_LIC, L);                          // use slot zero and some of the other slots to fill PREC_LIC
      if Copy(PREC_LIC, 160, 10) <> Copy(spac1000, 1, 10) then
      begin
        PREC_LIC := AnsiString(Uppercase(PREC_LIC));             // ensure upper case
        WriteLn(PACKET, PREC_LIC);
        HeadRecScnt := HeadRecScnt + 1;
      end;
      PREC_LIC := spac1000;
      if (licenseTSL[L] <> Copy(spac1000, 1, 10)) and (L < 99) then
        GOTO MOREL2;                                             // if more lic work to do, branch
    end;
  end;
  //
  strCount := IntToStr(CPRawFcnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter of raw F recds for this packet
  PLogMsg := PFileName + ':F=' + strCount + ';';                                  // begin build of the log message by adding filename and raw F count
  strCount := IntToStr(HeadRecFcnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter value
  PLogMsg := PLogMsg + strCount; // add in the Final count of F records now
  //
  strCount := IntToStr(CPRawScnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter of raw S recds for this packet
  PLogMsg := PLogMsg + ':S=' + strCount + ';';                                    // add in raw number of S records that went into this packet fil
  strCount := IntToStr(HeadRecScnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter value
  PLogMsg := PLogMsg + strCount + ':';                                            // add in the Final count of S records now
    //
  WriteLn(PACKET, (PLogMsg+HeadRecB));                                                // Write the footer record to the Packet file now
    //
 ENDOFCP2:
  CloseFile(PACKET);
  licenseTSL.Free;
End;



// ==============================================================================
// procedure ChPk2AA handles process for LNA "AA" events.  It takes in RAW packet data
// [which was gathered and working txt file by ChPk1 routine] and organizes the data
// such that there is exactly ONE "F" record and one-S-record-per-impacted-State
// for any "S" records.  Resulting data is then ready for a subsequent program
// to process.  In that subsequent process, we'll programattically update the Admin
// System [do whatever automation is needed to accomplish each LNA data event].
// ==============================================================================
Procedure TForm1.ChPk2AA(Var CP2_RC: Integer; Var HeadRecScnt: Integer;
  Var HeadRecFcnt: Integer; Var PFileName: AnsiString; Var PLogMsg: AnsiString;
  Const HeadRecB: AnsiString; Const AR_OBARID: AnsiString;
  Const PCRTSL: TStringList; Const workdir: AnsiString;
  Const CurDt: AnsiString);

Var
  DAN_RC: Integer;                                           //  return code field which is to be set by the call to procedure DoAgtNum
  WORKPCKT: TextFile;
  PACKET: TextFile;
  licenseTSL: TStringList;
  PREC_AGT: AnsiString;
  PREC_LIC: AnsiString;
  spac1000: AnsiString;
  svAgentEmail: AnsiString;
  svAgentRSAddr: AnsiString;
  svAgentBPhn: AnsiString;
  inrec: AnsiString;
  currKEY: AnsiString;
  currCO: AnsiString;
  LASTKEY: AnsiString;
  blanks154: AnsiString;
  zros10: AnsiString;
  strCount: AnsiString;
  Lcount: Integer;
  MyNID: Integer;
  MyNIDstr: AnsiString;
  CPRawFcnt: Integer;
  CPRawScnt: Integer;
  N: Integer;
  L: Integer;
  R: Integer;
  lvAgents: TListView;
  MySSN: AnsiString;
  NameList: TNameList;
  DOINGAN: AnsiString;                                       // says whether DataArranger should bother with agent number preassignment
  fagnt: Integer;
  postn: Integer;
  rbytes: AnsiString;
  maxagtn: AnsiString;
  post: AnsiString;
  pre: AnsiString;
  SQLupdTN: AnsiString;
  //
Label
  ENDOFCP2, SKIPAN1, SKIPAN2, SKIPAN3, NEXTANO1, NEXTANO2, BUILDMOR, NEXTRECD,
  MOREL1, MOREL2, HANDLST;
Begin
  // ===============================
  // initialize a bunch of stuff
  // ===============================
  LASTKEY := '';
  //
  CP2_RC := 0;                                         // pre-set this routine's return code to zero
  //
  fagnt := Lpro.Files.FindFile('FAGNTMST.DAT', True);  // set file number of the agent master file
  //
  DOINGAN := 'N';                                      // for AA, we wont be needing to access LP
  //
  currCO := '';
  zros10 := '0000000000';
  blanks154 := AnsiString(stringofchar(' ', 154));
  licenseTSL := TStringList.Create;                    // each entry in this work array is to be 154 bytes in length
  for N := 0 to 99 Do
  begin
    licenseTSL.Add(blanks154);                         // initialize the license work array now
  end;
  //
  spac1000 := AnsiString(stringofchar(' ', 1000));
  PREC_AGT := spac1000;
  //
  CPRawFcnt := HeadRecFcnt;     // save the number of Raw F records that went into the building of this packet
  CPRawScnt := HeadRecScnt;     // save the number of Raw S records that went into building this packet
  HeadRecFcnt := 0;             // re-init this F counter [will use it again in next routine]
  HeadRecScnt := 0;             // re-init this S counter [will use it again in next routine]
  //
  // ===============================
  // get files ready
  // ===============================
  PFileName := '_' + AR_OBARID + '_' + 'PACKET' + '_' + CurDt + '.txt';         // result packet name
  If FileExists(workdir + PFileName) Then
    DeleteFile(workdir + PFileName);                                            // delete packet file if present
  //
  AssignFile(WORKPCKT, workdir + 'WORKPCKT.txt');                               //  LNA data change requests captured for use in this packet
  Reset(WORKPCKT);
  AssignFile(PACKET, workdir + PFileName);                                      //  this is Packet file... will be used by the pgm that updts LP
  ReWrite(PACKET);
  //
  // Now, process every record from the RAW packet
  //
  While Not Eof(WORKPCKT) Do
  Begin
    ReadLn(WORKPCKT, inrec);                                                    // get next record from incoming raw packet data
    //
    currKEY := Copy(inrec, 10, 19);                                             // key for these purposes is the 19-byte PDF filename
    if LASTKEY = currKEY then
      GOTO BUILDMOR;                                                            // if it is for same rec set as alrdy working on, branch
    //
    currCO := '17';
    if Copy(inrec, 5, 4) = '7977' then
      currCO := 'WP';                                                           // set LifePRO company code that goes with this LNA event
    //
    // NOW, WRT ANY HELD TRX RECORD, AND THEN INIT THE WORK AREAS SO WE CAN GET GOING WITH THE NEWLY ARRIVED RECORD SET
    //
    if PREC_AGT <> Copy(spac1000, 1, Length(PREC_AGT)) then                     // if the Agent Add trx rec has data, write it out
    begin
      PREC_AGT := AnsiString(Uppercase(PREC_AGT)); // ensure upper case
      WriteLn(PACKET, PREC_AGT);                                                // write the agent (F) record
      HeadRecFcnt := HeadRecFcnt + 1;
      PREC_AGT := spac1000;                                                     // re-init the agent record now that it has been written
      if licenseTSL[0] <> blanks154 then
      begin
        PREC_LIC := spac1000;
        L := 0;
      MOREL1:
        CreateL(licenseTSL, PREC_LIC, L);
        if Copy(PREC_LIC, 160, 10) <> Copy(spac1000, 1, 10) then
        begin
          PREC_LIC := AnsiString(Uppercase(PREC_LIC));                          // ensure upper case
          WriteLn(PACKET, PREC_LIC);
          HeadRecScnt := HeadRecScnt + 1;
        end;
        PREC_LIC := spac1000;
        if (licenseTSL[L] <> Copy(spac1000, 1, 10)) and (L < 99) then
          GOTO MOREL1;
      end;
    end;
    for N := 0 to 99 Do
    begin
      licenseTSL[N] := blanks154;
    end;
    //
  BUILDMOR:
    if Copy(inrec, 9, 1) = 'S' then
      GOTO HANDLST;                                                             // if this is an "S" record, branch
    //
    // SAVE OFF A FIELD OR TWO FROM THIS "F" RECORD HERE, IF NEEDED
    //
    if Copy(inrec, 364, 2) = 'BB' then
    begin
      PREC_AGT := inrec;
      GOTO NEXTRECD;
    end;
    //
    // might be some buildmor stuff for AA-trxn FC records that should go here, gary  (for example, see AI para)
    //
    //
    GOTO NEXTRECD;
    //
    // USE DATA FROM THIS "S" REC TO UPDATE THE licenseTSL [data in licenseTSL will be used later]
    //
  HANDLST:
    if Copy(inrec, 420, 1) = 'l' then                                           // if this byte is a lower case L, make it an upper case L
      move(AnsiString(SysUtils.Uppercase(Copy(inrec, 420, 1)))[1],
        inrec[420], 1);
    if licenseTSL[0] = Copy(spac1000, 1, 154) then
    begin
      licenseTSL[0] := Copy(inrec, 1, 154);
      licenseTSL[1] := Copy(inrec, 364, 154);
      GOTO NEXTRECD;
    end;
    for N := 2 to 99 Do
    begin
      if licenseTSL[N] = Copy(spac1000, 1, 154) then
      begin
        licenseTSL[N] := Copy(inrec, 364, 154);
        break;
      end;
    end;
  NEXTRECD:
    LASTKEY := currKEY;                                                         // update last seen key value now
  End;
  CloseFile(WORKPCKT);
  RenameFile(workdir + 'WORKPCKT.txt', workdir + '_' + AR_OBARID + '_' +
    'WORKPCKT' + '_' + CurDt + '.txt');
  //
  // REACHED END OF RAW PACKET INPUT FILE, BUT MAY HAVE RESIDUAL RECORD IN MEMORY THAT NEEDS WRITTEN
  //
  if PREC_AGT <> Copy(Spac1000, 1, length(PREC_AGT)) then                       // if the main (Agent) trx record has data, write it out
    begin
    //
     PREC_AGT := AnsiString(Uppercase(PREC_AGT));                               // ensure upper case
     WriteLn(PACKET, PREC_AGT);
     HeadRecFcnt := HeadRecFcnt + 1;
    //
    if licenseTSL[0] <> Copy(spac1000, 1, Length(licenseTSL[1])) then
    begin
      PREC_LIC := spac1000;
      L := 0;
    MOREL2:
      CreateL(licenseTSL, PREC_LIC, L);                                         // use slot zero and some of the other slots to fill PREC_LIC
      if Copy(PREC_LIC, 160, 10) <> Copy(spac1000, 1, 10) then
      begin
        PREC_LIC := AnsiString(Uppercase(PREC_LIC));                            // ensure upper case
        WriteLn(PACKET, PREC_LIC);
        HeadRecScnt := HeadRecScnt + 1;
      end;
      PREC_LIC := spac1000;
      if (licenseTSL[L] <> Copy(spac1000, 1, 10)) and (L < 99) then
        GOTO MOREL2;                                                            // if more lic work to do, branch
    end;
  end;
  //
  strCount := IntToStr(CPRawFcnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter of raw F recds for this packet
  PLogMsg := PFileName + ':F=' + strCount + ';';                                  // begin build of the log message by adding filename and raw F count
  strCount := IntToStr(HeadRecFcnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter value
  PLogMsg := PLogMsg + strCount;                                                  // add in the Final count of F records now
  //
  strCount := IntToStr(CPRawScnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter of raw S recds for this packet
  PLogMsg := PLogMsg + ':S=' + strCount + ';';                                    // add in raw number of S records that went into this packet fil
  strCount := IntToStr(HeadRecScnt);
  strCount := Copy(zros10 + strCount, Length(zros10) + Length(strCount) - 9, 10); // set AnsiString version of the counter value
  PLogMsg := PLogMsg + strCount + ':';                                            // add in the Final count of S records now
  //
  WriteLn(PACKET, (PLogMsg+HeadRecB));                                            // Write the footer record to the Packet file now
  //
 ENDOFCP2:
  CloseFile(PACKET);
  licenseTSL.Free;
End;



// ==============================================================================
// procedure ChPk1 matches the remaining LNA data events for today to the given
// selected Automation Request.  For the input LNA events that match/go with this AR,
// we move those raw input records to a txt file - creating the raw data packet
// for this AR.  A subsequent routine is used to adjust this raw data some - so
// it is more usable by the NEXT program [the program that will update Admin system].
// ==============================================================================
Procedure TForm1.ChPk1(Var HeadRecScnt: Integer; Var HeadRecFcnt: Integer;
  Const HeadRecB: AnsiString; Const AR_OBARID: AnsiString;
  Const AR_OBROKA: AnsiString; Const AR_FROMPN: AnsiString;
  Const AR_TOPN: AnsiString; Const AR_TRXCD: AnsiString;
  Const AR_FIID: AnsiString; Const AR_RAWSR: AnsiString;
  Const PCRTSL: TStringList; Const workdir: AnsiString);

Var
  nowDropping: AnsiString;
  WORKIN: TextFile;
  WORKOUT: TextFile;
  WORKPCKT: TextFile;
  zros10: AnsiString;
  inrec: AnsiString;
  currFSkey: AnsiString;
  lastFSkey: AnsiString;
  writingKEY: AnsiString;
  THISKEY: AnsiString;
  currKEY: AnsiString;
  LASTKEY: AnsiString;
Label
  NOTANAI, WRTPCKT, RETAIN, NEXTRECD;
Begin
  zros10 := '0000000000';
  lastFSkey := ' ';
  LASTKEY := ' ';
  currFSkey := '   ';
  currKEY := ' ';
  nowDropping := 'N';
  THISKEY := 'Z';
  writingKEY := ' ';
  If FileExists(workdir + 'WORKTEMP.txt') Then
    DeleteFile(workdir + 'WORKTEMP.txt');                                       // delete work file if present
  If FileExists(workdir + 'WORKPCKT.txt') Then
    DeleteFile(workdir + 'WORKPCKT.txt');                                       // delete work file if present
  AssignFile(WORKIN, workdir + 'WORKFCFS.txt');                                 // LNA data change requests take the form of FC/FS records
  Reset(WORKIN);
  AssignFile(WORKOUT, workdir + 'WORKTEMP.txt');                    //  this version of the file will get only those data change events that are okay to be seen by some OTHER Automation Request after this current one
  ReWrite(WORKOUT);
  AssignFile(WORKPCKT, workdir + 'WORKPCKT.txt');                   //  this is the set of FC/FS data needed for the current Automation Request
  ReWrite(WORKPCKT);
  //
  While Not Eof(WORKIN) Do
  Begin
    ReadLn(WORKIN, inrec);                                         // get next record from LNA data change event file
    //
    if Copy(inrec, 49, 2) <> 'AI' then
      GOTO NOTANAI;                                                // xxx - originally put this in
    nowDropping := 'N';                                            // xxx - but ChPk1 may not need to be trxcode specific
    //
  NOTANAI:                                                         // xxx - so remove these lines if possible
    //
    currKEY := Copy(inrec, 10, 19);                                // key for these purposes is the 19-byte PDF filename
    if writingKEY = currKEY Then
      GOTO WRTPCKT;                                                // if key is one that we have decided we need, go write it
    if LASTKEY = currKEY then
      GOTO RETAIN;                                                 // if it is for a key we dont want, just go retain for next AR
    //
    // AT THIS POINT, WE NOW NEED TO DECIDE WHETHER THE CURRENT REC (AN F RECD) IS ONE THAT MATCHES CURRENT AR NEED
    //
    if AR_TRXCD <> Copy(inrec, 49, 2) then
      GOTO RETAIN;                                                 // if data event is not of our sought trx code, branch
    if AR_TOPN <> Copy(inrec, 5, 4) then
      GOTO RETAIN;                                                 // if event is not bound for proper receiver Particip Num, branch
    if (AR_FROMPN <> '****') and (AR_FROMPN <> Copy(inrec, 1, 4)) then
      GOTO RETAIN;                                                 // if not a match on sender, branch
    writingKEY := currKEY;                                         // we WANT this event for inclusion in this packet
  WRTPCKT:
    WriteLn(WORKPCKT, inrec);                                      // curr LNA data change event IS needed for this change packet
    if copy(inrec, 9, 1) = 'F' then                                // update the F countner or the S counter now
       HeadRecFcnt := HeadRecFcnt + 1
    else
      HeadRecScnt := HeadRecScnt + 1;
    if AR_OBROKA <> 'K' then
      GOTO NEXTRECD;                                               // if instructed to keep a yes-qualified data change, then keep it available for other packets
  RETAIN:
    WriteLn(WORKOUT, inrec);                                       // wrt curr d chg rec to the file that will be considered for upcoming ARs
  NEXTRECD:
    lastKEY := currKEY;                                            // update last seen key value now
  End;
  CloseFile(WORKIN);
  CloseFile(WORKOUT);
  CloseFile(WORKPCKT);
End;



// ==============================================================================
// procedure SetViaPCR sets the passed variable [third parameter] to the value
// specified via that PCR keyword - from the control AR spreadsheet.
// ==============================================================================
Procedure TForm1.SetViaPCR(Const PCRTSL: TStringList; Const RULE: AnsiString;
  Var VALUE: AnsiString);

Var
  splitarray: TStringList;
  Y: Integer;
Begin
  VALUE := '';
  For Y := 0 to PCRTSL.Count - 1 do
  Begin
    splitarray := TStringList.Create;
    splitarray.text := StringReplace(PCRTSL[Y], ':', #13#10, [rfReplaceAll]);
    if splitarray[0] = RULE then
    begin
      VALUE := splitarray[1];
      break;
    end;
  end;
  splitarray.Free;
end;



// ==============================================================================
// procedure PCRedit checks what is coded in the Process/Control Rule field
// in an Automation Request [a row from the input control spreadsheet].
// If a RuleID is encountered that is not understood, then we set PCRbadRule
// to indicate that the provided RuleID is bad. We also do SOME editing of the
// rule values [the field immediately RIGHT of the colon]... and if any rule
// value seems bad, we update PCRbadValue to indicate that the value is bad.
// ==============================================================================
Procedure TForm1.PCRedit(Var PCRTSL: TStringList; Var PCRbadRule: AnsiString;
  Var PCRbadValue: AnsiString);

Var
  zros10: AnsiString;
  J: Integer;
Begin
  zros10 := '0000000000';
  //
  PCRbadRule := ''; // initially, assume all is well with the provided RuleIDs
  PCRbadValue := '';                                                            // initially, assume all is well with the provided rule values
  //
  // build out the editing rules here when you have time
  //
End;



// ==============================================================================
// a file MOVE is done from workdir to target dir for all files that match the FNfilter passed in
// ==============================================================================
Procedure TForm1.Move2Bkup(CONST workdir: AnsiString;
  CONST FNpattern: AnsiString);

var
  BackupPath: AnsiString;
  FilesPDF: TStringDynArray;
  NewName, FName, FNameFull: String;

Begin
  BackupPath := workdir + 'DABKUP\';
  ForceDirectories(BackupPath);
  FilesPDF := tdirectory.GetFiles(workdir, FNpattern + '.txt');
  //
  For FNameFull in FilesPDF Do
  Begin
    FName := ExtractFileName(FNameFull);
    NewName := BackupPath + ExtractFileName(FNameFull);
    If TFile.Exists(NewName) then
      TFile.Delete(NewName);
    TFile.move(FNameFull, NewName);
  end;
  //
End;



// =========================================================================
// M A I N L I N E
// =========================================================================
Procedure TForm1.Button1Click(Sender: tObject);
Const
  UcaseAlpha = ['A' .. 'Z'];

Var
  ARFILE: TextFile;
  inrec: AnsiString;
  rc: Integer;
  N: Integer;
  CP2_RC: Integer;
  EM_RC: Integer;
  records: longint;
  MASSPARMEXISTS: AnsiString;
  TESTPARMEXISTS: AnsiString;
  MDBCPARMEXISTS: AnsiString;
  workTSL: TStringList;
  AIFATSL: TStringList;
  PCRTSL: TStringList;
  PCRbadRule: AnsiString;
  PCRbadValue: AnsiString;
  HeadRecB: AnsiString;                            // control (top) record info for this change packet
  HeadRecFcnt: Integer;                            // counter of F detail recds written to a packet file
  HeadRecScnt: Integer;                            // counter of S detail records written to a packet file
  PFileName: AnsiString;                           // name of the in-progress packet file
  PLogMsg: AnsiString;                             // log/summary rec for a packet build
  LAST_OBARID: AnsiString;
  ABORTMSG, AR_OBARID, AR_OBROKA, AR_FROMPN, AR_TOPN, AR_TRXCD, AR_FIID,
    AR_RAWSR, AR_PCR: AnsiString;
  InptFNam: AnsiString;
  spac4: AnsiString;
  spac6: AnsiString;
  spac50: ShortString;
  spac1000: AnsiString;
  SrtIFils, SrtOFil: AnsiString;
  CurDt: String;
  workdir: AnsiString;
  zros10: AnsiString;
  fileDate: Integer;
  CanCnt: Integer;
  FAX: Integer;
  mon: AnsiString;
  day: AnsiString;
  yyyy: AnsiString;
  FNpattern: AnsiString;
  currentDate: tDateTime;
  COMPANY: AnsiString;
  RBTS: AnsiString;
  FAN: AnsiString;
  FANSugg: AnsiString;
  LEADO: AnsiString;
  FAKEY: AnsiString;
  FAVALU: AnsiString;
  LASTFAKEY: AnsiString;
  currKEY, CURRVALU, CURROBAR, CURRLEADO: AnsiString;

Label
  SETNEXT, FINCHKLA, ARTRXOK, PCRTRXOK, LFDONE, FANLOK, GETNXTAR, ARABORT,
  EDITSOK, NEXTREC, NOTHEAD, NEXTONE, NOT07A;

Begin
  lStatus.Caption := 'LNA Automation Request Data Arranger has started';
  Application.ProcessMessages;
  LAST_OBARID := ' ';
  Button1.Enabled := False;

  zros10 := '0000000000';
  CanCnt := 0;

  spac4 := AnsiString(stringofchar(' ', 4));
  spac6 := AnsiString(stringofchar(' ', 6));
  spac50 := AnsiString(stringofchar(' ', 50));
  spac1000 := AnsiString(stringofchar(' ', 1000));
  //
  AIFATSL := TStringList.Create;
  //
  DateTimeToString(CurDt, 'yyyymmddhhnnsszz', Now);
  //
  // validate company (received via run parameter) - and then point to that LP region
  //
  ABORTMSG :=
    'Run parameter for COMPANY is missing (example /company=banner).  ABORTING NOW';
  COMPANY := '';
  If (findcmdlineswitch('company=banner') or findcmdlineswitch('Company=Banner')
    or findcmdlineswitch('COMPANY=BANNER')) Then
  begin
    COMPANY := '17'
  end;
  If (findcmdlineswitch('company=penn') or findcmdlineswitch('Company=Penn') or
    findcmdlineswitch('COMPANY=PENN')) Then
  begin
    COMPANY := 'WP'
  end;
  if COMPANY = '' then
  begin
    lStatus.Caption := ABORTMSG;
    Application.ProcessMessages;
    ShowMessage('JOB FAILED WHEN SETTING COMPANY VALUE - CALL SUPPORT');
    close;
    Halt(0);
  end;
  //
  if COMPANY = 'WP' then
    ChangeCompany('Penn');
  if COMPANY = '17' then
    ChangeCompany('Banner');
  //
  MASSPARMEXISTS := 'N';
  TESTPARMEXISTS := 'N';
  MDBCPARMEXISTS := 'N';
  //
  If findcmdlineswitch('MASS') Then
  begin
    workdir := WorkAreaUNC + 'MASS\';
    MASSPARMEXISTS := 'Y';
    Log := tAppLogFile.Create((WorkAreaUNC + 'MASS\Log\'), 'LNADA_' +
      ComputerName + '_' + FormatDateTime('yyyymmddhhnnss', Now), False);
    GOTO LFDONE;
  end;
  //
  If findcmdlineswitch('MASS1') Then
  begin
    workdir := WorkAreaUNC + 'MASS1\';
    MASSPARMEXISTS := 'Y';
    Log := tAppLogFile.Create((WorkAreaUNC + 'MASS1\Log\'), 'LNADA_' +
      ComputerName + '_' + FormatDateTime('yyyymmddhhnnss', Now), False);
    GOTO LFDONE;
  end;
  //
  If findcmdlineswitch('MASS2') Then
  begin
    workdir := WorkAreaUNC + 'MASS2\';
    MASSPARMEXISTS := 'Y';
    Log := tAppLogFile.Create((WorkAreaUNC + 'MASS2\Log\'), 'LNADA_' +
      ComputerName + '_' + FormatDateTime('yyyymmddhhnnss', Now), False);
    GOTO LFDONE;
  end;
  //
  workdir := WorkAreaUNC + 'DTCCFILES\LNA\';
  Log := tAppLogFile.Create((WorkAreaUNC + 'DtccFiles\Log\'), 'LNADA_' +
    ComputerName + '_' + FormatDateTime('yyyymmddhhnnss', Now), False);
  //
LFDONE:
  //
  //Log.CacheLog := True;
  //LB1840B - START
  Log.CacheLog := False;
  //LB1840B - END
  If findcmdlineswitch('test') Then
  begin
    TESTPARMEXISTS := 'Y';
    Log.LogIt('THIS IS A TEST RUN.');
  end;
  //
  If (findcmdlineswitch('movedocsbyco') or findcmdlineswitch('MOVEDOCSBYCO') or
    findcmdlineswitch('Movedocsbyco') or findcmdlineswitch('MoveDocsByCo')) Then
  begin
    MDBCPARMEXISTS := 'Y';
    Log.LogIt('PER EXEC PARMS, THIS RUN WILL MOVE NON-AUTOMATED LNAPLOT DOCS  O N L Y  FOR CO ' + COMPANY);
  end;
  //
  Log.LogIt('Begin Automation Request Data Arranger program.');
  //
  InptFNam := workdir + 'LNA_SEQ_FS.txt';                            // main input (data) files are the FC and FS files from LNAPLOT
  fileDate := FileAge(InptFNam);                                     // find last-changed date of this file
  if fileDate > -1 then                                              // if we got the file date okay, proceed to set CurDt based on that
  begin
    CurDt := datetostr(FileDateToDateTime(fileDate));
    workTSL := TStringList.Create;
    workTSL.text := StringReplace(CurDt, '/', #13#10, [rfReplaceAll]);   // Split the date value into it's sub-components (all are 'AnsiString' components)
    mon := workTSL[0];
    day := workTSL[1];
    yyyy := workTSL[2];
    if Length(mon) < 2 then
      mon := '0' + mon;
    if Length(day) < 2 then
      day := '0' + day;
    CurDt := yyyy + mon + day;
    workTSL.Free;
    Log.LogIt('Based on create date of LNA_SEQ_FS.txt, this run is for: ' + CurDt);
    lStatus.Caption := 'Based on LNA_SEQ_FS.txt file date, this run is for: ' + CurDt;
    Application.ProcessMessages;
  end
  else
  Begin
    Log.LogIt('RUN ABORT !  LNA_SEQ_FS.txt missing from ' + workdir);
    log.Free;
    lStatus.Caption := 'RUN HALTED.  LNA_SEQ_FS.txt is missing from ' + workdir;
    Application.ProcessMessages;
    close;
    Halt(0);
  End;
  //
  DateTimeToString(CurDt, 'yyyymmdd', Now);                        // okay - reset this to be in the format the rest of pgm needs
  //
  // SAVE OFF OLD FILES BEFORE WE MAKE SOME NEW ONES
  //
  Log.LogIt('Moving old files to backup: *_PACKET_*');
  lStatus.Caption := 'Moving old files to backup: *_PACKET_*';
  Application.ProcessMessages;
  FNpattern := '*_PACKET_*';
  Move2Bkup(workdir, FNpattern);                                   // do file MOVE for files that match this filename pattern
  //
  Log.LogIt('Moving old files to backup: *WORKPCKT*');
  lStatus.Caption := 'Moving old files to backup: *WORKPCKT*';
  Application.ProcessMessages;
  FNpattern := '*WORKPCKT*';
  Move2Bkup(workdir, FNpattern);                                  // do file MOVE for files that match this filename pattern
  //
  Log.LogIt('Moving old files to backup: *WORKFCFS*');
  lStatus.Caption := 'Moving old files to backup: *WORKFCFS*';
  Application.ProcessMessages;
  FNpattern := '*WORKFCFS*';
  Move2Bkup(workdir, FNpattern);                                  // do file MOVE for files that match this filename pattern
  //
  if FileExists(workdir + 'WORKTEMP.txt') then
    DeleteFile(workdir + 'WORKTEMP.txt');
  if FileExists(workdir + 'WORKFCFS_ORIG.txt') then
    DeleteFile(workdir + 'WORKFCFS_ORIG.txt');
  //
  // Here we sort/merge the FC and FS data together.
  // Result goes into "WORKFCFS" - which thereafter continually shrinks with each processed Automation Request.
  //
  SrtIFils := workdir + 'LNA_SEQ_FC.txt' + '+' + workdir + 'LNA_SEQ_FS.txt';         //FC and FS files to be sort/merged together
  SrtOFil := workdir + 'WORKFCFS.txt';                                               // SORT/MERGE OUTPUT
  OtSort(SrtIFils, SrtOFil, 's(1,8,C,A,10,41,C,A,9,1,C,A,364,56,C,A,420,2,C,D,364,1,C,A)', records, rc);
  //
  // OKAY, WE KNOW THE DATE OF OUR RUN AND WE HAVE CONFIRMED AVLBLTY OF THE FS AND FC FILES
  // NOW, WE WILL MATCH EACH OF THE AUTOMATION REQUESTS TO TODAYS LNA DATA, CREATING CHANGE PACKETS
  //
  Log.LogIt('Opening Automation_Requests.csv now ');
  lStatus.Caption := 'Opening Automation_Requests.csv now ';
  Application.ProcessMessages;
  AssignFile(ARFILE, workdir + 'AUTOMATION_REQUESTS.csv');         //  Automation Requests file has rules
  Reset(ARFILE);
  //
  While Not Eof(ARFILE) Do
  Begin
    Application.ProcessMessages;
    ReadLn(ARFILE, inrec);                                         // get next Automation Request record
    //
    If Copy(inrec, 1, 1) = '*' Then
      GOTO GETNXTAR;                                               // if col A indicates 'comment', just go get next record
    if Copy(inrec, 2, 1) <> ',' Then
      GOTO GETNXTAR;
    //
    // if col A is not exactly ONE byte, just go get next record
    //
    HeadRecB := inrec;                                        // initialize control record info for this change packet
    HeadRecFcnt := 0;                                         // initialize number of todays LNA primary ["F" recds] data events for this packet file to zero
    HeadRecScnt := 0;                                         // initialize number of todays LNA state ["S" recds] records this packet file to zero
    //
    workTSL := TStringList.Create;                                      //  use this string array to hold the separate (comma-separated) input rec values
    workTSL.Text := StringReplace(inrec, ',', #13#10, [rfReplaceAll]);  //  split the comma-separated input rec into fields
    //
    AR_OBARID := workTSL[0];                                 // get the one-byte Automation Request ID from the just-read AR input record
    AR_OBROKA := workTSL[1];                                 // the one-byte Remove or Keep-Available code
    // right here - replace any periods with zeros, instead...
    AR_FROMPN := AnsiReplaceStr(workTSL[2], '.', '0'); // in csv, leading zero in this field is entered as a period
    AR_TOPN  := workTSL[3];                                  // the 4-byte TO participant num (either 7977 for penn or 7976 for banner)
    AR_TRXCD := workTSL[4];                                  // the 2-byte LNA transaction code
    AR_FIID  := workTSL[5];                                  // the up-to-seven byte LGA Financial Institution ID
    AR_RAWSR := workTSL[6];                                  // the extra rule which is used during RAW selection [creation of raw/work packet]
    AR_PCR := workTSL[7];                                    // the Process/Control rule - indicates "how" to do something
    workTSL.Free;
    //
    // NOW, WE ARE GOING TO DO SOME EDITS TO FIND ANY SITUATION IN THIS AUTOMATION REQUEST THAT IS NOT SUPPORTED
    // Note: Editing of the automation requests occurs AS those requests are being processed.
    // That means that there is the possibility that a "good" Automation Request will have gone all
    // the way through - before we run into a Request row that fails the edits.
    // So, there is the chance that SOME "good" (complete) output change packets may
    // exist - even if/when the job abends due to a Request edit error.
    //
    //
    // edit the PCR [Process/Control rule]
    ABORTMSG := 'AR ' + AR_OBARID +
      ': AR PCR nonblank, but PCR usage only applies to AA or AI processing - ABORTING NOW';
    if (Length(AR_PCR) <> 0) and (AR_TRXCD = 'AA') then
      GOTO PCRTRXOK;
    if (Length(AR_PCR) <> 0) and (AR_TRXCD <> 'AI') then
      GOTO ARABORT;                                          // when PCR non-blank, the AR has to be for an "AI" or "AA" trx
  PCRTRXOK:
    //
    //
    PCRTSL := TStringList.Create;                            // this stringlist carries how-to info for this Automation Request
    PCRTSL.Text := StringReplace(AR_PCR, ';', #13#10, [rfReplaceAll]);
    PCRbadRule := '';                                        // indicate that the pre-colon Rule ids included are okay asis
    PCRbadValue := '';                                       // indicate that the post-colon value in ALL PCR parms are okay asis
    PCRedit(PCRTSL, PCRbadRule, PCRbadValue);                // PCRedit routine to examine/validate PCR encoding
    if (PCRbadRule <> '') or (PCRbadValue <> '') then
    begin
      ABORTMSG := 'AR ' + AR_OBARID +
        ' has bad Process/Control rule or rule value - ABORTING NOW';
      GOTO ARABORT;
    end;
    //
    //
    ABORTMSG := 'raw selection rule is not yet supported - ABORTING NOW';
    if Length(AR_RAWSR) <> 0 then
      GOTO ARABORT;
    //
    //
    ABORTMSG :=
      'Limiting by Financial Institution ID is not yet supported - ABORTING NOW';
    if Length(AR_FIID) <> 0 then
      GOTO ARABORT;
    //
    //
    ABORTMSG :=
      'the only LNA transaction types supported are AA and AI - ABORTING NOW';
    if AR_TRXCD = 'AA' then
      GOTO ARTRXOK;
    if AR_TRXCD <> 'AI' then
      GOTO ARABORT;
  ARTRXOK:
    //
    //
    ABORTMSG :=
      'the TO participant number must be 7977 (Penn) or 7976 (Banner) - ABORTING NOW';
    if (AR_TOPN <> '7976') and (AR_TOPN <> '7977') then
      GOTO ARABORT;
    //
    //
    ABORTMSG := 'Run parameter says to process for company ' + COMPANY +
      ', but AR found for non-matching Participant Number.  ABORTING NOW';
    if (AR_TOPN = '7976') and (COMPANY <> '17') then
      GOTO ARABORT;
    if (AR_TOPN = '7977') and (COMPANY <> 'WP') then
      GOTO ARABORT;
    //
    //
    ABORTMSG :=
      'only Automation Requests for Edward Jones are currently supported - ABORTING NOW';
    if (AR_FROMPN <> '****') and (AR_FROMPN <> '0057') then
      GOTO ARABORT;
    //
    //
    ABORTMSG :=
      'Only Remove-or-Keep codes of R or K are supported currently - ABORTING NOW';
    if (AR_OBROKA <> 'R') and (AR_OBROKA <> 'K') then
      GOTO ARABORT;
    //
    //
    ABORTMSG :=
      'AR ID must be a one-byte upper-case alpha.   It must be unique.  The rule ids must be used in order, alphabetically.  ABORTING NOW';
    if LAST_OBARID > AR_OBARID then
      GOTO ARABORT;
    if (AR_OBARID < 'A') or (AR_OBARID > 'Z') then
      GOTO ARABORT;
    //
    //
    if AR_TRXCD <> 'AI' then
      GOTO FANLOK;                                                 // the following edit applies to AI only
    ABORTMSG :=
      'Length of PCR field FIRSTAGENTNUM does not match value of PCR field field RIGHTBYTES.  ABORTING NOW';
    SetViaPCR(PCRTSL, 'FIRSTAGENTNUM', FAN);                       // set field FAN based on PCR value of FIRSTAGENTNUM
    SetViaPCR(PCRTSL, 'RIGHTBYTES', RBTS);                         // set RBTS to whatever value is in PCR field RIGHTBYTES
    If (IsStrANumber(FAN) = False) or (IsStrANumber(RBTS) = False) Then
      Goto FANLOK;
    if StrToInt(RBTS) <> Length(FAN) then
      GOTO ARABORT;
  FANLOK:
    //
    //
    GOTO EDITSOK;
    //
    //
  ARABORT:
    Log.LogIt(ABORTMSG);
    Log.LogIt('Automation Request record:' + inrec);
    log.Free;
    lStatus.Caption := ABORTMSG;
    Application.ProcessMessages;
    ShowMessage('JOB FAILED - CALL SUPPORT');
    close;
    Halt(0);
    //
  EDITSOK:
    LAST_OBARID := AR_OBARID;                                      //  Now, set the remembered ID value to be the value of the AR we are working on
    //
    // Here we match the current Automation Request to the (remaining) sort/merged FC/FS data (WORKFCFS).
    // There is a switch inside each Request record that lets us know whether an LNA DATA EVENT (from DTCC)
    // is to be retained (for possible inclusion in MULTIPLE change packets) - or whether  being
    // associated with a single change packet is sufficient for that DATA EVENT to STOP being considered
    // for inclusion in change packets at that point.  Normally, we expect an LNA data event to become
    // part of a MAX of one Change Packet.
    //
    Log.LogIt('Begin work on Packet Request ' + AR_OBARID +
      ', with AR: ' + inrec);
    lStatus.Caption := 'Processing Packet Request ' + AR_OBARID + ' now.';
    Application.ProcessMessages;
    //
    HeadRecFcnt := 0;                                              // this field shows num of F detail recds placed into the created Change Packet
    ChPk1(HeadRecScnt, HeadRecFcnt, HeadRecB, AR_OBARID, AR_OBROKA, AR_FROMPN,
      AR_TOPN, AR_TRXCD, AR_FIID, AR_RAWSR, PCRTSL, workdir);      // call subroutine
    //
    //
    if HeadRecFcnt > 0 then                                        // if ChPk1 accepted at least one F rec then... (1st step is save the ORIGINGAL version of WORKFCFS if not done yet)
    begin
      // if not FileExists(workdir + 'WORKFCFS_ORIG.txt') Then RenameFile(workdir + 'WORKFCFS.txt', workdir + 'WORKFCFS_ORIG.txt');
      PFileName := '';                                             // initialize output packet file name
      PLogMsg := '';                                               // initialize log message
      CP2_RC := 0;                                                 // pre-set the changepacket2 return code to zero
      //
      if AR_TRXCD = 'AI' then
      begin
        FANSugg := '';
        ChPk2AI(CP2_RC, HeadRecScnt, HeadRecFcnt, PFileName, PLogMsg, FANSugg,
          HeadRecB, AR_OBARID, PCRTSL, workdir, CurDt);             // if pckt has data, create adm sys trxn recds
        SetViaPCR(PCRTSL, 'LEADORG', LEADO);                        // set field LEADO to whatever is in PCR field LEADORG
        if LEADO <> '' then                                         // see if a Lead Org was specified for this packet
        begin
          CanCnt := CanCnt + 1;                                     // add 1 to the count of AI packets we will later verify F.A.N. for
          AIFATSL.Add(AR_OBARID + '/' + LEADO + '/' + AR_FROMPN + '/' + AR_TOPN + '/' + FAN + '/' + FANSugg);
        end;
      end;
      //
      if AR_TRXCD = 'AA' then
      begin
        ChPk2AA(CP2_RC, HeadRecScnt, HeadRecFcnt, PFileName, PLogMsg, HeadRecB, AR_OBARID, PCRTSL, workdir, CurDt);  // if pckt has data, create adm sys trxn recds
      end;
      //
      Log.LogIt(PLogMsg);
      Application.ProcessMessages;
      //
      if CP2_RC <> 0 then
      begin
        ABORTMSG := 'Subroutine failed - Aborting packet ' + AR_OBARID;
        Log.LogIt(' Packet ' + AR_OBARID + ' build has been ABORTED');
        Application.ProcessMessages;
        //
        if MASSPARMEXISTS = 'Y' then
         begin
          Log.LogIt('Non-cycle run of this program - so, aborting the overall job now');
          Log.LogIt(' Automation Request record:' + inrec);
          log.Free;
          lStatus.Caption := ABORTMSG;
          Application.ProcessMessages;
          ShowMessage('JOB FAILED - SUBROUTINE RETURN CODE IS ' + IntToStr(CP2_RC) + ' - CALL SUPPORT');
          close;
          Halt(0);
         end
        else
         begin
          Log.LogIt('In-cycle run - subroutine Return Code is:' + IntToStr(CP2_RC));
          Log.LogIt(' Sending email (if not a Test run) and will then try next packet.');
          Log.LogIt(' Automation Request record:' + Copy(inrec, 1, 175));
          EM_RC := 0;
          if TESTPARMEXISTS = 'N' then
           begin
            SendAbortPacketEmail(CurDt, AR_OBARID, PLogMsg, COMPANY, EM_RC);
           end
          else
           begin
            Log.LogIt(' TEST RUN - so aborted packet email not sent; Automation Request record:' + Copy(inrec, 1, 175));
           end;
         //
         if EM_RC > 0 then
           begin
            ABORTMSG := 'Email to notify about aborted packet has failed!';
            Log.LogIt(ABORTMSG);
            Log.LogIt(' Automation Request record:' + Copy(inrec, 1, 175));
            log.Free;
            lStatus.Caption := ABORTMSG;
            Application.ProcessMessages;
            ShowMessage ('UNABLE TO SEND PACKET ABORT EMAIL - SUBROUTINE RETURN CODE IS ' +
              IntToStr(EM_RC) + ' - CALL SUPPORT');
            close;
            Halt(0);
           end;
         end;
      end;
    end;
  //
  if FileExists(workdir + 'WORKTEMP.txt') then
    begin
     if not FileExists(workdir + 'WORKFCFS_ORIG.txt') Then
       RenameFile(workdir + 'WORKFCFS.txt', workdir + 'WORKFCFS_ORIG.txt');
     if FileExists(workdir + 'WORKFCFS.txt') then
       DeleteFile(workdir + 'WORKFCFS.txt');
     RenameFile(workdir + 'WORKTEMP.txt', workdir + 'WORKFCFS.txt');
    end;
  //
  GETNXTAR:

  End;

  //
  PCRTSL.Free;
  CloseFile(ARFILE);
  //
  // Now, see if we find a non-matching FANSugg (first agent number suggested) value - where AR keys (for AI) match
  //
  FAKEY := '';
  LASTFAKEY := '';
  FAX := 0;                                                        // x value used to control begin-looking point in the AIFATSL by SetFA routine

  if AIFATSL.Count < 2 then
    goto FINCHKLA;

 SETNEXT:
  SETFA(FAKEY, FAVALU, FAX, AIFATSL);                              // set FAKEY and FAVALU so we can check first-agent-number consistency across agent orgs
  if FAKEY = LASTFAKEY then
    goto FINCHKLA;                                                 // if search-for key came back unchanged, then we are done with this checking
  //
  for N := 0 to AIFATSL.Count - 1 Do
   begin
     //
     workTSL := TStringList.Create;
     workTSL.text := StringReplace(AIFATSL[N], '/', #10, [rfReplaceAll]);    // split the data into key and value
     //
     CURROBAR := workTSL[0];
     CURRLEADO := workTSL[1];
     currKEY := workTSL[1] + '/' + workTSL[2] + '/' + workTSL[3] + '/' + workTSL[4];
     CURRVALU := workTSL[5];
     //
     workTSL.Free;
     //
     if FAKEY = currKEY then
       begin
         if FAVALU <> CURRVALU then
           begin
             ABORTMSG := 'Packet ' + CURROBAR +
               ' must have same start agt num as other Packets for leadorg ' +
               CURRLEADO + ', but does not!';
           Log.LogIt(ABORTMSG);
           log.Free;
           lStatus.Caption := ABORTMSG;
           Application.ProcessMessages;
           ShowMessage('JOB FAILED - CALL SUPPORT');
           close;
           Halt(0);
           end;
       end;
       //
   end;

  LASTFAKEY := FAKEY;
  GOTO SETNEXT;

 FINCHKLA:

  //
  Lpro.Free;
  // if AR_TOPN = '7977' then ChangeCompany('Penn');        // should these 3 lines come out?
  // if AR_TOPN = '7976' then ChangeCompany('Banner');
  // LoadDatabase;
  //
  //
  Log.LogIt('Finished creating change packet files for all Automation Requests, now.');
  Application.ProcessMessages;
  //
  // FOR TODAYS LNA EVENTS THAT CANT BE HANDLED VIA AUTOMATION: MOVE THE CORRESP LNAPLOT PDF TO Lic doc queue
  // NOTE: when MASS or MASS1 or MASS2 exec parm is included, this pgm knows "this is not an LNA cycle that we are doing"
  //
  if MASSPARMEXISTS = 'N' then
     MoveDocs(COMPANY, MDBCPARMEXISTS, workdir);
  //
  Log.LogIt('LNADA has completed, now.');
  Application.ProcessMessages;
  //
  log.Free;
  close;
  //
End;



Procedure TForm1.FormCreate(Sender: tObject);
Begin
  LoadDatabase;                                            // access to Admin System data
End;



Procedure TForm1.FormClose(Sender: tObject; Var Action: TCloseAction);
Begin
  //Lpro.Free;                                             // decided to move this free to the mainline
End;



Procedure TForm1.FormShow(Sender: tObject);
Begin
  Button1.Enabled := True;
End;


End.

}}}PPRECON.dproj
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <ProjectGuid>{969C37D5-131B-4DAD-994F-453AF7587AFB}</ProjectGuid>
        <ProjectVersion>18.4</ProjectVersion>
        <FrameworkType>VCL</FrameworkType>
        <MainSource>PPRECON.dpr</MainSource>
        <Base>True</Base>
        <Config Condition="'$(Config)'==''">Debug</Config>
        <Platform Condition="'$(Platform)'==''">Win32</Platform>
        <TargetedPlatforms>1</TargetedPlatforms>
        <AppType>Application</AppType>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Base)'=='true') or '$(Base_Win32)'!=''">
        <Base_Win32>true</Base_Win32>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''">
        <Base_Win64>true</Base_Win64>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_1)'!=''">
        <Cfg_1>true</Cfg_1>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''">
        <Cfg_1_Win32>true</Cfg_1_Win32>
        <CfgParent>Cfg_1</CfgParent>
        <Cfg_1>true</Cfg_1>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_2)'!=''">
        <Cfg_2>true</Cfg_2>
        <CfgParent>Base</CfgParent>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''">
        <Cfg_2_Win32>true</Cfg_2_Win32>
        <CfgParent>Cfg_2</CfgParent>
        <Cfg_2>true</Cfg_2>
        <Base>true</Base>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base)'!=''">
        <DCC_DcuOutput>dcuout</DCC_DcuOutput>
        <DCC_ExeOutput>exe</DCC_ExeOutput>
        <DCC_UsePackage>vcl;rtl;vclx;indy;vclie;xmlrtl;inetdbbde;inet;inetdbxpress;dbrtl;soaprtl;dsnap;VclSmp;dbexpress;vcldb;dbxcds;inetdb;bdertl;vcldbx;adortl;ibxpress;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOfficeXP;ILCORP50;addict3_d7;addict3db_d7;AUSComponents;PKBOOKMARK;PTCommon;ptEtsPanel;LproComponents;PTZipCodeCityState;Tee97;TeeUI97;TeeDB97;TeePro97;TeeGL97;TeeImage97;TeeLanguage97;TeeWorld97;FlexCel_Report;RESTBackendComponents;CloudService;FlexCel_XlsAdapter;soaprtl;soapmidas;RESTComponents;FlexCel_Pdf;FireDACIBDriver;FireDACCommon;soapserver;FireDACCommonDriver;inet;FireDAC;FireDACSqliteDriver;FlexCel_Core;FlexCel_Render;$(DCC_UsePackage)</DCC_UsePackage>
        <DCC_Namespace>Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;System;Xml;Data;Datasnap;Web;Soap;Winapi;Data.Win;Xml.Win;System.Win;Datasnap.Win;Web.Win;Soap.Win;Bde;VCLTee;$(DCC_Namespace)</DCC_Namespace>
        <Icon_MainIcon>$(BDS)\bin\delphi_PROJECTICON.ico</Icon_MainIcon>
        <UWP_DelphiLogo44>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_44.png</UWP_DelphiLogo44>
        <UWP_DelphiLogo150>$(BDS)\bin\Artwork\Windows\UWP\delphi_UwpDefault_150.png</UWP_DelphiLogo150>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.LGAmerica.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>units;EXCH;CommonUnits;..\..\_commonvnext;C:\Projects\_Externals\nativexml;DCUOut;CommonUnits\Synapse;$(D3P)\Source;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <DCC_Define>SQL;$(DCC_Define)</DCC_Define>
        <DCC_DcpOutput>$(D3P)\$(Platform)\DCP</DCC_DcpOutput>
        <DCC_BplOutput>$(D3P)\$(Platform)\BPL</DCC_BplOutput>
        <SanitizedProjectName>PPRECON</SanitizedProjectName>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win32)'!=''">
        <DCC_UsePackage>DBXSqliteDriver;dxSpreadSheetCoreDialogsRS25;dxSkinOffice2007PinkRS25;dxSkinMcSkinRS25;vclFireDAC;cxExportRS25;dxHttpIndyRequestRS25;tethering;dxPScxCommonRS25;addict3db_;FireDACADSDriver;Kodak_Image_Edit;cxPivotGridOLAPRS25;JvPluginSystem;vcltouch;dxSkinDarkRoomRS25;dxSkinDarkSideRS25;Intraweb;svn;JvBands;JvJans;cxLibraryRS25;JvDotNetCtrls;dxSkinOffice2007SilverRS25;dxSkinBlackRS25;dxSkinOffice2007BlueRS25;dxSkinOffice2007BlackRS25;AcroPDF;XMLPartner_PD;Tee925;dxSkinVS2010RS25;dxSkinFoggyRS25;dxSkinSevenRS25;dxSpreadSheetConditionalFormattingDialogsRS25;dxSkinSpringTimeRS25;TeeWorld925;TeeTree2D25Tee9;VCLRESTComponents;XMLPartner_PR;RvCore;cxPageControlRS25;dxSkinLilianRS25;dxPSLnksRS25;RvCompiler;bindengine;dxFireDACServerModeRS25;JvHMI;FireDACMySQLDriver;dxSkinOffice2013LightGrayRS25;dxSkinMetropolisRS25;dxSkinOffice2016DarkRS25;bindcompdbx;dxSkinBlueprintRS25;dxSkinStardustRS25;IndyIPServer;dxPSdxLCLnkRS25;NxDBGridDsgn_dxe;IndySystem;dxSkinOffice2007GreenRS25;dsnapcon;VirtualTreesR;dxLayoutControlRS25;FireDACMSAccDriver;fmxFireDAC;RvBarcode;vclimg;NxCommonDsgn_dxe;Jcl;NxAddonsRun_dxe;dxPScxTLLnkRS25;RvStandard;dxSkinVisualStudio2013LightRS25;dxSpreadSheetRS25;RvReport;TeeMaker125;cxGridRS25;dxSpreadSheetCoreConditionalFormattingDialogsRS25;dxSkinTheAsphaltWorldRS25;DbxCommonDriver;JvManagedThreads;dxSkinHighContrastRS25;JvTimeFramework;fmxobj;dxPScxGridLnkRS25;D7MStreams;PTExtPanels;DbxClientDriver;dxPSCoreRS25;CodeSiteExpressPkg;dxmdsRS25;JvSystem;JvStdCtrls;dxSkinOffice2016ColorfulRS25;appanalytics;LockBox3DR;IndyIPClient;bindcompvcl;dxThemeRS25;NxDBGridRun_dxe;JvDocking;JvPascalInterpreter;FMXTee925;JclVcl;NxCommonRun_dxe;NxGridRun_dxe;cxVerticalGridRS25;JvControls;JvPrintPreview;dxADOServerModeRS25;dxSkinPumpkinRS25;dxCoreRS25;dxSkinValentineRS25;FMXTeeImport925;DBXInterBaseDriver;RvGraphics;TeeDB925;dxSkinOffice2010BlueRS25;JvGlobus;svnui;dxSkinMoneyTwinsRS25;dxSkinSilverRS25;JvMM;dxSkinOffice2013WhiteRS25;bindcompfmx;JvNet;FMXTeePro925;JvAppFrm;TeeImport925;dxOfficeCoreRS25;fmx;fmxdae;dxSkinBlueRS25;dxPScxPivotGridLnkRS25;VirtualTreesD;dxSkinDevExpressDarkStyleRS25;JvWizards;FMXTeeLanguage925;IndyCore;FMXTeeDB925;XMLPartner_CR;JvPageComps;NxCollectionRun_dxe;JvDB;dxSkinLiquidSkyRS25;dxPScxExtCommonRS25;cxPivotGridRS25;dxPSdxSpreadSheetLnkRS25;dxSpreadSheetReportDesignerRS25;JclDeveloperTools;dxSkinCoffeeRS25;JvCmp;DBXMySQLDriver;NxInspectorDsgn_dxe;FireDACCommonODBC;dxSkinOffice2010SilverRS25;cxTreeListRS25;LockBoxDR;IndyIPCommon;JvCustom;dxSkinLondonLiquidSkyRS25;dxPScxVGridLnkRS25;dclRave;JvXPCtrls;dxSkinsCoreRS25;dxComnRS25;TeeUI925;dxSkinWhiteprintRS25;FmxTeeUI925;dxSkinVisualStudio2013BlueRS25;madExcept_;dxSkinGlassOceansRS25;dxSkinMetropolisDarkRS25;dxSkinOffice2013DarkGrayRS25;madBasic_;dxSkinSharpPlusRS25;dxSpreadSheetCoreRS25;dxServerModeRS25;dxSkinCaramelRS25;dxPScxPCProdRS25;NxCollectionDsgn_dxe;JvCore;JvCrypt;FireDACPgDriver;dxSkiniMaginaryRS25;cxEditorsRS25;TeePro925;TeeGL925;JvDlgs;JvRuntimeDesign;NxGridDsgn_dxe;vclwinx;dxSkinSevenClassicRS25;RvEngine;madDisAsm_;cxDataRS25;CustomIPTransport;vcldsnap;dxSkinSharpRS25;bindcomp;FMXTree25;dxSkinVisualStudio2013DarkRS25;cxPivotGridChartRS25;dxSkinOffice2010BlackRS25;dxDBXServerModeRS25;dxSkinDevExpressStyleRS25;dxGDIPlusRS25;GW_Crap;VCL_FlexCel_Core;TeeImage925;NxSheetRun_dxe;TeeLanguage925;dsnapxml;IndyProtocols;addict3_;dxSkinSummer2008RS25;JclContainers;NxInspectorRun_dxe;dxSkinXmas2008BlueRS25;fmxase;$(DCC_UsePackage)</DCC_UsePackage>
        <BT_BuildType>Debug</BT_BuildType>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Keys>CompanyName=;FileDescription=$(MSBuildProjectName);FileVersion=1.0.0.0;InternalName=;LegalCopyright=;LegalTrademarks=;OriginalFilename=;ProgramID=com.embarcadero.$(MSBuildProjectName);ProductName=$(MSBuildProjectName);ProductVersion=1.0.0.0;Comments=</VerInfo_Keys>
        <DCC_UnitSearchPath>$(BDSlib)\win32\release;$(BDSlib)\win32\Debug;$(D3P)\Win32\CommonDCU;$(DCC_UnitSearchPath)</DCC_UnitSearchPath>
        <Manifest_File>$(BDS)\bin\default_app.manifest</Manifest_File>
        <DCC_UseMSBuildExternally>false</DCC_UseMSBuildExternally>
        <DCC_BplOutput>$(D3P)\Win32\BPL</DCC_BplOutput>
        <DCC_DcpOutput>$(D3P)\Win32\DCP</DCC_DcpOutput>
        <DCC_Define>madexcept;$(DCC_Define)</DCC_Define>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Base_Win64)'!=''">
        <DCC_UsePackage>DBXSqliteDriver;DataSnapServerMidas;DBXDb2Driver;DBXInterBaseDriver;FMX_FlexCel_Core;vclFireDAC;tethering;FireDACADSDriver;DBXMSSQLDriver;DatasnapConnectorsFreePascal;FireDACMSSQLDriver;vcltouch;bindcompfmx;Intraweb;DBXOracleDriver;FmxTeeUI;emsedge;fmx;fmxdae;VCL_FlexCel_Components;vclib;FireDACDBXDriver;IndyCore;DataSnapCommon;DataSnapConnectors;VCLRESTComponents;bindengine;DBXMySQLDriver;FireDACOracleDriver;FireDACMySQLDriver;DBXFirebirdDriver;FireDACCommonODBC;DataSnapClient;bindcompdbx;IndyIPCommon;DBXSybaseASEDriver;IndyIPServer;IndySystem;FireDACDb2Driver;dsnapcon;FireDACMSAccDriver;fmxFireDAC;FireDACInfxDriver;vclimg;TeeDB;emshosting;FireDACPgDriver;ibmonitor;FireDACASADriver;DBXOdbcDriver;FireDACTDataDriver;FMXTee;DbxCommonDriver;Tee;DataSnapServer;DataSnapNativeClient;fmxobj;vclwinx;ibxbindings;FireDACDSDriver;DbxClientDriver;DBXSybaseASADriver;CustomIPTransport;vcldsnap;bindcomp;appanalytics;DBXInformixDriver;IndyIPClient;bindcompvcl;TeeUI;FMX_FlexCel_Components;VCL_FlexCel_Core;FireDACODBCDriver;DataSnapIndy10ServerTransport;dsnapxml;DataSnapProviderClient;FireDACMongoDBDriver;IndyProtocols;fmxase;$(DCC_UsePackage)</DCC_UsePackage>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1)'!=''">
        <DCC_Define>DEBUG;$(DCC_Define)</DCC_Define>
        <DCC_DebugDCUs>true</DCC_DebugDCUs>
        <DCC_Optimize>false</DCC_Optimize>
        <DCC_GenerateStackFrames>true</DCC_GenerateStackFrames>
        <DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>
        <DCC_RemoteDebug>true</DCC_RemoteDebug>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_1_Win32)'!=''">
        <DCC_RemoteDebug>false</DCC_RemoteDebug>
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
        <VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>
        <VerInfo_Locale>1033</VerInfo_Locale>
        <DCC_MapFile>3</DCC_MapFile>
        <Debugger_RunParams>/ini=BANTEST /MASS /company=banner /test /applini=//mdlxit/vol1/test32/lifepro/bat/garym/DATAGATHER_SIFTER1C.INI /runafterdelay=04</Debugger_RunParams>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2)'!=''">
        <DCC_LocalDebugSymbols>false</DCC_LocalDebugSymbols>
        <DCC_Define>RELEASE;$(DCC_Define)</DCC_Define>
        <DCC_SymbolReferenceInfo>0</DCC_SymbolReferenceInfo>
        <DCC_DebugInformation>0</DCC_DebugInformation>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Cfg_2_Win32)'!=''">
        <AppEnableRuntimeThemes>true</AppEnableRuntimeThemes>
        <AppEnableHighDPI>true</AppEnableHighDPI>
    </PropertyGroup>
    <ItemGroup>
        <DelphiCompile Include="$(MainSource)">
            <MainSource>MainSource</MainSource>
        </DelphiCompile>
        <DCCReference Include="units\PPRECONU.pas">
            <Form>ppreconform</Form>
            <FormType>dfm</FormType>
        </DCCReference>
        <BuildConfiguration Include="Release">
            <Key>Cfg_2</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
        <BuildConfiguration Include="Base">
            <Key>Base</Key>
        </BuildConfiguration>
        <BuildConfiguration Include="Debug">
            <Key>Cfg_1</Key>
            <CfgParent>Base</CfgParent>
        </BuildConfiguration>
    </ItemGroup>
    <ProjectExtensions>
        <Borland.Personality>Delphi.Personality.12</Borland.Personality>
        <Borland.ProjectType>Application</Borland.ProjectType>
        <BorlandProject>
            <Delphi.Personality>
                <Source>
                    <Source Name="MainSource">PPRECON.dpr</Source>
                </Source>
                <Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dcloffice2k250.bpl">Microsoft Office 2000 Sample Automation Server Wrapper Components</Excluded_Packages>
                    <Excluded_Packages Name="$(BDSBIN)\dclofficexp250.bpl">Microsoft Office XP Sample Automation Server Wrapper Components</Excluded_Packages>
                </Excluded_Packages>
            </Delphi.Personality>
            <Deployment Version="3">
                <DeployFile LocalName="exe\PPRECON.exe" Configuration="Debug" Class="ProjectOutput">
                    <Platform Name="Win32">
                        <RemoteName>PPRECON.exe</RemoteName>
                        <Overwrite>true</Overwrite>
                    </Platform>
                </DeployFile>
                <DeployClass Name="AdditionalDebugSymbols">
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>0</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidClassesDexFile">
                    <Platform Name="Android">
                        <RemoteDir>classes</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidGDBServer">
                    <Platform Name="Android">
                        <RemoteDir>library\lib\armeabi-v7a</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidLibnativeArmeabiFile">
                    <Platform Name="Android">
                        <RemoteDir>library\lib\armeabi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidLibnativeMipsFile">
                    <Platform Name="Android">
                        <RemoteDir>library\lib\mips</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidServiceOutput">
                    <Platform Name="Android">
                        <RemoteDir>library\lib\armeabi-v7a</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidSplashImageDef">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="AndroidSplashStyles">
                    <Platform Name="Android">
                        <RemoteDir>res\values</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_DefaultAppIcon">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_LauncherIcon144">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-xxhdpi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_LauncherIcon36">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-ldpi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_LauncherIcon48">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-mdpi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_LauncherIcon72">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-hdpi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_LauncherIcon96">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-xhdpi</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_SplashImage426">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-small</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_SplashImage470">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-normal</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_SplashImage640">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-large</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="Android_SplashImage960">
                    <Platform Name="Android">
                        <RemoteDir>res\drawable-xlarge</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="DebugSymbols">
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="DependencyFramework">
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                        <Extensions>.framework</Extensions>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="DependencyModule">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                        <Extensions>.dll;.bpl</Extensions>
                    </Platform>
                </DeployClass>
                <DeployClass Required="true" Name="DependencyPackage">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                        <Extensions>.dylib</Extensions>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                        <Extensions>.bpl</Extensions>
                    </Platform>
                </DeployClass>
                <DeployClass Name="File">
                    <Platform Name="Android">
                        <Operation>0</Operation>
                    </Platform>
                    <Platform Name="iOSDevice32">
                        <Operation>0</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>0</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>0</Operation>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\Resources\StartUp\</RemoteDir>
                        <Operation>0</Operation>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPad_Launch1024">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPad_Launch1536">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPad_Launch2048">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPad_Launch768">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPhone_Launch320">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPhone_Launch640">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="iPhone_Launch640x1136">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectAndroidManifest">
                    <Platform Name="Android">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectiOSDeviceDebug">
                    <Platform Name="iOSDevice32">
                        <RemoteDir>..\$(PROJECTNAME).app.dSYM\Contents\Resources\DWARF</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <RemoteDir>..\$(PROJECTNAME).app.dSYM\Contents\Resources\DWARF</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectiOSDeviceResourceRules">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectiOSEntitlements">
                    <Platform Name="iOSDevice32">
                        <RemoteDir>..\</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <RemoteDir>..\</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectiOSInfoPList">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectiOSResource">
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectOSXEntitlements">
                    <Platform Name="OSX32">
                        <RemoteDir>..\</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectOSXInfoPList">
                    <Platform Name="OSX32">
                        <RemoteDir>Contents</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectOSXResource">
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\Resources</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Required="true" Name="ProjectOutput">
                    <Platform Name="Android">
                        <RemoteDir>library\lib\armeabi-v7a</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSDevice64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="iOSSimulator">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Linux64">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="OSX32">
                        <RemoteDir>Contents\MacOS</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win32">
                        <Operation>0</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="ProjectUWPManifest">
                    <Platform Name="Win32">
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win64">
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="UWP_DelphiLogo150">
                    <Platform Name="Win32">
                        <RemoteDir>Assets</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win64">
                        <RemoteDir>Assets</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <DeployClass Name="UWP_DelphiLogo44">
                    <Platform Name="Win32">
                        <RemoteDir>Assets</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                    <Platform Name="Win64">
                        <RemoteDir>Assets</RemoteDir>
                        <Operation>1</Operation>
                    </Platform>
                </DeployClass>
                <ProjectRoot Platform="iOSDevice64" Name="$(PROJECTNAME).app"/>
                <ProjectRoot Platform="Win64" Name="$(PROJECTNAME)"/>
                <ProjectRoot Platform="iOSDevice32" Name="$(PROJECTNAME).app"/>
                <ProjectRoot Platform="Linux64" Name="$(PROJECTNAME)"/>
                <ProjectRoot Platform="Win32" Name="$(PROJECTNAME)"/>
                <ProjectRoot Platform="OSX32" Name="$(PROJECTNAME).app"/>
                <ProjectRoot Platform="Android" Name="$(PROJECTNAME)"/>
                <ProjectRoot Platform="iOSSimulator" Name="$(PROJECTNAME).app"/>
            </Deployment>
            <Platforms>
                <Platform value="Win32">True</Platform>
                <Platform value="Win64">False</Platform>
            </Platforms>
            <ModelSupport>False</ModelSupport>
        </BorlandProject>
        <ProjectFileVersion>12</ProjectFileVersion>
    </ProjectExtensions>
    <Import Project="$(BDS)\Bin\CodeGear.Delphi.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Delphi.Targets')"/>
    <Import Project="$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj" Condition="Exists('$(APPDATA)\Embarcadero\$(BDSAPPDATABASEDIR)\$(PRODUCTVERSION)\UserTools.proj')"/>
    <Import Project="$(MSBuildProjectName).deployproj" Condition="Exists('$(MSBuildProjectName).deployproj')"/>
</Project>
}}}PPRECONU.dfm
object ppreconform: Tppreconform
  Left = 412
  Top = 190
  Caption = 
    'PPRECON: axxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx bxxxxxxxxxxxxxxxx' +
    'xxxxxxx  cxxxxxxxxxxxxxxxxxxx.'
  ClientHeight = 745
  ClientWidth = 1133
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clBlue
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OldCreateOrder = False
  OnActivate = OnActivate
  OnCreate = FormCreate
  OnDestroy = FormDestroy
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Panel1: TPanel
    Left = 0
    Top = 0
    Width = 1133
    Height = 745
    Align = alClient
    AutoSize = True
    TabOrder = 0
    object Label1: TLabel
      Left = 111
      Top = 264
      Width = 37
      Height = 13
      Caption = 'Status'
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clWindowText
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = [fsBold, fsUnderline]
      ParentFont = False
    end
    object lStatus: TLabel
      Left = 8
      Top = 264
      Width = 971
      Height = 13
      Caption = 
        '                                                               C' +
        'lick RUN and provide inputs such as WHERE TO LOOK and WHAT VALUE' +
        ' TO SEARCH FOR, etc.  This program will only READ the search fil' +
        'es, not update them.'
    end
    object Button1: TButton
      Left = 152
      Top = 8
      Width = 75
      Height = 25
      Caption = 'Run'
      TabOrder = 0
      OnClick = Button1Click
    end
    object ListBox1: TListBox
      Left = 8
      Top = 80
      Width = 1113
      Height = 178
      Style = lbOwnerDrawFixed
      Color = 13819132
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clMaroon
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = []
      ItemHeight = 11
      ParentFont = False
      TabOrder = 1
    end
    object StringGrid1: TStringGrid
      Left = 8
      Top = 283
      Width = 1073
      Height = 420
      ColCount = 8
      Font.Charset = DEFAULT_CHARSET
      Font.Color = clRed
      Font.Height = -11
      Font.Name = 'MS Sans Serif'
      Font.Style = [fsBold]
      Options = [goFixedVertLine, goFixedHorzLine, goVertLine, goHorzLine, goRangeSelect, goColSizing, goColMoving, goTabs]
      ParentFont = False
      TabOrder = 2
      OnDrawCell = StringGrid1DrawCell
      ColWidths = (
        4
        30
        66
        101
        1000
        4
        4
        4)
      RowHeights = (
        24
        24
        24
        24
        24)
    end
    object CancelAUTORUN: TButton
      Left = 8
      Top = 8
      Width = 97
      Height = 25
      Caption = 'Cancel AUTORUN'
      TabOrder = 3
      OnClick = CancelAUTORUNClick
    end
  end
  object Timer1: TTimer
    OnTimer = Timer1Timer
    Left = 520
    Top = 33
  end
end
}}}PPRECONU
Unit PPRECONU;

Interface

Uses
  Windows, Messages, SysUtils, StrUtils, DateUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, IdBaseComponent, IdComponent, IdIOHandler, IdIOHandlerStream,
  Vcl.ExtCtrls, SabUtils, uLGAini, Vcl.Grids, UITypes, System.IOUtils, System.Types;

Type
  Tppreconform = Class(TForm)
    Panel1: TPanel;
    Button1: tButton;
    Label1: tLabel;
    lStatus: tLabel;
    ListBox1: TListBox;
    Timer1: TTimer;
    StringGrid1: TStringGrid;
    CancelAUTORUN: TButton;
    procedure WaitForABit(Const TickLimit: Integer);
    procedure gettrovedata(const ChkField: AnsiString; const Rule: AnsiString; const MovField: AnsiString;
     var trovedata: AnsiString; var rc: integer);
    procedure GetRFiles(const StartDir: String; const List: TStrings; var GRFresult: boolean);
    procedure ScriptIfNotFound(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptIfFound(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptFindInFile01(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure BuildPlus(Const fieldin: AnsiString; Var fieldout: AnsiString);
    procedure ScriptCopyWNC(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptRename(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptIfne(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptCopyAsis(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptDeleteFile(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptIfeq(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptGoto(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptUnsupported(Const Field1: String; Const Field2: String);
    procedure ISOLATETEXT(Const infield: AnsiString; Var outfield: AnsiString);
    procedure ScriptSet(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptReport(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure ScriptCompare(Const Operand1: String; Const Operand2: String; Const Operand3: String);
    procedure APPLYSCRIPT(const S_REFFILENAME: AnsiString);
    Procedure DoWaitx(J_RUNDATETIME: String);
    procedure FillGrid(const EXECPARM: AnsiString; const PPTH: Ansistring;
     const AITOUSE: AnsiString; StringGrid1: TStringGrid; script: TStringList);
    procedure FormCreate(Sender: TObject);
    Procedure FormShow(Sender: tObject);
    Procedure OnActivate(Sender: TObject);
    Procedure Button1Click(Sender: tObject);
    procedure FormDestroy(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState);
    procedure CancelAUTORUNClick(Sender: TObject);
  Private
    { Private declarations }
    //
    S_LINETRACKER: TStringList;            // to track script lines executed and related return code
    S_SPERR: Integer;                      // script processing error code
    S_GOTONEXTSTMT: AnsiString;            // a script re-direction "next line" pointer - set by a GOTO statement
    S_LASTSTMTNUM: AnsiString;             // the statement number of the last script statement
    //
    S_ReportNTLSSP: AnsiString;             // next to last script statement processed
    S_ReportLSSP: AnsiString;               // last script statement processed
    S_ReportRecord: AnsiString;            // overall output report line area
    S_ReportLT: AnsiString;                // the segment of the report line having to do with Line Tracker info
    S_ReportMRL: AnsiString;               // most recently encountered script Label name
    S_ReportTF: AnsiString;
    S_ReportStates: AnsiString;
    //
    S_FILESIZE: AnsiString;                // size of the in-focus Ref file
    S_LASTMODDT: AnsiString;               // last modified date of the currently-in-focus Ref file
    S_ATTRREADONLY: AnsiString;            //  Y in this means it is a READ ONLY file
    S_CURRRECORD: AnsiString;              //  the currently-in-focus record from the current Reference file
    S_RECPOINTER: LongInt;                 //  the currently-in-focus record number within current Reference file
    S_RECPOSITION: Integer;                //  a pointer value.   it points to "where" in the record some data was found
    //
    S_STATEEQUAL: AnsiString;               // F in this means NOT equal    (T means it WAS equal)
    S_STATELESSTHAN: AnsiString;            // F in this means NOT less than
    S_STATELESSTHANOREQUAL: AnsiString;     // F in this means NOT less than or equal to
    S_STATEGREATERTHAN: AnsiString;         // F in this means NOT greater than
    S_STATEGREATERTHANOREQUAL: AnsiString;  // F in this means NOT greater than or equal to
    S_STATEFOUND: AnsiString;               // F in this means NOT found
    //
    S_STATEFOUNDPOSITION: Integer;          // if FOUND IN RECORD is true, this is the POSITION that it was found at
    S_STATEFOUNDRECPOINTER: Integer;        // for FOUND state True, this is the rec num of the rec that the prior FIND was successful on
    S_RUNDATETIME: AnsiString;              // run date and time
    S_RUNDATE: AnsiString;                  // run date
    S_RUNTIME: AnsiString;                  // run time
    S_TEXT0, S_TEXT1, S_TEXT2, S_TEXT3, S_TEXT4, S_TEXT5, S_TEXT6, S_TEXT7, S_TEXT8, S_TEXT9: AnsiString;
    S_PCKD0, S_PCKD1, S_PCKD2, S_PCKD3, S_PCKD4, S_PCKD5, S_PCKD6, S_PCKD7, S_PCKD8, S_PCKD9: LongInt;
    //
    S_PCKD1_STRTEMP: AnsiString;    // temp garygary  garygarygary
    //
    //S_FILESIZE: AnsiString;                 // filesize of the in-focus REF file
    //S_LASTMODDT: AnsiString;                // last modified date of the in-focus REF file
    //S_ATTRREADONLY: AnsiString;             // one byte for Y or N
    //
    //S_DATA1: AnsiString;
    //S_DATA2: AnsiString;
    //S_DATA3: AnsiString;
    //S_DATA4: AnsiString;
    //S_DATA5: AnsiString;
    //S_DATA6: AnsiString;
    //S_DATA7: AnsiString;
    //S_DATA8: AnsiString;
    //S_DATA9: AnsiString;
    //S_FOUNDSWITCH: AnsiString; // is set to Y or N as result of a FIND command
    //S_RESULTSWITCH: AnsiString;  //  set to T (for true) if IF statement is found to be true,   F if found to be false
    //S_DATAINDEX: AnsiString;      //  an in-record pointer to the specific byte that is in question (a FIND will set this value)
    //
    S_LAST_LOADED: AnsiString;              // the path + filename of the last Reference file that was loaded into S_REFFILERECORD
    S_REFFILENAME: AnsiString;              // the full filename of the in-focus Reference file
    S_REFFILESTEM: AnsiString;              // left (STEM) part of the filename for the in-focus Ref file
    S_REFFILEEXTENSION: AnsiString;         // right (Extension) part of the filenmae fo rthe in-focus Ref file
    S_REFNEXTRECORD: AnsiString;            // going to try to NOT need this at all
    S_REFPRIORRECORD: AnsiString;           // going to try to NOT need this at all
    //S_REFCURRRECORD: AnsiString;
    //S_REFFILENAME: AnsiString;
    //S_REFFILENAMEWITHOUTEXTENSION: AnsiString;
    //S_REFFILENAMEEXTENSION: AnsiString;
    //
    S_REFFILERECORD: TStringList;    //  when this variable really exists, it contains indexed list of ALL records in the in-focus REF file (first rec is record zero)
    //
    J_TROVE1CHK: AnsiString;                 //   a trove is a tuck-away data store which will get dumped as output at the end
    J_TROVE1RULE: AnsiString;
    J_TROVE1MOV: AnsiString;
    J_TROVE1: TStringList;
    J_TROVE2CHK: AnsiString;                 //
    J_TROVE2RULE: AnsiString;
    J_TROVE2MOV: AnsiString;
    J_TROVE2: TStringList;
    J_TROVE3CHK: AnsiString;                 //
    J_TROVE3RULE: AnsiString;
    J_TROVE3MOV: AnsiString;
    J_TROVE3: TStringList;
    //
    J_REPORTLINE: TStringList;  // tempStringList := TStringList.Create;
    J_TEXTFIELDREPORTMAXBYTES: Integer;
    J_RUNDATETIME: String;
    J_PATHIN: AnsiString;
    J_FILTER: AnsiString;
    J_RPTTITLE: AnsiString;
    J_RPTNOTE: AnsiString;
    J_RPTFILENAME: AnsiString;    // output file name for the file we create on pathout1
    J_OF1FILENAME: AnsiString;
    J_OF2FILENAME: AnsiString;
    J_OF3FILENAME: AnsiString;
    J_DELIMRPT: AnsiString;
    J_DELIM1: AnsiString;
    J_DELIM2: AnsiString;
    J_DELIM3: AnsiString;
    J_LIMITINFILES: AnsiString;
    J_LIMITRPT: AnsiString;
    J_RPTWHENISAY: AnsiString;
    J_LOGFILENAME: AnsiString;
    J_PATHOUT1: AnsiString;
    J_PATHOUT2: AnsiString;
    J_PATHOUT3: AnsiString;
    //
    PPTH: AnsiString;
    EXECPARM: AnsiString;
    AITOUSE: AnsiString;
    //
    delayseconds: Integer;
    Delay: integer;
    AutoContinue: AnsiString;
    ErrColl: Integer;
    FCount: Integer;
    TimeOut: TDateTime;
    script: tStringList;
    ParmData: tStringList;
    StatementError: tStringList;
    StatementErrorCodes: array of Integer;
    //
  Public
    { Public declarations }
    log: ttextfileout;
    //s: AnsiString; del
    //tfilenm: AnsiString;    del
    //pfilenm: AnsiString;           del
    //x: Integer;    del
    Function DtNow(DT: tDateTime): AnsiString;
  End;

//type
//  TTmColumnTitle = class(TTmObject)
//  private
//    FCellColor: TColor;
//  public
//    property CellColor: TColor read FCellColor write FCellColor;
//  end;



Var
  ppreconform: Tppreconform;

Implementation

//var
//  FG: array of array of TColor;
//  BG: array of array of TColor;

{$R *.dfm}


//    FUNCTIONS


procedure Tppreconform.CancelAUTORUNClick(Sender: TObject);
begin
   CancelAUTORUN.Enabled := False;            // user clicked CANCEL autorun button, so turn this off
   AutoContinue := 'N';
   //
   //    and here, we should cancel the timer and maybe set delayseconds to zero
   TimeOut := IncSecond(Now, 0);
   Delay := 0;
   //Timer1.Enabled := False;
   //delayseconds := 0;
   //
end;




Function Tppreconform.DtNow(DT: tDateTime): AnsiString;
Begin
  Result := EmptyStr;
  Result := datetostr(DT) + ' ' + timetostr(DT) + ': ';
End;



Function IsStrANumber(Const s: AnsiString): Boolean;
Var
  C: PAnsiChar;
Begin
  C := PAnsiChar(s);
  Result := False;
  While C^ <> #0 Do
  Begin
    If Not (C^ In ['0'..'9']) Then
      Exit;
    Inc(C);
  End;
  Result := True;
End;




function FileSizeStr (const filename: string ): string;
var
  size: Int64;
  handle: integer;
begin
  handle := FileOpen(filename, fmOpenRead);
  if handle = -1 then
    result := '??'                                   // unable to open the sought file, so return ?? as the size
  else try
    size := Int64(FileSeek(handle,Int64(0),2));
    case Length(IntToStr(size)) of
      1..3: result := Format ( '%d bytes', [size] );
      4..6: result := Format ( '%f KB', [size / 1E3] );
      7..9: result := Format ( '%f MB', [size / 1E6] );
      10..12: result := Format ( '%f GB', [size / 1E9] );
      13..15: result := Format ( '%f TB', [size / 1E12] );
    end;
  finally
    FileClose ( handle );
  end;
end;




// F comes in as B (blank) or C (colon) or X (check for either blank or colon)
function FindBCX(const F: String; const S: String; const startbyte: Integer): Integer;
var
  z: Integer;
  testbyte: AnsiString;
 begin
   Result := 0;
   for z := startbyte to Length(S) do
    begin
     testbyte := S[z];
     if ((F = 'B') or (F = 'X')) and (testbyte = ' ') then result := z;
     if ((F = 'C') or (F = 'X')) and (testbyte = ':') then result := z;
     //if and (testbyte = ':')) then result := z;
     if result <> 0 then Break;
    end;
 end;



function ISOLOPER(var StartByte: integer; const OperandArea: AnsiString; var EndByte: integer): AnsiString;
var
  i: Integer;
  capturing: AnsiString;
  mybyte: AnsiString;
  countofsc: Integer;
  WorkingWithinQuotes: AnsiString;

LABEL
 EXITNOW;

begin
  capturing := 'N';
  countofsc := 0;
  WorkingWithinQuotes := 'N';
  //
  for i := StartByte to Length(OperandArea) do
      //if (WorkingWithinQuotes = 'Y') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'N';
      //if (WorkingWithinQuotes = 'N') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'Y';
      if capturing = 'Y' then
         begin
           mybyte := OperandArea [i];
           if (WorkingWithinQuotes = 'Y') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'N';
           if (WorkingWithinQuotes = 'N') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'Y';
           if (OperandArea [i] = ' ') and (WorkingWithinQuotes = 'N') then
             begin
               //EndByte := EndByte - 1;
               Break;
             end
           else
             begin
               EndByte := EndByte + 1;
               if EndByte > Length(OperandArea) then Break;
             end
         end
      else
         begin
           mybyte := OperandArea [i];   // gary test
           if (WorkingWithinQuotes = 'Y') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'N';
           if (WorkingWithinQuotes = 'N') and (OperandArea [i] = '"') then WorkingWithinQuotes := 'Y';
           if (OperandArea [i] = ' ') or (OperandArea [i] = CHR(0)) then
              begin
                //if (OperandArea [i] = ' ') then StartByte := Startbyte + 1;
                StartByte := Startbyte + 1;
                //if (OperandArea [i] = CHR(0)) then EndByte := EndByte + 1;
                EndByte := EndByte + 1;
                if (OperandArea [i] = CHR(0)) then
                  begin
                   countofsc := countofsc + 1;
                  end;
              end
           else
              begin
                capturing := 'Y';
                EndByte := StartByte + 1 + countofsc;
              end
         end;
//
result := Copy(OperandArea, StartByte, EndByte - StartByte);
//
if countofsc = 0 then GOTO EXITNOW;
//
EndByte := EndByte - countofsc;
//
EXITNOW:
end;


//function ISOLOPER(var StartByte: integer; const OperandArea: AnsiString; var EndByte: integer): AnsiString;
//var
//  i: Integer;
//  capturing: AnsiString;
//  mybyte: AnsiString;
//
//begin
//  capturing := 'N';
//  //
//  for i := StartByte to Length(OperandArea) do
//      if capturing = 'Y' then
//         begin
//           mybyte := OperandArea [i];
//           if OperandArea [i] = ' ' then
//             begin
//               EndByte := EndByte - 1;
//               Break;
//             end
//           else
//            begin
//               EndByte := EndByte + 1;
//               if EndByte > Length(OperandArea) then Break;
//             end
//         end
//      else
//         begin
//           mybyte := OperandArea [i];   // gary test
//           if ((OperandArea [i] <> ' ') and (OperandArea [i] <> CHR(0))) or (OperandArea [i] = CHR(94)) then
//              begin
//                capturing := 'Y';
//                EndByte := StartByte + 1;
//              end
//           else
//              begin
//                StartByte := Startbyte + 1;
//                if (OperandArea [i] = CHR(0)) then EndByte := EndByte + 1;
//              end
//         end;
//   result := Copy(OperandArea, StartByte, EndByte - StartByte);
//end;




function OccurrencesOfChar(const S: string; const C: char): integer;
var
  i: Integer;
begin
  result := 0;
  for i := 1 to Length(S) do
    if S[i] = C then
      inc(result);
end;




function ScriptLineEdit(const SL: AnsiString; var Operand1: AnsiString;
 var Operand2: AnsiString; var Operand3: AnsiString): integer;        // this will be added to to supply edits of Script lines
var
  OperandArea: AnsiString;
  //OperandCount: Integer;
  countofquotes: Integer;
  countofoperands: Integer;
  //i: Integer;  del
  StartSpot: Integer;
  EndSpot: Integer;
  F: AnsiString;
  P: Integer;
  TrimSL: AnsiString;
  Command: AnsiString;

Label
  EDITEXIT, NOCOLON, QUOTEERR, OPERANDSSET, WRONGNUMOPERANDS, TROVEERR;

begin
  result := 0;
  StartSpot := 1;
  F := 'C';
  //
  TrimSL := TrimLeft(SL);
  P := FindBCX(F, TrimSL, StartSpot);   // set P to byte-position of first (left-most) colon
  if P = 0 then GOTO NOCOLON;
  Command := Copy(TrimSL, 1, P-1);
  OperandArea := Copy(TrimSL, P+1, Length(TrimSL));
  //
  //OperandCount := 0;
  //Operand1 := '';
  //Operand2 := '';
  //Operand3 := '';


  //garygary
  if Command = 'FINDINFILE01' then
    begin
      Command := Command;
    end;
   //garygary






  if Length(OperandArea) = 0 then GOTO OPERANDSSET;
  if (Command = 'RPTTITLE') or (Command = 'RPTNOTE') then
    begin
      //OperandCount := 1;
      Operand1 := OperandArea;
      countofoperands := 1;
      GOTO OPERANDSSET;
    end;
  //
  countofquotes := OccurrencesOfChar(OperandArea, '"');
  if (countofquotes > 0) and (countofquotes mod 2 = 1) then GOTO QUOTEERR;   // an odd num of quotes is problematic

  //if MyNumber mod 2 = 0 then
  //if (countofquotes <> 0) and (countofquotes <> 2) then GOTO QUOTEERR;
  //
  countofoperands := 0;
  StartSpot := 0;
  Operand1 := TrimRight(ISOLOPER(StartSpot, OperandArea, EndSpot));
  //Operand1 := ISOLOPER(StartSpot, OperandArea, EndSpot);
  if Operand1 = '' then GOTO OPERANDSSET;
  countofoperands := countofoperands + 1;
  //
  StartSpot := EndSpot + 1;
  if EndSpot < Length(OperandArea) then
   begin
    //Operand2 := ISOLOPER(StartSpot, OperandArea, EndSpot);
    Operand2 := TrimRight(ISOLOPER(StartSpot, OperandArea, EndSpot));
    if Operand2 = '' then GOTO OPERANDSSET;
    countofoperands := countofoperands + 1;
   end;
  //
  StartSpot := EndSpot + 1;
  if EndSpot < Length(OperandArea) then
   begin
    //Operand3 := ISOLOPER(StartSpot, OperandArea, EndSpot);
    Operand3 := TrimRight(ISOLOPER(StartSpot, OperandArea, EndSpot));
    if Operand3 = '' then GOTO OPERANDSSET;
    countofoperands := countofoperands + 1;
   end;
  //
  if EndSpot < Length(OperandArea) then GOTO WRONGNUMOPERANDS;
  //


  //
OPERANDSSET:
  //
  // IFFOUND can have zero or one operands. If has one operand, it must be a GOTO:nnnn statement+labelname
  if Command = 'IFFOUND' then
   begin
     if countofoperands > 1 then GOTO WRONGNUMOPERANDS;
      // gary, here we just need to confirm that the ONE operand we have is a GOTO with label
     GOTO EDITEXIT;
   end;
  //
  // IFNOTFOUND can have zero or one operands. If has one operand, it must be a GOTO:nnnn statement+labelname
  if Command = 'IFNOTFOUND' then
   begin
     if countofoperands > 1 then GOTO WRONGNUMOPERANDS;
      // gary, here we just need to confirm that the ONE operand we have is a GOTO with label
     GOTO EDITEXIT;
   end;
  //
  //   17) FINDINFILE01 Search exactly ONE time for a given value (optionally, you can indicate
  //   which in-record "row" to search in)
  //   This can have up to three operands:
  //    RECORDRANGE(nnn,yyy) where nnn indicates "which record within curr ref file to start the search in)
  //         and yyy indicates which record is the LAST record in which the search should be done.
  //              RECORDRANGE(DATA5,DATA5+11) would mean to search the TWELVE records only (or up to 12) that are at record counter DATA5.
  //        (For the short term, I will support RECORDRANGE(NEXT,ALL) as "find starting in the next unsearched rec no, and go through end of file")
  //    COLUMNRANGE(ccc,xxx) where ccc is the "column number" within the record to begin the search - and
  //         xxx is the last column number that is to be considered to be in searchable area for each record
  //    %TEXT8  (an operand to explain "what we are seeking").  If this is referring to a work filed,
  //         we should see if that work field appears to be being set ANYWHERE within the script
  if Command = 'FINDINFILE01' then
   begin
     if countofoperands > 3 then GOTO WRONGNUMOPERANDS;
     if countofoperands < 1 then GOTO WRONGNUMOPERANDS;

     // gary - here we need to parse and edit whatever operands are provided
     GOTO EDITEXIT;
   end;
  //
  if Command = 'FINDINRECORD' then
   begin

   GOTO EDITEXIT;
   end;
  //
  // for findfile, just ensure that exactly ONE operand exists
  // (it can be a compound operand, like DATA2+DATA6))
    if Command = 'FINDFILE' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //   22) SET   must have exactly TWO operands.  The first operand is set to some value - based on
  //   what the second operand resolves to.  If the second operand is a work data field (DATA03, etc)
  //   then check the overall script to see if that data field appears to be being set at all.
  if Command = 'SET' then
   begin
     if countofoperands <> 2 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //    24)  COMPARE    exactly two operands must be provided
  //    for this, just ensure that there are exactly two operands and that both are either
  //    work data names (DATA05, etc) or Script Keyword fields (such as @FILENAME)
  if Command = 'COMPARE' then
   begin
     if countofoperands <> 2 then GOTO WRONGNUMOPERANDS;
     // gary - add checks to validate the KIND of operands here
     GOTO EDITEXIT;
   end;
  //
  //   12) COPYASIS:  Copy current REF file (as it exists in memory) from PATHIN to selcted output path.
  //    There must be exactly ONE operand.  This operand resolves to the output location (path) to which
  //    the file is to be copied.
  if Command = 'COPYASIS' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //   13) COPYWNC:   Copy with filename change.  For this command, there must be exactly TWO operands.
  //   The first operand must resolve to a location (path) where the file is to be copied to.  The
  //   second operand must resolve to a FileName.  Both operands can be compound operands.
  if Command = 'COPYWNC' then
   begin
     if countofoperands <> 2 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //   25) DELETEFILE    erase an existing file
  //  for edit, we just will check if there are exactly ONE operand provided AND confirm if that operand is
  //  a work field (DATA0, DATA1, etc) - and if so, then see if a line elsewhere (anywhere) in the script
  //  that SETS that field in question... and if so, then consider this statement to pass the edits
  if Command = 'DELETEFILE' then
   begin
     if countofoperands > 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //   11) GOTO:      Jump to a stated Label within the script.
  //    after the colon, there must be a label name.  so, one check taht we'll need to do is to
  //     confirm that whatever label is pointed to by this GOTO - that label really does exist
  if Command = 'GOTO' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - for the one operand received, ensure that the label referred to really DOES exist
     GOTO EDITEXIT;
   end;
  //
  //   23) LABEL:xxx   provides a jump-to script location  for use by a GOTO statement that is
  // somewhere in the logic.   Just ensure that the refferred to LABEL IS defined exactly ONE time in the
  // script.  Also - as you are editing these, complete the JUMPTO array (just a label name and a script
  // pointer).
  if Command = 'LABEL' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - for the one operand received, ensure that the specified label name does not already exist (if so, duplicate labell has been requested)
     GOTO EDITEXIT;
   end;
  //
  //   10) IFEQ (if A operand equals B operand)        example:   IFEQ: DATA1 DATA2
  //   for IFEQ, there may be ZERO or ONE operand.   If there is an operand, it must be a
  //   GOTO command (which includes a target label)
  if Command = 'IFEQ' then
   begin
     if countofoperands > 1 then GOTO WRONGNUMOPERANDS;
     if countofoperands = 0 then GOTO EDITEXIT;
     // gary - for the ONE operand received, confirm that it is a valid GOTO with label
     GOTO EDITEXIT;
   end;
  //
  //   13) IFNE   (if A operand NOT equal to B operand)     example:   IFNE DATA5 DATA4
  //   for IFNE, there may be ZERO or ONE operand.   If there is an operand, it must be a
  //   GOTO command (which includes a target label)
  if Command = 'IFNE' then
   begin
     if countofoperands > 1 then GOTO WRONGNUMOPERANDS;
     if countofoperands = 0 then GOTO EDITEXIT;
     // gary - for the ONE operand received, confirm that it is a valid GOTO with label
     GOTO EDITEXIT;
   end;
  //
  if Command = 'IFLT' then
   begin

   GOTO EDITEXIT;
   end;
   //
  if Command = 'IFGT' then
   begin

   GOTO EDITEXIT;
   end;
  //
  if Command = 'IFGE' then
   begin

   GOTO EDITEXIT;
   end;
  //
  if Command = 'IFLE' then
   begin

   GOTO EDITEXIT;
   end;
  //
  //
  //    1) PATHIN  exactly one operand must exist for this.  It shows where to look for input REF files.
  if Command = 'PATHIN' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - confirm that valid path value is provided, if possible
     GOTO EDITEXIT;
   end;
  //
  //    2) FILTER: provides a filter/mask to limit "which" REF files within PATHIN are processed
  //    If this is not provided, we will seek to get this information via dialogue with user (unless
  //     autorun is on... in which case, we then would apply the script to ALL REF files in PATHIN).
  //     Exactly one operand is provided - and it describes the MASK to use when selecting input REF
  //     files from PATHIN.
  if Command = 'FILTER' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - confirm that valid filter value is received, if possible
     GOTO EDITEXIT;
   end;
  //
  //    2) RPTTITLE:  specifies what value to write as first output line in the primary output report
  //    The processing includes a SINGLE textual line at TOP of the main output report.
  //    Whatever information is found to right of the command is considered to be that data which goes tehre.
  if Command = 'RPTTITLE' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //    2) RPTNOTE:   specifies what value to write as second output line in primary output report.
  //    When this is present, record TWO written to the primary output "report" will be whatever is in
  //    this record (right of the command value).
  if Command = 'RPTNOTE' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //    2) RPTFILENAME: specifies the filename of the final Output (primary) report.
  //    When present, this provides a SINGLE operand - which when resolved (it can be a compound
  //    operand such as "FUNREPORT"+%DATETIME) - provides FILENAME of the output primary report file.
  if Command = 'RPTFILENAME' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - attempt to validate that the ONE operand received is a valid filename
     GOTO EDITEXIT;
   end;
  //
  //    2) OF1FILENAME: specifies filename of OUTFILE1
  //    If Output file is written to PATHOUT1, it will use this SINGLE operand as the output filename.
  //    Note: this doesn't apply to REF files copied to PATHOUT1... just work files that the script
  //    logic creates to PATHOUT1.
  if Command = 'OF1FILENAME' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - attempt to validate that the ONE operand received is a valid filename
     GOTO EDITEXIT;
   end;
  //
  //    2) OF2FILENAME: specifies filename of OUTFILE2
  //    If Output file is written to PATHOUT2, it will use this SINGLE operand as the output filename
  if Command = 'OF2FILENAME' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - attempt to validate that the ONE operand received is a valid filename
     GOTO EDITEXIT;
   end;
  //
  //    2) OF3FILENAME: specifies filename of OUTFILE3
  //    If Output file is written to PATHOUT3, it will use this SINGLE operand as the output filename
  if Command = 'OF3FILENAME' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - attempt to validate that the ONE operand received is a valid filename
     GOTO EDITEXIT;
   end;
  //
  //    2) DELIMRPT:  A value to use as field delimiter when constructing report line
  //    A single operand for this provides the value that will be used in separting report fields in rows that make up the primary output report
  if Command = 'DELIMRPT' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate that the delimiter value received is ONE byte and should 'work'
     GOTO EDITEXIT;
   end;
  //
  //    2) DELIM1:  Another Delimiter value that user can set (for use with outputs which are not the primary report)
  if Command = 'DELIM1' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate that the delimiter value received is ONE byte and should 'work'
     GOTO EDITEXIT;
   end;
  //
  //    2) DELIM2:  Another Delimiter value that user can set (for use with outputs which are not the primary report)
  if Command = 'DELIM2' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate that the delimiter value received is ONE byte and should 'work'
     GOTO EDITEXIT;
   end;
  //
  //    2) DELIM3:  Another Delimiter value that user can set (for use with outputs which are not the primary report)
  if Command = 'DELIM3' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate that the delimiter value received is ONE byte and should 'work'
     GOTO EDITEXIT;
   end;
  //
  //
  //    2) LIMITINFILES:    A number of maximum input REF files allowed to be considered in this run
  //    exactly ONE operand supplies this limiting value
  if Command = 'LIMITINFILES' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate the value of the ONE operand is usable as a count limiter
     GOTO EDITEXIT;
   end;
  //
  //    2) LIMITRPT:    A number of maximum report entries to allow written to the output report
  //    exactly ONE operand supplies this limiting value
  if Command = 'LIMITRPT' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate the value of the ONE operand is usable as a count limiter
     GOTO EDITEXIT;
   end;
  //
  //    2) RPTWHENISAY: Directive to ONLY write to the main output report when script processing encounters "REPORT"
  //    A single operand (one position... Y or N) supplies this switch value.
  if Command = 'RPTWHENISAY' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - validate the switch value (must by Y or N)
     GOTO EDITEXIT;
   end;
  //
  //    2) REPORT:    used only when RPTWHENISAY is "Y"... encountering this command tells report writer to create and write a report line at this time;
  //    This has exactly one Operand - which provides the info that needs reporting... (can use Complex operand with + to append more fields)
  if Command = 'REPORT' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     GOTO EDITEXIT;
   end;
  //
  //    2) LOGFILENAME a single operand for this indicates what the outut LOG file name should be;
  //    A single operand supplies filename of the to-be-created log file (can be a compound operand)
  if Command = 'LOGFILENAME' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - attempt to validate that the ONE operand received is a valid LOG filename
     GOTO EDITEXIT;
   end;
  //
  //    2) PATHOUT1:  (if creating any work files for reports or OUTFILE1 files)
  //    A single operand supplies PATH value
  if Command = 'PATHOUT1' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - confirm that valid path value is provided, if possible
     GOTO EDITEXIT;
   end;
  //
  //    2) PATHOUT2:  (if creating any OUTFILE2 files)
  //    A single operand supplies PATH value
  if Command = 'PATHOUT2' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - confirm that valid path value is provided, if possible
     GOTO EDITEXIT;
   end;
  //
  //    2) PATHOUT3:  (if creating any OUTFILE3 files)
  //    A single operand supplies PATH value
  if Command = 'PATHOUT3' then
   begin
     if countofoperands <> 1 then GOTO WRONGNUMOPERANDS;
     // gary - confirm that valid path value is provided, if possible
     GOTO EDITEXIT;
   end;
  //
  if (Command = 'TROVE1') OR (Command = 'TROVE2') OR (Command = 'TROVE3') then
   begin
     if countofoperands <> 3 then GOTO WRONGNUMOPERANDS;
     if copy(Operand1, 1, 5) <> '%TEXT' then GOTO TROVEERR;
     if (copy(Operand3, 1, 5) <> '%TEXT') and (copy(Operand3,1, 4)  <> '%REF') and (copy(Operand3,1, 5)  <> '%PATH') then GOTO TROVEERR;
     if (Operand2 <> 'NULL') and (Operand2 <> 'NOTNULL') then GOTO TROVEERR;
     // gary - could do more checking of operand 1 and 2
     GOTO EDITEXIT;
   end;
  //
  result := 5;    // command is not recognized
  GOTO EDITEXIT;
  //
  //
  //
  GOTO EDITEXIT;
NOCOLON:
  result :=1;     // this command is lacking the colon - which needs to come immediatly after the command
  GOTO EDITEXIT;
  //
TROVEERR:
  result :=4;     // TROVE command is using un-supported operands
  GOTO EDITEXIT;
  //
QUOTEERR:
  result :=6;     // count of quote marks within operand area must be zero or two
  GOTO EDITEXIT;
  //
WRONGNUMOPERANDS:
  result :=7;     // some extra data - which MAY be mistaken as an extra operand - is found in this statement
  GOTO EDITEXIT;
  //
EDITEXIT:
  //
end;









function FindPos(aCh: AnsiChar; const S: String; const startbyte: Integer): Integer;
var
  z: Integer;
  testbyte: AnsiString;
 begin
   Result := 0;
   for z := startbyte to Length(S) do
    begin
     testbyte := S[z];
     if (testbyte = aCh) then Result := z;
     if Result <> 0 then Break;
    end;
     //  begin
     //    Result := z;
     //    Break
     //  end;
 end;








// function FindBlankOrColon(const S: String; const startbyte: Integer): Integer;
//var
//  z: Integer;
//  testbyte: AnsiString;
// begin
//   Result := 0;
//   for z := startbyte to Length(S) do
//    begin
//     testbyte := S[z];
//     if (testbyte = ' ') then result := z;
//     if (testbyte = ':') then result := z;
//     if result <> 0 then Break;
//    end;
// end;













function SecsToHmsStr(ASecs: integer):string;
begin
  Result := Format('%2d:%2.2d:%2.2d',
    [ASecs div 3600, ASecs mod 3600 div 60, ASecs mod 3600 mod 60]);
end;





//   SUBROUTINES



procedure  Tppreconform.GetRFiles(const StartDir: String; const List: TStrings; var GRFresult: boolean);
var
  SRec: TSearchRec;
  Res: Integer;
  filt: AnsiString;
begin
  filt := '*.*';
  if J_FILTER <> '' then filt := J_FILTER;
  if not Assigned(List) then
  begin
    GRFresult := False;
    Exit;
  end;
  Res := FindFirst(StartDir + filt, faAnyfile, SRec );
  if Res = 0 then
  try
    while res = 0 do
    begin
      if (SRec.Attr and faDirectory <> faDirectory) then
        // If you want filename only, remove "StartDir +"
        // from next line
        //List.Add( StartDir + SRec.Name );
      List.Add(SRec.Name);
      Res := FindNext(SRec);
    end;
  finally
    FindClose(SRec)
  end;
  GRFresult := (List.Count > 0);
end;




// garygary there is a lot more to do in this function...
procedure Tppreconform.gettrovedata(const ChkField: AnsiString; const Rule: AnsiString; const MovField: AnsiString; var trovedata: AnsiString; var rc: integer);

var
 worksender: AnsiString;
 workcheck: AnsiString;

begin
  rc := 0;
  //
  ISOLATETEXT(MovField, worksender);
  ISOLATETEXT(ChkField, workcheck);
  //
  trovedata := worksender;
  if (workcheck = '') and (Rule = 'NOTNULL') then rc := 1;
  if (workcheck <> '') and (Rule = 'NULL') then rc := 1;
end;








procedure Tppreconform.ScriptUnsupported(Const Field1: String; Const Field2: String);
//var
// i: Integer;
Begin
  showmessage('Script Line ' + Field1 + ' is using command that is currently unsupported:' + Field2);
End;




//   gary - the next bit to do is to make ISOLATETEXT be able to deal with internal fields, like %REFFILENAME@001(003)
//procedure Tppreconform.ISOLATETEXT(Const infield: AnsiString; Var outfield: AnsiString; Var LI: LongInt);
procedure Tppreconform.ISOLATETEXT(Const infield: AnsiString; Var outfield: AnsiString);
var
//i: Integer;  del
Quote1POS: Integer;
Quote2POS: Integer;

MOVEBYTES: Integer;
MOVEDISPLACEMENT: Integer;
MOVEEND: Integer;
MOVELENGTH: Integer;

POSAT: Integer;
POSOPEN: Integer;
POSCLOSE: Integer;
MOVELEN: AnsiString;
MOVEPOS: AnsiString;

zeros15: AnsiString;

//charArray : Array[0..2] of Char;      del
//strArray  : Array of String;     del

//strA      : String;  del

LABEL
 ISO_NOTDOINGQUOTES, ISOLATETEXTX, ISO_NOTCURRREC, ISO_LFF_NOTNEEDED, ISO_NOTRECPOINTER, ISO_NOTPCKD1;
begin
  //
  zeros15 := '000000000000000';
  //
  Quote1POS := FindPos('"', infield, 1);
  if Quote1POS = 0 then GOTO ISO_NOTDOINGQUOTES;
  Quote2POS := FindPos('"', infield, Quote1POS+1);
  outfield := copy(infield, Quote1POS+1, Quote2POS - Quote1POS - 1);
  GOTO ISOLATETEXTX;
  //
ISO_NOTDOINGQUOTES:
  outfield := infield;                                        //  assume we should end up with this user-coded constant for this field
  if infield = '%TEXT0' then outfield := S_TEXT0;
  if infield = '%TEXT1' then outfield := S_TEXT1;
  if infield = '%TEXT2' then outfield := S_TEXT2;
  if infield = '%TEXT3' then outfield := S_TEXT3;
  if infield = '%TEXT4' then outfield := S_TEXT4;
  if infield = '%TEXT5' then outfield := S_TEXT5;
  if infield = '%TEXT6' then outfield := S_TEXT6;
  if infield = '%TEXT7' then outfield := S_TEXT7;
  if infield = '%TEXT8' then outfield := S_TEXT8;
  if infield = '%TEXT9' then outfield := S_TEXT9;
  //
  if copy(infield, 1, 12) = '%REFFILENAME' then
   begin
     outfield := S_REFFILENAME;
     if length(infield) = 12 then GOTO ISOLATETEXTX;
     POSAT := FindPos('@', infield, 1);
     POSOPEN := FindPos('(', infield, 1);
     POSCLOSE := FindPos(')', infield, 1);
     if POSOPEN = 0 then POSOPEN := Length(S_REFFILENAME);
     MOVEPOS := copy(infield, POSAT+1, POSOPEN-POSAT-1);
     MOVELEN := IntToStr(Length(S_REFFILENAME) - StrToInt(MOVEPOS) + 1);
     if POSCLOSE <> 0 then MOVELEN := copy (infield, POSOPEN+1, POSCLOSE - POSOPEN - 1);
     outfield := copy(S_REFFILENAME, StrToInt(MOVEPOS), StrToInt(MOVELEN));
   end;
  //
  if infield = '%PATHIN' then outfield := J_PATHIN;
  if infield = '%PATHOUT1' then outfield := J_PATHOUT1;
  if infield = '%PATHOUT2' then outfield := J_PATHOUT2;
  if infield = '%PATHOUT3' then outfield := J_PATHOUT3;
  //
  if infield = '%REFFILEEXTENSION' then
   begin
    outfield := S_REFFILEEXTENSION;
   end;
  if infield = '%REFFILESTEM' then outfield := S_REFFILESTEM;
  //
  //
  if copy(infield, 1, 17) <> '%REFCURRENTRECORD' then  GOTO ISO_NOTCURRREC;
  // okay - we have now learned that we'll need focus on data/content that is within this REF file.
  if S_LAST_LOADED = J_PATHIN + S_REFFILENAME then GOTO ISO_LFF_NOTNEEDED;  // if curr REF file alread loaded, then branch (with S_CURRECORDNUM set how ever it is set...)
  S_RECPOINTER := 0;                                                        // record pointer will show that FIRST recd in file has focus
  if Assigned(S_REFFILERECORD) then S_REFFILERECORD.free;                   // free stringlist if needed
  S_REFFILERECORD:= TStringList.Create;                                     // create stringlist for REF file content
  S_REFFILERECORD.LoadFromFile(J_PATHIN + S_REFFILENAME);                   // put all rows from curr REF file into this stringlist at once
  WaitForABit(100);                                                         // give Windows a chance to catch up (loading all the records may take a bit)
  S_LAST_LOADED := J_PATHIN + S_REFFILENAME;                                // keep track of which REF file we last loaded into S_REFFILERECORD
  S_CURRRECORD := S_REFFILERECORD[S_RECPOINTER];                            // the in-focus REF file record content
ISO_LFF_NOTNEEDED:
 //
  outfield := S_CURRRECORD;                                                 // assume for now that we want the ENTIRE in-focus record...
  if Length(infield) = 17 then GOTO ISOLATETEXTX;                           // if no qualifiers after main part of the operand, then we are done
  //
  //here - if position 18 is an @, then find either an set MOVEEND to either the location of an open-paren OR length of this operand
  MOVEEND := Length(infield);                                               // assume it'll be len of infield that we'll need...
  POSOPEN := FindPos('(', infield, 1);                                      // see what position the open-paren is in, if any
  if POSOPEN > 0 then                                                       // if there is an open-paren then that marks the 'end' of the move length data
    begin
      MOVEEND := POSOPEN;
      POSCLOSE := FindPos(')', infield, 1);
    end;
  MOVEBYTES := MOVEEND - 19;                                                // calc num-of-bytes in the script-specified Displacement data
  MOVEDISPLACEMENT := StrToInt(copy(infield, 19, MOVEBYTES));               // set the script-prescribed "move from" position (within the in-focus REF file record)
  MOVELENGTH := StrToInt(copy(infield, POSOPEN+1, POSCLOSE-POSOPEN-1));     // set move length (if provided)
  outfield := copy(outfield, MOVEDISPLACEMENT, MOVELENGTH);                 // isolate the proper part of the data, now
  //
ISO_NOTCURRREC:
  //
  if copy(infield, 1, 11) <> '%RECPOINTER' then  GOTO ISO_NOTRECPOINTER;    // we do Not need to isolate a field based on %RECPOINTER, so branch
  outfield := IntToStr(S_RECPOINTER);                                       // gary
  outfield := RightStr(zeros15 + outfield, 15);                             // garygary
ISO_NOTRECPOINTER:
  //
  if copy(infield, 1, 6) <> '%PCKD1' then  GOTO ISO_NOTPCKD1;    // we do Not need to isolate a field based on %PCKD1, so branch
  outfield := S_PCKD1_STRTEMP;                                       // garygary
ISO_NOTPCKD1:
  //
ISOLATETEXTX:                                             //garygary - currently testing the SET based on %REFCURRENTRECORD
end;




procedure Tppreconform.WaitForABit(Const TickLimit: Integer);
var
  StartTickCount, CurTicks: DWORD;
begin
// sleep for 5 seconds without freezing
StartTickCount := GetTickCount();
//Start := Ticks;
CurTicks := 0;
repeat
  // (WAIT_OBJECT_0+nCount) is returned when a message is in the queue.
  // WAIT_TIMEOUT is returned when the timeout elapses.
  if MsgWaitForMultipleObjects(0, Pointer(nil)^, FALSE, TickLimit-CurTicks, QS_ALLINPUT) <> WAIT_OBJECT_0 then Break;
  Application.ProcessMessages;
  CurTicks := GetTickCount() - StartTickCount;
  //Elapsed := Ticks - Start;
until CurTicks >= TickLimit;
end;




procedure Tppreconform.ScriptFindInFile01(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 i: Integer;
 P: Integer;
 //WORKLEFT: AnsiString;       del
 //WORKRIGHT: AnsiString;   del
 //compareformat: AnsiString;   del
 soughtdata: AnsiString;
 colendviaop: AnsiString;                 // a switch - to let the below loop know whether the in-play script stmt provided an artificial Column End limiter for searching
 colstart: Integer;
 colend: Integer;
 recnostart: Integer;
 recnoend: Integer;
 numofgoodfindsneeded: Integer;
 numofgoodfinds: Integer;
 finddirection: AnsiString;

 //LI: LongInt;

LABEL
 FIF01NOTF, FIF01EXIT, FIF_LFF_NOTNEEDED;

Begin
  //
  S_STATEFOUND := 'F';        // assume search will be unsuccessful
  //
  if S_LAST_LOADED = J_PATHIN + S_REFFILENAME then GOTO FIF_LFF_NOTNEEDED;
  S_RECPOINTER := 0;
  if Assigned(S_REFFILERECORD) then S_REFFILERECORD.free;    // doing it this way, you'd load every time a file operation like FINDINFILE is done...
  S_REFFILERECORD:= TStringList.Create;
  S_REFFILERECORD.LoadFromFile(J_PATHIN + S_REFFILENAME);
  WaitForABit(100);
  S_LAST_LOADED := J_PATHIN + S_REFFILENAME;
  if S_REFFILERECORD.Count > 0 then S_CURRRECORD := S_REFFILERECORD[S_RECPOINTER];
FIF_LFF_NOTNEEDED:
 //
 // if not Assigned(S_REFFILERECORD) then
 //  S_REFFILERECORD:= TStringList.Create;
 //  S_REFFILERECORD.LoadFromFile(J_PATHIN + S_REFFILENAME);
 //  WaitForABit(100);
  //
  if S_REFFILERECORD.Count < 1 then GOTO FIF01NOTF;
  //
  S_RECPOINTER := 0;             //  if find is successful, this becomes the Record Number of the record we found
  S_RECPOSITION := 0;            //  a pointer to "where" in the record the data was found
  //
  numofgoodfindsneeded := 1;     //  the number of successful "finds" we are trying for
  finddirection := 'F';          //  indicate that the search for the data should be "F"orward through the file
  //  gary - this routine needs adjustment so as to be able to "search the file Backwards", when needed... if we want to do that
  //
  //
  //  default values (will use these values if user did not specify via this script stmt to limit columns and row numbers involved)
  colstart :=1;
  recnostart := 0;
  recnoend := S_REFFILERECORD.Count;
  colendviaop := 'N';
  //
  ISOLATETEXT(Operand2, soughtdata);   // put Operand2 data into field "soughtdata"
  if (soughtdata = 'RECORDRANGE(next,end)') OR (soughtdata = 'RECORDRANGE(NEXT,END)') Then recnostart := S_STATEFOUNDRECPOINTER + 1;   // to be able to keep looking beyond place where last FIND was successful
  //
  //ISOLATETEXT(Operand1, soughtdata, LI);   // resolve the search data as set forth by the current script statement
  ISOLATETEXT(Operand1, soughtdata);   // resolve the search data as set forth by the current script statement
  //
  //resolve colstart, colend, recnostart, recnoend - these are established based on Operand2 and Operand3.
  // also set colendviaop to "Y" if the user did provide a colend value... see for loop below for 'why we need it'
  //
  For i := recnostart To recnoend - 1 Do
    Begin
    //
      if colendviaop = 'N' then colend := Length(S_REFFILERECORD[i]);    // note: if colend WAS set via operand, then colend has already been set... via above stmts
      //
      P := Pos(soughtdata, S_REFFILERECORD[i]);    //
      //
      If (P <> 0) And (P >= colstart) And (P <= colend) Then             //
        Begin
          numofgoodfinds := numofgoodfinds + 1;
          if numofgoodfinds = numofgoodfindsneeded Then
             begin
               S_STATEFOUND := 'T';
               S_RECPOINTER := i + 1;
               //
               S_CURRRECORD := S_REFFILERECORD[i];         //
               //
               S_RECPOSITION := P;
               S_STATEFOUNDRECPOINTER := i + 1;
               S_SPERR := 0;
               Break;
             end;
        End;
    End;
  //
  if S_STATEFOUND = 'T' then GOTO FIF01EXIT;
  //
FIF01NOTF:
    S_SPERR := 1;                 //  we were not able to find what user asked to find
    S_STATEFOUNDRECPOINTER := 0;  //  reset this - since FIND was not successful
  //
FIF01EXIT:
End;




procedure Tppreconform.ScriptCompare(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 //i: Integer; del
 WORKLEFT: AnsiString;
 WORKRIGHT: AnsiString;
 compareformat: AnsiString;
 //LI: LongInt;
LABEL
 COMPARENUM, COMPAREEXIT, COMPAREISEQUAL, COMPAREISGREATER;
Begin
  //showmessage('Compare Operand2:'+Operand2);
  //
  S_SPERR := 0;
  //
  //
  //
  //S_TEXT1 := 'JEG';   // for a test
  //
  //
  //
  //
  S_STATEEQUAL := 'F';
  S_STATELESSTHANOREQUAL := 'F';
  S_STATEGREATERTHANOREQUAL := 'F';
  S_STATELESSTHAN := 'F';
  S_STATEGREATERTHAN := 'F';
  //
  compareformat := 'P';                                           // assume it will be a packed (numeric) compare
  if copy(Operand1, 1, 5) = '%TEXT' then compareformat := 'T';    // indicate that we are to compare Text
  if copy(Operand1, 1, 1) = '"' then compareformat := 'T';
  //
  if compareformat = 'P' then GOTO COMPARENUM;
  //
  //ISOLATETEXT(Operand1, WORKLEFT, LI);                                // whatever value is indicated by operand1 now goes into field WORKLEFT
  //ISOLATETEXT(Operand2, WORKRIGHT, LI);                               // whatever data value is indicated by operand2 goes into WORKRIGHT
  ISOLATETEXT(Operand1, WORKLEFT);                                // whatever value is indicated by operand1 now goes into field WORKLEFT
  ISOLATETEXT(Operand2, WORKRIGHT);                               // whatever data value is indicated by operand2 goes into WORKRIGHT
  //
  if WORKLEFT = WORKRIGHT then GOTO COMPAREISEQUAL;
  if WORKLEFT > WORKRIGHT then GOTO COMPAREISGREATER;
  //
  S_STATELESSTHANOREQUAL := 'T';
  S_STATELESSTHAN := 'T';
  GOTO COMPAREEXIT;
  //
COMPAREISGREATER:
  S_STATEGREATERTHANOREQUAL := 'T';
  S_STATEGREATERTHAN := 'T';
  GOTO COMPAREEXIT;
  //
COMPAREISEQUAL:
  S_STATEEQUAL := 'T';
  S_STATELESSTHANOREQUAL := 'T';
  S_STATEGREATERTHANOREQUAL := 'T';
  GOTO COMPAREEXIT;
  //
COMPARENUM:
  S_SPERR := 8;                  // for now, we don't have all of the COMPARE logic in place
COMPAREEXIT:
End;






procedure Tppreconform.ScriptSet(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 //LI: LongInt;
 WORKRIGHT: AnsiString;
 targetformat: AnsiString;
LABEL
 SETNUM, SETNUMBAD, SETEXIT;
Begin
  S_SPERR := 0;
  //
  if Operand1 = '%TEXT6' then         // garygary temptemp
     begin
       S_REFFILENAME := S_REFFILENAME; // garygary temp stuff
     end;
  //
  //
  if Copy(Operand2, 1, 18) = '%REFCURRENTRECORD@' then         // garygary temptemp
     begin
       S_REFFILENAME := S_REFFILENAME; // garygary temp stuff
     end;
  //
  targetformat := 'T';                                           // assume it will be a text set
  if (copy(Operand1, 1, 5) = '%PCKD') or (copy(Operand1, 1, 11) = '%RECPOINTER') then             // added recopointer 5/25/2023
    begin
      targetformat := 'P';    // indicate that we are to result in Packed
      if S_REFFILENAME = 'MDADMIN_D4_ANNSTMTSWP_ERRORS.TXT' then
        begin
          S_REFFILENAME := S_REFFILENAME; // garygary temp stuff
        end;
    end;
  //
  if targetformat = 'P' then GOTO SETNUM;
  //
  BuildPlus(Operand2, WORKRIGHT);   // use Operand2 info to construct some "sending" value for this SET instruction
  //
  if Operand1 = '%TEXT0' then S_TEXT0 := WORKRIGHT;
  if Operand1 = '%TEXT1' then S_TEXT1 := WORKRIGHT;
  if Operand1 = '%TEXT2' then S_TEXT2 := WORKRIGHT;
  if Operand1 = '%TEXT3' then S_TEXT3 := WORKRIGHT;
  if Operand1 = '%TEXT4' then S_TEXT4 := WORKRIGHT;
  if Operand1 = '%TEXT5' then S_TEXT5 := WORKRIGHT;
  if Operand1 = '%TEXT6' then S_TEXT6 := WORKRIGHT;
  if Operand1 = '%TEXT7' then S_TEXT7 := WORKRIGHT;
  if Operand1 = '%TEXT8' then S_TEXT8 := WORKRIGHT;
  if Operand1 = '%TEXT9' then S_TEXT9 := WORKRIGHT;
  if copy(Operand1, 1, 5) = '%TEXT' then GOTO SETEXIT;
  //
  if Operand1 = '%REFCURRENTRECORD' then
    begin
      S_CURRRECORD := WORKRIGHT;
      S_REFFILERECORD[S_RECPOINTER-1] := S_CURRRECORD;
      GOTO SETEXIT;
    end;
 //
SETNUM:
  BuildPlus(Operand2, WORKRIGHT);    // set WORKRIGHT to be numeric version of whatever Operand2 suggests
  //garygary
  if Operand1 = '%PCKD1' then
    begin
      S_PCKD1_STRTEMP := WORKRIGHT;
    end;
  //
  if Operand1 = '%RECPOINTER' then                           //garygary experimental
    begin
      S_RECPOINTER := StrToInt(WORKRIGHT);
      S_STATEFOUNDRECPOINTER := StrToInt(WORKRIGHT);
      GOTO SETEXIT;
    end;
  //
    GOTO SETEXIT;
  //
SETNUMBAD:
  S_SPERR := 8;                  // for now, we don't have all of the SET logic in place
SETEXIT:
End;







//  this routine will need a lot of work going forward    garygary
procedure Tppreconform.ScriptReport(Const Operand1: String; Const Operand2: String; Const Operand3: String);
Begin
  S_SPERR := 0;
  //
  BuildPlus(Operand1, S_ReportRecord);   // use Operand1 info to construct the Report Line
  J_REPORTLINE.Add(S_ReportRecord);  // add an output row to output report now
  //
End;








procedure Tppreconform.ScriptIfne(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
 //i: Integer;   del
// WORKRIGHT: AnsiString;

LABEL
 IFNEEXIT;

Begin
  S_SPERR := 0;
  if (S_STATEEQUAL = 'F') and (Operand1 = '') then GOTO IFNEEXIT;    // if no goto exists in this command AND if the "IF" passes... then branch
  //
  if (S_STATEEQUAL = 'F') then
    begin
      ScriptGoto(Operand1, '', '');       // this just sets field S_GOTONEXTSTMT to the STATEMENT NUMBER that we should bounce to
      GOTO IFNEEXIT;
    end;
  //
  S_SPERR := 1;                                                      // send back a return code of 1 if the sought state wasnt found
  //
  if (S_STATEEQUAL = 'T') and (Operand1 <> '') then GOTO IFNEEXIT;   // true would have done the provided goto... but false will just fall thru to next script stmt
  //
  if (S_STATEEQUAL = 'T') then
    begin
      S_GOTONEXTSTMT := S_LASTSTMTNUM;      // no goto was on this stmt... so, the IF is interpreted to just allow fallthrough if true... but, it's false - so jump to end of this script execution now
      GOTO IFNEEXIT;
    end;
  //
  S_SPERR := 7;                                                      // user has tested a State without having done a compare ahead of that
IFNEEXIT:
  //
End;






procedure Tppreconform.ScriptIfFound(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
 //i: Integer; del
 //WORKRIGHT: AnsiString;

LABEL
 IFFDEXIT;

Begin
  S_SPERR := 0;
  if (S_STATEFOUND = 'T') and (Operand1 = '') then GOTO IFFDEXIT;    // if no goto exists in this command AND if the "IF" passes... then branch
  //
  if (S_STATEFOUND = 'T') then
    begin
      ScriptGoto(Operand1, '', '');       // this just sets field S_GOTONEXTSTMT to the STATEMENT NUMBER that we should bounce to
      GOTO IFFDEXIT;
    end;
  //
  S_SPERR := 1;                                                      // send back a return code of 1 if the sought state wasnt found
  //
  if (S_STATEFOUND = 'F') and (Operand1 <> '') then GOTO IFFDEXIT;   // true would have done the provided goto... but false will just fall thru to next script stmt
  //
  if (S_STATEFOUND = 'F') then
    begin
      S_GOTONEXTSTMT := S_LASTSTMTNUM;      // no goto was on this stmt... so, the IF is interpreted to just allow fallthrough if true... but, it's false - so jump to end of this script execution now
      GOTO IFFDEXIT;
    end;
  //
  S_SPERR := 7;                                                      // user has tested a State without having done a compare ahead of that
IFFDEXIT:
  //
End;







procedure Tppreconform.ScriptIfNotFound(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
 //i: Integer; del
// WORKRIGHT: AnsiString;

LABEL
 IFNFEXIT;

Begin
  S_SPERR := 0;
  if (S_STATEFOUND = 'F') and (Operand1 = '') then GOTO IFNFEXIT;    // if no goto exists in this command AND if the "IF" passes... then branch
  //
  if (S_STATEFOUND = 'F') then
    begin
      ScriptGoto(Operand1, '', '');       // this just sets field S_GOTONEXTSTMT to the STATEMENT NUMBER that we should bounce to
      GOTO IFNFEXIT;
    end;
  //
  S_SPERR := 1;                                                      // send back a return code of 1 if the sought state wasnt found
  //
  if (S_STATEFOUND = 'T') and (Operand1 <> '') then GOTO IFNFEXIT;   // true would have done the provided goto... but false will just fall thru to next script stmt
  //
  if (S_STATEFOUND = 'T') then
    begin
      S_GOTONEXTSTMT := S_LASTSTMTNUM;      // no goto was on this stmt... so, the IF is interpreted to just allow fallthrough if true... but, it's false - so jump to end of this script execution now
      GOTO IFNFEXIT;
    end;
  //
  S_SPERR := 7;                                                      // user has tested a State without having done a compare ahead of that
IFNFEXIT:
  //
End;







procedure Tppreconform.ScriptCopyWNC(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 //i: Integer; del
 //LI: LongInt;
 selectedopath: AnsiString;
 constructedname: AnsiString;

 Begin
  S_SPERR := 0;
  //
  //ISOLATETEXT(Operand1, selectedopath, LI);
  ISOLATETEXT(Operand1, selectedopath);
  BuildPlus(Operand2, constructedname);   // use Operand2 info to construct a value which will be used as a new Filename
  //
  if Assigned(S_REFFILERECORD) then
    begin
      S_REFFILERECORD.SaveToFile(selectedopath + constructedname);
      WaitForABit(100);
    end
  else
    begin
      TFILE.Copy(J_PATHIN + S_REFFILENAME, selectedopath + constructedname);
      WaitForABit(100);
    end;

  //TFILE.Copy(J_PATHIN + S_REFFILENAME, selectedopath + constructedname);
End;







procedure Tppreconform.BuildPlus(Const fieldin: AnsiString; Var fieldout: AnsiString);
var
 i: Integer;
 //LI: LongInt;
 SLsegment: TStringList;
 isolatedresult: AnsiString;

 Begin
  fieldout := '';
  SLsegment := tstringlist.create;
  S_SPERR := 0;
  SLsegment.Text :=  StringReplace(fieldin, '+', #13#10, [rfReplaceAll]);      // note: Use [rfReplaceAll, rfIgnoreCase] if you want to ignore case
  //
  // now, for each of those name 'segments', we need to resolve what each "means":
  //
  for i := 0 to SLsegment.Count-1 do
    begin
      //ISOLATETEXT(SLsegment[i], isolatedresult, LI);
      ISOLATETEXT(SLsegment[i], isolatedresult);
      fieldout := fieldout + isolatedresult;
    end;
  SLsegment.Free;
End;







procedure Tppreconform.ScriptCopyAsis(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 //i: Integer; del
 //LI: LongInt;
 selectedopath: AnsiString;
 //pwidechar1: PWideChar;     del
 //pwidechar2: PWideChar;  del

 Begin
  S_SPERR := 0;
  //
  //pwidechar1 := S_REFFILENAME;
  //pwidechar2 := S_REFFILENAME;
  //
  selectedopath := J_PATHOUT1;
  //if Operand1 <> '' then ISOLATETEXT(Operand1, selectedopath, LI);
  if Operand1 <> '' then ISOLATETEXT(Operand1, selectedopath);
  //
  if Assigned(S_REFFILERECORD) then
    begin
      S_REFFILERECORD.SaveToFile(selectedopath + S_REFFILENAME);
      WaitForABit(100);
    end
  else
    begin
      TFILE.Copy(J_PATHIN + S_REFFILENAME, selectedopath + S_REFFILENAME);
      WaitForABit(100);
    end;
  ////CopyFile(J_PATHIN + pwidechar1, selectedopath + pwidechar2, False);
  //TFILE.Copy(J_PATHIN + S_REFFILENAME, selectedopath + S_REFFILENAME);
End;





procedure Tppreconform.ScriptDeleteFile(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
// i: Integer;

 Begin
  //S_SPERR := 2;
  //if DeleteFile(J_PATHIN + S_REFFILENAME) then S_SPERR := 0;
  TFILE.Delete(J_PATHIN + S_REFFILENAME);
End;




// gary - this one is still in progress
procedure Tppreconform.ScriptRename(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
// i: Integer;

 Begin
  //S_SPERR := 2;
  //if DeleteFile(J_PATHIN + S_REFFILENAME) then S_SPERR := 0;
  TFILE.Delete(J_PATHIN + S_REFFILENAME);
End;







procedure Tppreconform.ScriptGoto(Const Operand1: String; Const Operand2: String; Const Operand3: String);
var
 i: Integer;
 //WORKRIGHT: AnsiString;  del
 POSCOLON: Integer;
 SOUGHTLABEL: AnsiString;
 myscriptlinelabelvalue: AnsiString;

Begin
  S_SPERR := 0;
  SOUGHTLABEL := Operand1;
  POSCOLON := FindPos(':', Operand1, 1);
  if POSCOLON > 0 then SOUGHTLABEL := TrimLeft(copy(Operand1, POSCOLON+1, Length(Operand1)));
  //
  for i := 0 to StringGrid1.RowCount-1 Do
   begin
     myscriptlinelabelvalue := StringGrid1.Cells[5, i];
     if (StringGrid1.Cells[3, i] = 'LABEL:') and (StringGrid1.Cells[5, i] = SOUGHTLABEL) then
       begin
         S_GOTONEXTSTMT := IntToStr(i);
         Break
       end;
   end;

End;





procedure Tppreconform.ScriptIfeq(Const Operand1: String; Const Operand2: String; Const Operand3: String);
//var
 //i: Integer; del
// WORKRIGHT: AnsiString;

LABEL
 IFEQEXIT;

Begin
  S_SPERR := 0;
  if (S_STATEEQUAL = 'T') and (Operand1 = '') then GOTO IFEQEXIT;    // if no goto exists in this command AND if the "IF" passes... then branch
  //
  if (S_STATEEQUAL = 'T') then
    begin
      ScriptGoto(Operand1, '', '');       // this just sets field S_GOTONEXTSTMT to the STATEMENT NUMBER that we should bounce to
      GOTO IFEQEXIT;
    end;
  //
  S_SPERR := 1;                                                      // send back a return code of 1 if the sought state wasnt found
  //
  if (S_STATEEQUAL = 'F') and (Operand1 <> '') then GOTO IFEQEXIT;   // true would have done the provided goto... but false will just fall thru to next script stmt
  //
  if (S_STATEEQUAL = 'F') then
    begin
      S_GOTONEXTSTMT := S_LASTSTMTNUM;      // no goto was on this stmt... so, the IF is interpreted to just allow fallthrough if true... but, it's false - so jump to end of this script execution now
      GOTO IFEQEXIT;
    end;
  //
  S_SPERR := 7;                                                      // user has tested a State without having done a compare ahead of that
IFEQEXIT:
  //
End;






procedure Tppreconform.APPLYSCRIPT(const S_REFFILENAME: AnsiString);

var
 i: Integer;
 //CompareResult: Integer;     del
 startstmt: Integer;
 mycommand: AnsiString;

LABEL
 SCRIPTGO;

begin
  startstmt := 0;
  S_ReportNTLSSP := '';                     // next to last script statement processed
  S_ReportLSSP := '';                      // last script statement processed
SCRIPTGO:
  for i := startstmt to StringGrid1.RowCount-1 Do
   begin
     //
     S_GOTONEXTSTMT := '';
     S_ReportNTLSSP := S_ReportLSSP;
     S_ReportLSSP :=  StringGrid1.Cells[3, i] + StringGrid1.Cells[4, i];
     //
     mycommand :=  StringGrid1.Cells[3, i];
     //Showmessage(mycommand + ' ' + StringGrid1.Cells[4, i]);
     //
     if StringGrid1.Cells[3, i] = 'COMPARE:' then ScriptCompare(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     if StringGrid1.Cells[3, i] = 'FINDINFILELAST:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     //if StringGrid1.Cells[3, i] = 'FINDINFILE01:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'FINDINFILE01:' then ScriptFindInFile01(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     if StringGrid1.Cells[3, i] = 'RENAME:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'OPEN:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'WRITE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'CLOSE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'APPEND:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'IFGT:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'IFLT:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     //if StringGrid1.Cells[3, i] = 'IFEQ:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'IFEQ:' then ScriptIfeq(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     if StringGrid1.Cells[3, i] = 'IFLE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'IFGE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     //if StringGrid1.Cells[3, i] = 'IFNE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'IFNE:' then ScriptIfne(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     //if StringGrid1.Cells[3, i] = 'GOTO:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'GOTO:' then ScriptGoto(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     if StringGrid1.Cells[3, i] = 'MOVEASIS:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     if StringGrid1.Cells[3, i] = 'MOVEWNC:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     //
     //if StringGrid1.Cells[3, i] = 'COPYASIS:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'COPYASIS:' then ScriptCopyAsis(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     //if StringGrid1.Cells[3, i] = 'COPYWNC:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'COPYWNC:' then ScriptCopyWNC(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     //if StringGrid1.Cells[3, i] = 'IFFOUND:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'IFFOUND:' then ScriptIfFound(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     //if StringGrid1.Cells[3, i] = 'IFNOTFOUND:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'IFNOTFOUND:' then ScriptIfNotFound(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     //if StringGrid1.Cells[3, i] = 'SET:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'SET:' then ScriptSet(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     if StringGrid1.Cells[3, i] = 'REPORT:' then ScriptReport(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     // FOr the label command: there is really NOTHING to process on these lines... so, allow it to be skipped over
     //if StringGrid1.Cells[3, i] = 'LABEL:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'LABEL:' then S_ReportMRL := StringGrid1.Cells[5, i];
     //
     //if StringGrid1.Cells[3, i] = 'DELETEFILE:' then ScriptUnsupported(StringGrid1.Cells[1, i], StringGrid1.Cells[3, i]);
     if StringGrid1.Cells[3, i] = 'DELETEFILE:' then ScriptDeleteFile(StringGrid1.Cells[5, i], StringGrid1.Cells[6, i], StringGrid1.Cells[7, i]);
     //
     S_LINETRACKER.Add(IntToStr(i));            // add a pair of values here (the stmt number for the curr script line AND the return code value it produced)
     S_LINETRACKER.Add(IntToStr(S_SPERR));
     //
     if S_GOTONEXTSTMT <> '' then Break;
   end;
   //
   if S_GOTONEXTSTMT <> '' then
     begin
       startstmt := StrToInt(S_GOTONEXTSTMT);       // honor the provided "GOTO"
       S_GOTONEXTSTMT := '';
       GOTO SCRIPTGO;
     end;
   //
end;





procedure Split(const ParmValu: string; Delimiter: Char; ListOfStrings: TStrings) ;
begin
   ListOfStrings.Clear;
   ListOfStrings.Delimiter       := Delimiter;
   ListOfStrings.StrictDelimiter := True; // Requires D2006 or newer.
   ListOfStrings.DelimitedText   := ParmValu;
end;





//procedure TForm6.Timer1Timer(Sender: TObject);
//begin
//  Label1.Caption := SecsToHmsStr(SecondsBetween(Now, TimeOut));
//  if Now > Timeout then Timer1.Enabled := False;
//end;



//Procedure DoWaitx(delayseconds: Integer; Delay: Integer; Timeout: TDateTime);
Procedure Tppreconform.DoWaitx(J_RUNDATETIME: String);
var
  Start, Elapsed: DWORD;
Begin
 // sleep for N seconds
  Start := GetTickCount;
  Delay := delayseconds * 1000;
  Elapsed := 0;
  //
  repeat
    // (WAIT_OBJECT_0+nCount) is returned when a message is in the queue.
    // WAIT_TIMEOUT is returned when the timeout elapses.
    //if MsgWaitForMultipleObjects(0, Pointer(nil)^, FALSE, 11000-Elapsed, QS_ALLINPUT) <> WAIT_OBJECT_0 then Break;
    Application.ProcessMessages;
    //Elapsed := GetTickCount - Start;
    if Delay = 0 then          // during the countdown, user may click the button which cancels the auto run
     begin                     // when that is clicked, this delay/wait is canceled and that button is made non-working
      Elapsed := 1;
      Break;
     end
    else
     begin
      Elapsed := GetTickCount - Start;
     end;
  until Elapsed >= Delay;
  //
  //Showmessage('The Delay is complete - continue with processing now, since user did not press RUN.');
  //
 End;




procedure Tppreconform.FillGrid(const EXECPARM: AnsiString; const PPTH: Ansistring;
     const AITOUSE: AnsiString; StringGrid1: TStringGrid; script: TStringList);
var
  F: AnsiString;
  tempStringList: TStringList;
  string1, string2, string3, string4: AnsiString;
  row: integer;
  tblsource: AnsiString;
  tbldesc: AnsiString;
  i: Integer;
  startbyte: Integer;
  myPOS: Integer;
  testint: Integer;
  Operand1: AnsiString;
  Operand2: AnsiString;
  Operand3: AnsiString;
begin
  string1 := 's1';
  string2 := 's2';
  string3 := 's3';
  string4 := 's4';
  //
  tblsource := 'ExecParm';
  tbldesc := 'Exec Path';
  //
  row := 0;
  StringGrid1.Font.Color := clRed;
  StringGrid1.Cells[0, row] := '0';
  StringGrid1.Cells[1, row] := 'ITEM NO';
  StringGrid1.Cells[2, row] := 'SOURCE';
  StringGrid1.Cells[3, row] := 'KEYWORD';
  StringGrid1.Cells[4, row] := 'OPERAND';
  //
  row := row + 1;
  StringGrid1.Cells[0, row] := '0';
  StringGrid1.Cells[1, row] := IntToStr(row);
  StringGrid1.Cells[2, row] := 'ExecParm';
  StringGrid1.Cells[3, row] := 'Exec Path';
  StringGrid1.Cells[4, row] := PPTH;
  //
  row := row + 1;
  StringGrid1.Cells[0, row] := '0';
  StringGrid1.Cells[1, row] := IntToStr(row);
  StringGrid1.Cells[2, row] := 'ExecParm';
  StringGrid1.Cells[3, row] := 'Exec Parameters';
  StringGrid1.Cells[4, row] := EXECPARM;
  //
  //   what statements can be encountered within the ApplicationINI?
  //    1) PATHIN
  //     optional:
  //    2) RPTTITLE:  specifies what value to write as first output line in the primary output report
  //    2) RPTNOTE:   specifies what value to write as second output line in primary output report
  //    2) RPTFILENAME: specifies the filename of the final Output (primary) report
  //    2) OF1FILENAME: specifies filename of OUTFILE1
  //    2) OF2FILENAME: specifies filename of OUTFILE2
  //    2) OF3FILENAME: specifies filename of OUTFILE3
  //    2) DELIMRPT:  A value to use as field delimiter when constructing report line
  //    2) DELIMOTH:  Another Delimiter value that user can set (for use with outputs which are not the primary report)
  //    2) RPTMAX:    A number of maximum report entries to allow written to the output report
  //    2) RPTWHENISAY: Directive to ONLY write to the main output report when script processing encounters "REPORT"
  //    2) REPORT:    used only when RPTWHENISAY is "Y"... encountering this command tells report writer to create and write a report line at this time;
  //    2) REFFILTER: provides a filter/mask to limit "which" REF files within PATHIN are processed
  //    2) PATHOUT1:  (if creating any work files for reports or OUTFILE1 files)
  //    2) PATHOUT2:  (if creating any OUTFILE2 files)
  //    2) PATHOUT3:  (if creating any OUTFILE3 files)
  //    3) RENAME:   (to close+rename the current REF file)
  //    4) OPEN:     (open an output file in PATHOUT)
  //    5) WRITE:    (write something to next output row in an output file that has been Opened)
  //    6) CLOSE:    (close an output file in PATHOUT)
  //    7) APPEND:   (open to append to an existing file in PATHOUT)
  //    8) IFAGREATER: See if first listed data item is greater than the second listed item
  //    9) IFALESS:    See if first listed item is less than second listed item
  //   10) IFEQUAL:    See if first listed item has exact same value as second listed item
  //   11) GOTO:      Jump to a stated Label within the script
  //   12) MOVEASIS:   Copy current REF to PATHOUT, and once that copy is done, Delete the PATHIN instance of the file
  //   12  MOVEWNC:    Copy current REF file to PATHOUT with a special/different name for the PATHOUT file - and then delete the PATHIN instance of the file
  //   12) COPYASIS:  Copy current REF file from PATHIN to PATHOUT
  //   13) COPYWNC:   Copy with filename change
  //   14) FIND01     Find first input REF record in current file that has data as specified
  //   15) FIND03 (etc) See if third FIND for the stated data is successful
  //   16) FINDLAST    Find latest occurring instance within the REF file of the stated data
  //   17) FINDINFILE01 Search exactly ONE time for a given value (optionally, you can indicate which in-record "row" to search in)
  //   18) FINDINFILE03 Search three times (unless first or second search failed) for a given value.  If the third find isnt successful, then NOTFOUND condition is set
  //   19) FINDINFILELAST Search for a given value... if found, keep finding until you've found THE LAST such value in the file.
  //   20) IFFOUND Test only the FOUND condition (set by a prior statement) - and only if that is the case, then do whatever is commanded on this line
  //   21) IFNOTFOUND Test only the NOTFOUND condition (as set by prior statement) - and only if that is the case, then do whatever is commanded on this line
  //   22) SET         Put some or all of an existing data field into another data field
  //   23) LABEL:xxx   to supply a jump-to location within the user's script logic - used via "GOTO" statement
  //
  //
  script := TStringList.Create;
  F := 'X';                    // set up to find EITHER a blank or a colon
  StatementError := TStringList.Create;
  tempStringList := TStringList.Create;
  tempStringList.LoadFromFile(AITOUSE);    {Load string from text file}
  //
  for i := 0 to tempStringList.Count-1 do
    begin
      if i = 0 then
       begin
        testint := tempStringList.Count;
        SetLength(StatementErrorCodes, 14) ;
       end;

      if Copy(tempStringList[i], 1, 1) <> '*' then
       begin
        Operand1 := '';
        Operand2 := '';
        Operand3 := '';
        ErrColl := ScriptLineEdit(tempStringList[i], Operand1, Operand2, Operand3);
        StatementError.Add(IntToStr(ErrColl));
        if (ErrColl = 0) or (ErrColl > 0) then
         begin
           script.Add(tempStringList[i]);
           row := row + 1;
           StringGrid1.Font.Color := clPurple;
           //
           if ErrColl > 0 then
            begin
              StringGrid1.DefaultDrawing := False;
              StringGrid1.Font.Color := clGreen;
            end;
           //
           StringGrid1.Cells[0, row] := IntToStr(ErrColl);
           StringGrid1.Cells[1, row] := IntToStr(row);
           StringGrid1.Cells[2, row] := 'Script Line';
           startbyte := 1;
           myPOS := FindBCX(F, tempStringList[i], startbyte);
           if myPOS = 0 then
             begin
               myPOS := Length(tempStringList[i]);
               StringGrid1.Cells[3, row] := Copy(tempStringList[i], 1, myPOS);
               StringGrid1.Cells[4, row] := '';
               StringGrid1.Cells[5, row] := Operand1;
               StringGrid1.Cells[6, row] := Operand2;
               StringGrid1.Cells[7, row] := Operand3;
             end
            else
             begin
               StringGrid1.Cells[3, row] := Copy(tempStringList[i], 1, myPOS);
               StringGrid1.Cells[4, row] := Copy(tempStringList[i], myPOS+1, Length(tempStringList[i]) - myPOS);
               StringGrid1.Cells[5, row] := Operand1;
               StringGrid1.Cells[6, row] := Operand2;
               StringGrid1.Cells[7, row] := Operand3;
             end;
         end;
         S_LASTSTMTNUM := IntToStr(row);                         // this will end up with value of LAST statement number
         StringGrid1.DefaultDrawing := True;
        end;
    end;
    Application.ProcessMessages;
    StringGrid1.RowCount := row+1;
  //
  //
  //  sample code to FINDFIRST and FINDNEXT and FINDCLOSE
  //
  //
  //var
  //searchResult : TSearchRec;
  //
  //begin
  // if FindFirst('Unit1.d*', faAnyFile, searchResult) = 0 then  // find matches to Unit1.d* in current directory
  //    begin
  //      repeat
  //        ShowMessage('File name = '+searchResult.Name);
  //        ShowMessage('File size = '+IntToStr(searchResult.Size));
  //      until FindNext(searchResult) <> 0;
  //      FindClose(searchResult);
  //    end;
  //end;

end;





//        M A I N L I N E
Procedure Tppreconform.Button1Click(Sender: tObject);
Var
  trovedata: AnsiString;
  troverc: Integer;
  //RDIR: AnsiString;
  //S_SPERR: Integer;
  //ParmSegment: Array of String;   del
  //searchvalu: AnsiString;    del
  //Ppath: AnsiString;  del
  XFIELDDELIM: AnsiString;
  //FS: TFormatSettings;   del
  //FileDateTime: TDateTime;    del
  //FormattedDateTime: AnsiString;  del
  i: Integer;
  //fad: TWin32FileAttributeData;   del
  //CurrWidth: Integer;  del
  //MaxWidth: Integer;  del
  //FINALO: TextFile;   del
  //TFile, TTFile: TextFile;  del
  //SFile: TextFile;  del
  //CURRREFFILE: AnsiString;
  //OutpTNam: AnsiString;  del
  FileDateI: TDateTime;
  //RFLMODDT: AnsiString;
  //RFEXT: AnsiString;
  //RFSTEM: AnsiString;
  RFSTEMLENGTH: Integer;
  //RFSIZE: AnsiString;
  //myCvalue: Integer;    del
  //saveWTSLC: Integer; del
  //saveN: Integer;        del
  Q: Integer;
  //openDialog: TOpenDialog;   del
  //FworkTSL: tStringList;     del
  //TTYPESTSL: tStringList;  del
  REFFILESSL: tStringList;
  spac4: AnsiString;
  spac10: AnsiString;
  //tmpltnmI: AnsiString;    del
  //tmpltnmO: AnsiString; del
  InptFNam: AnsiString;
  //FCOL: Integer;  del
  //P1COL, P2COL, P1ROW, P2ROW: Integer;    del
  //SCOL: Integer; del
  today: tDateTime;
  CurDt: String;
  //CURDOCNO: AnsiString;           del
  zros10: AnsiString;
  //COMPANY: AnsiString;    del
  //COTXT: AnsiString;    del
  //wfolder: AnsiString;   del
  //workdir: AnsiString;       del
  //workfield: AnsiString;  del

  SR: TSearchRec;
  tempFile: TextFile;
  line: AnsiString;
  Rpath: AnsiString;
//  Spath: AnsiString;        del
//  Opath: AnsiString;   del
//  Sfilename: AnsiString;  del

  RECMX: AnsiString;
  RECM2: AnsiString;
  RECM1: AnsiString;
  REC0: AnsiString;
  RECPLUS1: AnsiString;
  RECPLUS2: AnsiString;
  Triggered: AnsiString;
  sep: AnsiString;

  qualified: integer;

  GRFresult: boolean;

  //S: String;  del
  Canvass: TCanvas;
  Index: integer;
  countoferrors: integer;

  ATTR: integer;

Label
  NOGO, REFFILESDONE, REFTOP, NEXT, SCRIPTSEVERE, KEEPONX, KEEPON1, GO, NOPOSTPROCESSAUTOREPORT, TROVEACCUMDONE;

Begin
  //
  //  the "RUN" button is only enabled for use if there are no script edit errors.  When user presses RUN button,
  //  this procedure is run.   This procedure is the main "script processor" routine.
  //
  //  This routine processes script instruction after script instruction on EACH Reference file encountered from the "list"
  //  of Reference files (that list is created near the top of this routine).
  //
  //  In processing the script statements from the user, there are TWO main things that the script tries to take care of:
  //   a) it tries to keep a set of available data fields current, based on whatever the user's script statement sought to do; and
  //   b) it reads/writes/moves files, etc - based on user's script commands
  //
  //   Here are the fields that this script processor tries to keep current as it goes:
  //
  //    S_FILESIZE: AnsiString;                // size of the in-focus Ref file
  //    S_LASTMODDT: AnsiString;               // last modified date of the currently-in-focus Ref file
  //    S_ATTRREADONLY: AnsiString;            //  Y in this means it is a READ ONLY file
  //    S_CURRRECORD: AnsiString;              //  the currently-in-focus record from the current Reference file
  //
  //    S_STATEEQUAL: AnsiString;               // F in this means NOT equal    (T means it WAS equal)
  //    S_STATELESSTHAN: AnsiString;            // F in this means NOT less than
  //    S_STATELESSTHANOREQUAL: AnsiString;     // F in this means NOT less than or equal to
  //    S_STATEGREATHERTHAN: AnsiString;        // F in this means NOT greater than
  //    S_STATEGREATERTHANOREQUAL: AnsiString;  // F in this means NOT greater than or equal to
  //    S_STATEFOUND: AnsiString;               // F in this means NOT found
  //
  //    S_STATEFOUNDPOSITION: Integer;          // if FOUND IN RECORD is true, this is the POSITION that it was found at
  //    S_CURRRECORDNUM: Integer;               // the NUMBER of the record that current has focus (within curr Ref file)
  //    S_REFFILENAME: AnsiString;              // the full filename of the in-focus Reference file
  //    S_REFFILESTEM: AnsiString;              // left (STEM) part of the filename for the in-focus Ref file
  //    S_REFFILEEXTENSION: AnsiString;         // right (Extension) part of the filenmae fo rthe in-focus Ref file
  //    S_RUNDATETIME: AnsiString;              // run date and time
  //    S_RUNDATE: AnsiString;                  // run date
  //    S_RUNTIME: AnsiString;                  // run time
  //    S_TEXT0, S_TEXT1, S_TEXT2, S_TEXT3, S_TEXT4, S_TEXT5, S_TEXT6, S_TEXT7, S_TEXT8, S_TEXT9: AnsiString;
  //
  lStatus.Caption := 'PPRECON Run was clicked';
  Application.ProcessMessages;
  Button1.Enabled := False;
  //
  // see if any rows in the stringgrid have show-stopper error codes, still... if some errors are there, we cannot continue
  countoferrors := 0;
  for i := 0 to StringGrid1.RowCount-1 Do
    begin
      if StringGrid1.Cells[0, i] <> '0' then countoferrors := countoferrors + 1;
    end;
  //
  if countoferrors > 0 then
    begin
      ShowMessage('SCRIPT ERROR(S) EXIST - CORRECTIONS NEEDED BEFORE WE CAN RUN THIS. Suggest you screen shot the errored line(s) - and update the script.  Then, try this program again.');
      GOTO NOGO;
    end;
  //
  XFIELDDELIM := ',';                                // default field delimiter value for output files that need it
  zros10 := '0000000000';
  spac4 := AnsiString(stringofchar(' ', 4));
  spac10 := AnsiString(stringofchar(' ', 10));
  //
  DateTimeToString(CurDt, 'yyyymmddhhnnsszz', Now);
  today := Now;
  //
  //
  //  set this group only once at start of the run:       gary - still need to fix these up
  //  S_RUNDATETIME: AnsiString;              // run date and time
  //  S_RUNDATE: AnsiString;                  // run date
  //  S_RUNTIME: AnsiString;                  // run time
  //
  //
 //
 // removing block of exec parameter stuff that involves company=    (might reenable it later)
 //
 // COMPANY := '';
 // If (findcmdlineswitch('company=banner') or findcmdlineswitch('Company=Banner') or findcmdlineswitch('COMPANY=BANNER')) Then
 //   begin
 //     COMPANY := '17';
 //     COTXT := 'Banner';
 //   end;
 // If (findcmdlineswitch('company=penn') or findcmdlineswitch('Company=Penn') or findcmdlineswitch('COMPANY=PENN')) Then
 //   begin
 //     COMPANY := 'WP';
 //     COTXT := 'Penn';
 //   end;
 //
 // if COMPANY = '' then
 //   begin
 //     lStatus.Caption := 'Run parameter for COMPANY is missing (example /company=banner).  ABORTING NOW';
 //     Application.ProcessMessages;
 //     ShowMessage('JOB FAILED WHEN SETTING COMPANY VALUE - CALL SUPPORT');
 //     close;
 //     Halt(0);
 //   end;
 //
 // commenting out MASS stuff for now
 //
 // workdir := LGAIni.ReadString(COTXT, 'Workarea', '') + 'MASS\Control\';
 //
 //If findcmdlineswitch('MASS') Then
 // begin
 //  wfolder := 'MASS';
 //  log := ttextfileout.Create(Format('%sPPRECON_%s.log', [WorkAreaUNC + 'MASS\Log\', CurDt]));
 //  log.Write(DtNow(Now) + 'Begin PPRECON program.');
 //  log.Write(DtNow(Now) + 'Exec parm says to work in folder: MASS\CONTROL');
 //  lStatus.Caption := 'Exec parm says to work in folder: MASS\CONTROL';
 //  Application.ProcessMessages;
 // end;
  //
  //
  //
  //
    //  InputBox('The precise DATA VALUE that I am to search for, please:',
	  //    '(put any value here - but we must have at least one byte of data)', '');
    //  InputBox('In WHAT COLUMN NUMBER (within each input record) should I search to find this data? (enter a FOUR-digit numeric, now).',
	  //    'Note: if your entered value exceeds record length, the SEARCH RESULT within that record will be default to Not Found.', '');
    //  InputBox('Now, must your sought data be EXACTLY in Col nnnn?  Answer YES here if the sought data MUST be in Col nnnn.  Answer EOR here if I should search from Col nnnn through End-of-Record for your sought data.',
	  //   'Alternatively - if you want ONLY a PORTION of the record to be searched for the sought data, enter another (higher) column number as the Search-End-Column value.', '');
    //
 //      InputBox('What is the PATH used to locate your SCRIPT file? (Full path.)  The script file is NOT updated during processing.',
 //	    'Note: More options regarding Script processing will be asked separately.', '');
    //
    //
 //      InputBox('Where should I put your Output File? (Full path.) The output will be like a CSV - but will actually be a PIPE-delimited txt file.).',
 //	     'Note: Output file will have file extension of TXT, and its Filename will be like: PPRECON_YYYYMMDD_TTTTTTT.Txt (so, date and time of run included in filename).', '');
      //
      // might add another user input to further qualify the READ files... maybe by Creation or Modified date or by filesize, or by *xxx* qualifier applied to first part of filename, ec
      // might also put some max-output limit... so, once we reach N "found" conditions, stop searching, etc...
      // might also let user specify some things about the Listbox that filled up as the program runs... maybe indicate whether to ONLY show situations where TRIGGER was found... instead of showing ALL of the data from all files
      // for the listbox that shows the inspected records - might remove that or might make it better show the sets of found data (background colors, or fonts, etc)
  ///
  ///
  ///
  ///
  // HERE, WE WILL ASK THE USER TO POINT DIRECTLY TO WHATEVER SCRIPT WE ARE TO USE.
  //
 //  openDialog := TOpenDialog.Create(self);
 //  openDialog.InitialDir := workdir;
 //  openDialog.Options := [ofFileMustExist];
 //  openDialog.Filter := ' all files|*.*';
 //  //
 //  ShowMessage('Select the SCRIPT file that specifies the processing needed.');
 //  lStatus.Caption := 'SELECT THE SCRIPT FILE, NOW';
 //  Application.ProcessMessages;
 //  //
 //  if openDialog.Execute then
 //    begin
 //     FworkTSL := TStringList.Create;
 //     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
 //     Sfilename := FworkTSL[FworkTSL.Count - 1];
 //     FworkTSL.free;
 //     // HERE, SET "PATH" TO BE EVERYTHING LEFT OF THE FILESPEC IN WHAT OUR USER JUST SELECTED
 //     Spath := copy(openDialog.FileName, 1, (Length(openDialog.FileName) - (Length(Sfilename))));
 //    end
 //   else
 //    begin
 //     lStatus.Caption := 'User canceled run instead of selecting a Script file.';
 //     log.Write(DtNow(Now) + 'User canceled run instead of selecting Script file.');
 //     Application.ProcessMessages;
 //     ShowMessage('Script file not provided; Run Aborted !');
 //     Halt(0);
 //    end;
 //  //
 //  log.Write(DtNow(Now) + 'User-selected location of SCRIPT file is:' + Sfilename);
 //  lStatus.Caption := 'Selected Script file is:' + Sfilename;
 //  //
 //  //
 //  ///
  ///
  ///
  ///
  // HERE, WE WILL ASK THE USER TO POINT DIRECTLY TO ONE OF THE FILES THAT WE WILL BE INTEROGATING.
  //
 //  openDialog := TOpenDialog.Create(self);
 //  openDialog.InitialDir := workdir;
 //  openDialog.Options := [ofFileMustExist];
 //  openDialog.Filter := ' all files|*.*';
 //  //
 // //
 //  ShowMessage('Select one of the reference files that this program will be interoating, now.');
 //  lStatus.Caption := 'SELECT ONE OF THE FILES TO INTEROGATE, NOW';
 //  Application.ProcessMessages;
 //  //
 //  if openDialog.Execute then
 //    begin
 //     FworkTSL := TStringList.Create;
 //     FworkTSL.Text := StringReplace(openDialog.FileName, '\', #13#10, [rfReplaceAll]);
 //     InptFNam := FworkTSL[FworkTSL.Count - 1];
 //     FworkTSL.free;
 //     // HERE, SET "PATH" TO BE EVERYTHING LEFT OF THE FILESPEC IN WHAT OUR USER JUST SELECTED
 //     Rpath := copy(openDialog.FileName, 1, (Length(openDialog.FileName) - (Length(InptFNam))));
 //    end
 //   else
 //    begin
 //     lStatus.Caption := 'User canceled run instead of selecting a Reference file.';
 //     log.Write(DtNow(Now) + 'User canceled run instead of selecting a Reference file.');
 //     Application.ProcessMessages;
 //    ShowMessage('Reference file not identified; Run Aborted !');
 //     Halt(0);
 //    end;
 // //
 //  log.Write(DtNow(Now) + 'User-selected location of REFERENCE files is:' + InptFNam);
 //  lStatus.Caption := 'Selected Reference file is:' + InptFNam;
 //  //
 //  //
  //RDIR := Rpath;
  //
  //RDIR := 'C:\Temp\';
  //
  //
  //
  //
  //
 //  ShowMessage('Select the folder where I should put OUTPUT, now.');
 //  lStatus.Caption := 'SELECT OUTPUT FOLDER';
 //  Application.ProcessMessages;
 //  //
 //  with TFileOpenDialog.Create(nil) do
 //  try
 //    Options := [fdoPickFolders];
 //    if Execute then
 //     begin
 //      Opath := (FileName);
 //     end
 //   else
 //    begin
 //     lStatus.Caption := 'User canceled run instead of selecting Output folder.';
 //     log.Write(DtNow(Now) + 'User canceled run instead of selecting Output folder.');
 //     Application.ProcessMessages;
 //     ShowMessage('Output folder not provided; Run Aborted !');
 //     Halt(0);
 //    end;
 //  finally
 //    Free;
 //  end;
 //  //ShowMessage(FileName);
 //  //ShowMessage(Opath);
 //  //
  //
  //
  //  THE BELOW BLOCK SHOWS HOW TO NAME OPEN AND ACCESS TXT FILES
  //
  //
  //     Var
  //    FINALO, TFile, SFile, TTFile, OFile, RFile: TextFile;
  //    workdir: AnsiString;
  //    tmpltnmI: AnsiString;
  //    tmpltnmO: AnsiString
  //    InptTnam: AnsiString;
  //    OutpTNam: AnsiString;
  //
  //
  //    //set filenames:
  //    tmpltnmI := Copy(STSL[0], 2, Lcellzero - 1);                         // capture the in-spreadsheet-row template name
  //    tmpltnmO := Copy(tmpltnmI, 1, Length(tmpltnmI) - 4) + '_OUTPUT_' + CurDt + Copy(tmpltnmI, Length(tmpltnmI) - 4 + 1, 4); // set OUTPUT file name for use with this template
  //    //
  //    // set the name of the template that needs to be opened - and open that input fle
  //    InptTNam := workdir + tmpltnmI;
  //    AssignFile(RFile, InptTNam);
  //    Reset(RFile);
  //    //
  //    // set output file name for the above Template and open this output (if file exists, open append)
  //    OutpTNam := workdir + tmpltnmO;
  //    AssignFile(OFile, OutpTNam);
  //    If FileExists(OutpTNam) Then
  //      Append(OFile)
  //    else
  //      ReWrite(OFile);
  //    //
  //:::
  //:::
  //    ReadLn(TFile, Trec);
  //   //
  //    WriteLn(OFile, Trec);
  //:::
  //:::
  //    CloseFile(TFile);
  //    CloseFile(OFile);
  //
  //
  //
  //
  //   AS A REMINDER, EACH ROW OF STRINGGRID1 HAS THESE COLUMNS:
  //    0) the error code that EDIT process developed (note: we could not be executing this script (RUN button) if ANY script row had errors... so these will all be zero)
  //    1) ROW number
  //    2) A value showing "line type" (such as Exec Parm or... Script Line, etc)
  //    3) COMMAND
  //    4) Remaining part of this script line (includes operands)
  //    5) Operand1 (if there was one in this script statement)
  //    6) Operand2 (if there was one in this script statement)
  //    7) Operand3 (if there was one in this script statement)
  //
  //
  //
  //   HERE, WE MUST SET BASIC JOB PARAMETERS SUCH AS PATHIN
  //   (here make an initial loop through the string grid looking for JOB-level items to set).
  //   We need to set items like this here: J_PATHIN, J_RPTFILENAME, J_PATHOUT1, J_FILTER
  //
  J_TEXTFIELDREPORTMAXBYTES := 0;
  //
  for i := 0 to StringGrid1.RowCount-1 Do
   begin
     if StringGrid1.Cells[3, i] = 'PATHIN:' then J_PATHIN := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'FILTER:' then J_FILTER := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'RPTTITLE:' then J_RPTTITLE := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'RPTNOTE:' then J_RPTNOTE := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'RPTFILENAME:' then J_RPTFILENAME := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'OF1FILENAME:' then J_OF1FILENAME := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'OF2FILENAME:' then J_OF2FILENAME := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'OF3FILENAME:' then J_OF3FILENAME := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'DELIMRPT:' then J_DELIMRPT := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'DELIM1:' then J_DELIM1 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'DELIM2:' then J_DELIM2 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'DELIM3:' then J_DELIM3 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'LIMITINFILES:' then J_LIMITINFILES := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'LIMITRPT:' then J_LIMITRPT := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'RPTWHENISAY:' then J_RPTWHENISAY := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'LOGFILENAME:' then J_LOGFILENAME := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'PATHOUT1:' then J_PATHOUT1 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'PATHOUT2:' then J_PATHOUT2 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'PATHOUT3:' then J_PATHOUT3 := StringGrid1.Cells[4, i];
     if StringGrid1.Cells[3, i] = 'TEXTFIELDREPORTMAXBYTES:' then J_TEXTFIELDREPORTMAXBYTES := StrToInt(Trim(StringGrid1.Cells[4, i]));
     if StringGrid1.Cells[3, i] = 'TROVE1:' then
       begin
         J_TROVE1CHK := StringGrid1.Cells[5, i];
         J_TROVE1RULE := StringGrid1.Cells[6, i];
         J_TROVE1MOV := StringGrid1.Cells[7, i];
         J_TROVE1 := TStringList.Create;
       end;
     if StringGrid1.Cells[3, i] = 'TROVE2:' then
       begin
         J_TROVE2CHK := StringGrid1.Cells[5, i];
         J_TROVE2RULE := StringGrid1.Cells[6, i];
         J_TROVE2MOV := StringGrid1.Cells[7, i];
         J_TROVE2 := TStringList.Create;
       end;
     if StringGrid1.Cells[3, i] = 'TROVE3:' then
       begin
         J_TROVE3CHK := StringGrid1.Cells[5, i];
         J_TROVE3RULE := StringGrid1.Cells[6, i];
         J_TROVE3MOV := StringGrid1.Cells[7, i];
         J_TROVE3 := TStringList.Create;
       end;

   end;
  //
  if COPY(J_PATHIN, Length(J_PATHIN) - 1, 1) <> '\' then J_PATHIN := J_PATHIN + '\';
  if COPY(J_PATHOUT1, Length(J_PATHOUT1) - 1, 1) <> '\' then J_PATHOUT1 := J_PATHOUT1 + '\';
  if COPY(J_PATHOUT2, Length(J_PATHOUT2) - 1, 1) <> '\' then J_PATHOUT2 := J_PATHOUT2 + '\';
  if COPY(J_PATHOUT3, Length(J_PATHOUT3) - 1, 1) <> '\' then J_PATHOUT3 := J_PATHOUT3 + '\';
  //
  //RDIR := J_PATHIN;
  //if RDIR = '' then RDIR := 'C:\Temp\';      //  gary temp code
  //
  //   GET ANY NEEDED DATA VIA SCREEN BACK-AND-FORTH    (if we really need to....)
  //
  //   MAKE LIST OF ALL QUALIFIED REF FILES: REFFILELIST    // see checked answer: https://stackoverflow.com/questions/11489680/list-all-files-from-a-directory-in-a-string-grid-with-delphi
  //
  REFFILESSL := TStringList.Create;
  GetRFiles(J_PATHIN, REFFILESSL, GRFresult);                                      // set the list of REF filenames we will process
  //
  //  OPEN THE OUTPUT FILE
  // gary - instead of actually working with a "file", change this to add any report line info to a stringlist... and at end of job, put that to an output report file
  //
 // if J_RPTFILENAME <> '' then
 //   begin
 //     tmpltnmO := J_RPTFILENAME;
 //     OutpTNam := J_PATHOUT1 + tmpltnmO;
 //     AssignFile(OFile, OutpTNam);
 //    try
 //     If FileExists(OutpTNam) Then
 //      Append(OFile)
 //     else
 //      ReWrite(OFile);
 //    except
 //     ShowMessage('Specified output location is invalid: ' + J_PATHOUT1 + tmpltnmO + '.  Job stopped now.');
 //     Halt(0);
 //    end;
 //
 //   end;
 //
 //
//  tmpltnmO := 'GARYOUT.TXT';                                           // set OUTPUT file name for use with this template
//  OutpTNam := J_PATHOUT1 + tmpltnmO;
//  AssignFile(OFile, OutpTNam);
//  try
//    If FileExists(OutpTNam) Then
//     Append(OFile)
//    else
//     ReWrite(OFile);
//  except
//    ShowMessage('Specified output location is invalid: ' + J_PATHOUT1 + tmpltnmO + '.  Job stopped now.');
//    Halt(0);
//  end;
  //WriteLn(OFile, 'test 2');
  //CloseFile(OFile);
  //ShowMessage('file is updated, now');
  //
  //
  J_REPORTLINE := TStringList.Create;
  if J_RPTTITLE <> '' then J_REPORTLINE.Add(J_RPTTITLE);
  if J_RPTNOTE <> '' then J_REPORTLINE.Add(J_RPTNOTE);
  //
  //
REFTOP:
  //
  //  IF NO MORE REF FILES TO PROCESS, BRANCH
  //
  if REFFILESSL.Count < 1 then goto REFFILESDONE;
  //
  //  SET NEXT REF FILENAME SO WE CAN BEGIN WORKING WITH THAT FILE
  //
  //CURRREFFILE := REFFILESSL[0];                                        // set this field to FIRST filenmame that is on the list
  S_REFFILENAME := REFFILESSL[0];                                        // set this field to FIRST filenmame that is on the list
  //
  //  GET ANY NEEDED DATA FROM THE FILENAME
  //
  S_REFFILEEXTENSION := ExtractFileExt(S_REFFILENAME);                     // set file extension
  //RFEXT := ExtractFileExt(S_REFFILENAME);                                // set file extension for this REF file
  RFSTEMLENGTH := Length(S_REFFILENAME) - Length(S_REFFILEEXTENSION);      // calc length of file stem for this REF file
  //RFSTEM := Copy(S_REFFILENAME, 1, RFSTEMLENGTH);                        // set the value of the stem
  S_REFFILESTEM := Copy(S_REFFILENAME, 1, RFSTEMLENGTH);                   // set stem value
  //
  //  GET DATA FROM FILE ATTRIBUTES
  //
  //RFSIZE := FileSizestr(RDIR+CURRREFFILE);
  //RFSIZE := FileSizestr(J_PATHIN+S_REFFILENAME);
  S_FILESIZE := FileSizestr(J_PATHIN+S_REFFILENAME);
  //
  //FileAge(RDIR + CURRREFFILE, FileDateI);                              // set FileDateI as the last modified date for this REF file
  FileAge(J_PATHIN + S_REFFILENAME, FileDateI);                          // set FileDateI as the last modified date for this REF file
  //RFLMODDT := SysUtils.DateTimeToStr(FileDateI);                       // get a displayable version of last modified date
  S_LASTMODDT := SysUtils.DateTimeToStr(FileDateI);                       // get a displayable version of last modified date
  //
  //
  ATTR := FileGetAttr(J_PATHIN + S_REFFILENAME);
  if ATTR and faReadOnly > 0 then S_ATTRREADONLY := 'Y' else S_ATTRREADONLY := 'N';
  //
  //
  //
  //  set proper internal fiels to zero now that we have moved to another REF file
  S_STATEFOUNDPOSITION := 0;                   // if FOUND IN RECORD is true, this is the POSITION that it was found at
  S_STATEFOUNDRECPOINTER := 0;                 // if FOUND is True, this is rec num of the recd where the Found was noted
  S_RECPOINTER := 0;                           // the NUMBER of the record that current has focus (within curr Ref file)
  S_PCKD0 := 0;
  S_PCKD1 := 0;
  S_PCKD2 := 0;
  S_PCKD3 := 0;
  S_PCKD4 := 0;
  S_PCKD5 := 0;
  S_PCKD6 := 0;
  S_PCKD7 := 0;
  S_PCKD8 := 0;
  S_PCKD9 := 0;
  //
  //      set these to null now that we are starting with a new REF file
  S_TEXT0 := '';
  S_TEXT1 := '';
  S_TEXT2 := '';
  S_TEXT3 := '';
  S_TEXT4 := '';
  S_TEXT5 := '';
  S_TEXT6 := '';
  S_TEXT7 := '';
  S_TEXT8 := '';
  S_TEXT9 := '';
  //
  //
  //
  //
  // gary - here, update the caption so user has progress info
  lStatus.Caption := IntToStr(REFFILESSL.Count) + ' files to go; working on:' + S_REFFILENAME + '; ';
 //     log.Write(DtNow(Now) + 'User canceled run instead of selecting Output folder.');
  Application.ProcessMessages;
  //
  //
  //
  //
  //
  //  HERE, DO ALL SCRIPT PROCESSING TO THIS REF FILE, BEFORE MOVING ON TO THE NEXT REF FILE
  //
  S_LINETRACKER := TStringList.Create;
  //
  //
  S_SPERR := 0;
  APPLYSCRIPT(S_REFFILENAME);                                           //  Apply script commands to current REF file
  //
  // gary - might be good to provide an easy way to call a DLL
  // gary  - might want to provide a GOTO which could force the job to halt after the current REF file examination is complete
  //
  //  DO TROVE ACCUMULATION AT THIS POINT
  //
  if J_TROVE1RULE <> '' then
    begin
      trovedata := '';
      gettrovedata(J_TROVE1CHK, J_TROVE1RULE, J_TROVE1MOV, trovedata, troverc);   //  set TROVEDATA to be whatever we are to add into this trove
      //if (trovedata <> '') and (troverc = 0) then J_TROVE1.Add(trovedata);
      if troverc = 0 then J_TROVE1.Add(trovedata);
    end;
  //
  if J_TROVE2RULE <> '' then
    begin
      trovedata := '';
      gettrovedata(J_TROVE2CHK, J_TROVE2RULE, J_TROVE2MOV, trovedata, troverc);   //  set TROVEDATA to be whatever we are to add into this trove
      //if (trovedata <> '') and (troverc = 0) then J_TROVE2.Add(trovedata);
      if troverc = 0 then J_TROVE2.Add(trovedata);
    end;
  //
  if J_TROVE3RULE <> '' then
    begin
      trovedata := '';
      gettrovedata(J_TROVE3CHK, J_TROVE3RULE, J_TROVE3MOV, trovedata, troverc);   //  set TROVEDATA to be whatever we are to add into this trove
      //if (trovedata <> '') and (troverc = 0) then J_TROVE3.Add(trovedata);
      if troverc = 0 then J_TROVE3.Add(trovedata);
    end;
  //
TROVEACCUMDONE:
  if (J_RPTWHENISAY = 'Y') or (J_RPTWHENISAY = '-') then goto NOPOSTPROCESSAUTOREPORT;
  //
  // At this point, check REPORTWHENISAY and if it allows, then create a post-file-processing "report" record (now that examination of this REF file is complete).
  // The output row will include these things:
  //  a) statement flow info (series of stmt numbers along with the return code that the execution of that stmt produced (S_SPERR))
  //  b) a capture of the up-to-J_TEXTFIELDREPORTMAXBYTES for EACH non-null %TEXT field (this is not included if NO %TEXT fields were used at all)
  //  c) a capture of text version of the field content for all %Pckd fields (this is not included if NO %Pckd fields were used at all)
  //  d) the name of the LABEL that was most recently engaged (while script lines were being processed)
  //  e) full content of the LAST script statement processed as this REF file was being examined/handled
  //  f) full content of the NEXT TO LAST script statement processed as this REF file was being examined/handled
  //  g) a copy of CURRENT value of all the "STATE" switches
  //  h) date and time of this report record's creation
  //  i) full path and filename of the REF file that was considered/examined by the script
  //
  // fulfillment notes for the above requierments are here:
  // for 'a' - these values are recorded in S_LINETRACKER as script is being processed, so just make it a report record segment, here:
  S_ReportRecord := '';
  //
  S_LINETRACKER.Delimiter := '~';
  S_ReportLT := 'LINETRACKER:' + S_LINETRACKER.DelimitedText;
  //
  S_ReportTF := 'TEXTFIELDS:';
  if S_TEXT0 <> '' then S_ReportTF := S_ReportTF + '%TEXT0=' + S_TEXT0;
  if S_TEXT1 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT1=' + S_TEXT1;
  if S_TEXT2 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT2=' + S_TEXT2;
  if S_TEXT3 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT3=' + S_TEXT3;
  if S_TEXT4 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT4=' + S_TEXT4;
  if S_TEXT5 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT5=' + S_TEXT5;
  if S_TEXT6 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT6=' + S_TEXT6;
  if S_TEXT7 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT7=' + S_TEXT7;
  if S_TEXT8 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT8=' + S_TEXT8;
  if S_TEXT9 <> '' then S_ReportTF := S_ReportTF + '~' + '%TEXT9=' + S_TEXT9;
  //
  //fieldtype := FieldDefs.Find(S_PCKD0).DataType;
  //
  S_ReportMRL := 'LASTLABEL:'+S_ReportMRL;
  //
  S_ReportNTLSSP := 'NEXTtoLASTstatement:' + S_ReportNTLSSP;
  S_ReportLSSP := 'LastStatement:' + S_ReportLSSP;
  //
  S_ReportStates := 'STATES:StateEqual=' + S_STATEEQUAL;
  S_ReportStates := S_ReportStates + '~' + 'StateLessThan=' + S_STATELESSTHAN;
  S_ReportStates := S_ReportStates + '~' + 'StateLessThanOrEqual=' + S_STATELESSTHANOREQUAL;
  S_ReportStates := S_ReportStates + '~' + 'StateGreaterThan=' + S_STATEGREATERTHAN;
  S_ReportStates := S_ReportStates + '~' + 'StateGreaterThanOrEqual=' + S_STATEGREATERTHANOREQUAL;
  S_ReportStates := S_ReportStates + '~' + 'StateFound=' + S_STATEFOUND;
  //
  S_ReportRecord := S_ReportLT + J_DELIMRPT + S_ReportTF + J_DELIMRPT + S_ReportMRL + J_DELIMRPT + S_ReportLSSP + J_DELIMRPT;
  S_ReportRecord := S_ReportRecord + S_ReportNTLSSP + J_DELIMRPT + S_ReportStates + J_DELIMRPT + 'REF FILE:' + J_PATHIN + S_REFFILENAME;
  //
  J_REPORTLINE.Add(S_ReportRecord);  // add an output row to output report now
  //
  //
NOPOSTPROCESSAUTOREPORT:
  //
  //
  if S_SPERR < 7 then
   begin
    GOTO KEEPON1;
   end;
     //                                                                // here - we have encountered a severe script error - need to shut down entire job
  GOTO SCRIPTSEVERE;
  //
KEEPON1:
  if S_SPERR < 1 then GOTO KEEPONX;
  //                                                                   // here, we handle script errs that arent severe enough to call for immediate shutdown
KEEPONX:
  //
  // REMOVE TOP ENTRY FROM REFFILELIST:       (to destroy only the first item in a stringlist, making the second one now be the first:
  try
    REFFILESSL.Delete(0);                               //remove the in-focus file from the list so we can move on to the next REF file
  except
    ShowMessage('Job failed when removing item from REF files list.');
  end;
  //
  S_LINETRACKER.Free;
  //
  goto REFTOP;
  //
  //
REFFILESDONE:
  //
  //
  // HAVE FINISHED LOOKING AT ALL THE REF FILES - SO, NOW HANDLE ANY POST PROCESSING THAT IS NEEDED
  //
  // SUMMARIZE AS NEEDED
  //
  //
  J_REPORTLINE.SaveToFile(J_PATHOUT1 + J_RPTFILENAME + '.TXT');
  J_REPORTLINE.Free;
  //
  if Assigned(J_TROVE1) then
    begin
    J_TROVE1.SaveToFile(J_PATHOUT1 + 'TROVE1' + '.TXT');
    J_TROVE1.Free;
    end;
  //
  if Assigned(J_TROVE2) then
    begin
    J_TROVE2.SaveToFile(J_PATHOUT1 + 'TROVE2' + '.TXT');
    J_TROVE2.Free;
    end;
  //
  if Assigned(J_TROVE3) then
    begin
    J_TROVE3.SaveToFile(J_PATHOUT1 + 'TROVE3' + '.TXT');
    J_TROVE3.Free;
    end;
  //
  //
  //
  //
  //
  //
  //  THIS INFO IS TO DOC HOW THE PROCESS WILL WORK:
  //
  //   OPEN EXTRACT FILE
  //    //set filenames:
  //    tmpltnmI := Copy(STSL[0], 2, Lcellzero - 1);                         // capture the in-spreadsheet-row template name
  //
  // REFTOP:
  //
  //   IF REFFILELIST HAS NO ENTRIES IN IT, GO TO REFFILESDONE:  // if MyStringList.Count = 0 then goto REFFILESDONE
  //
  //   SET S_REFFILENAME TO FIRST FILENAME IN REFFILELIST
  //
  //   PERFORM REFFILENAMEDISECTION
  //                            // get file extension and filename_sans_extension: https://docwiki.embarcadero.com/Libraries/Sydney/en/System.SysUtils.ExtractFileName
  //                            // if requested, disect the filename_sans_extension based on a filename_node_separator, and set any user sought data fields based on result
  //
  //   PERFORM REFFILEATTRIBS   // to get attribs like READONLY, etc: http://www.delphibasics.co.uk/RTL.php?Name=filegetattr
  //                            // to get last modified date: http://www.delphibasics.co.uk/RTL.php?Name=FileAge
  //                            // to get filesize: see checked solution at: https://stackoverflow.com/questions/6066896/why-do-i-get-an-invalid-handle-error-using-getfilesizeex-with-files-marked-r
  //
  //   IF REFCONTENTNEEDED, PERFORM REFINSIDE                       (can construct this later)
  //
  //   IF CUSTOMEXTRACTISNEEDED PERFORM BUILDCUSTOMEXTRACT           (can construct this later - just do BUILDEXTRACT for now)
  //    ELSE PEFORM BUILDEXTRACT
  //
  //   WRITE EXTRACT
  //
  //   REMOVE TOP ENTRY FROM REFFILELIST      (to destroy only the first item in a stringlist, making the second one now be the first:
  //                                         try
  //                                            MyStringList.Delete(0);
  //                                         finally
  //                                            ShowMessage('All done removing the REF list entry.');
  //                                         end;
  //
  //   GO TO REFTOP:
  //
  // REFFILESDONE:
  //
  //
  //
  line := spac10;
  RECMX := spac10;
  RECM2 := spac10;
  RECM1 := spac10;
  REC0 := spac10;
  RECPLUS1 := spac10;
  RECPLUS2 := spac10;
  sep := '======';
  Triggered := 'N';

  qualified := 0;

  if FindFirst(Rpath + '*.txt', faAnyFile, SR) = 0 then
  begin
    repeat
      if (SR.Attr <> faDirectory) then
      begin
        AssignFile(tempFile, Rpath + SR.Name);
        Reset(tempFile);
        while not Eof(tempFile) do
        begin
          Readln(tempFile, line);
          //
          if Triggered = 'Y' then
            begin

              if RECPLUS1 = spac10 then
                 begin
                   RECPLUS1 := line;
                   GOTO NEXT;
                 end;

              RECPLUS2 := line;


             // Canvass := ListBox1.Canvas;
             // Canvass.Brush.Color := TColor(ListBox1.Items[Index]);
             // Canvass.FillRect(Rect);
             // S := ListBox.Items[Index];




              // write the whole enchilada output record at this point   (this is a CSV record, but is delimited by PIPE)

              // To the listbox, add RECM2, RECM1, REC0, RECPLUS1, RECPLUS2 (add them in standout font or backgrnd color)
              self.Font.Color := clBlue;
              //ListBox1.Canvas.TextOut( Rect.Left, Rect.Top, ListBox1.Items[Index] );
              ListBox1.Canvas.Font.Color := clGreen;
              self.ListBox1.Font.Style := [fsBold];








              //Form1.Font.Color := clRed;     // this changed message at bottom of form to be red
              self.ListBox1.Canvas.Font.Color := clRed;



              self.ListBox1.Canvas.Pen.Color := clWhite;


              //Form1.Font.Name := 'Times New Roman';   //This changed the Status message at bottom to be T N R
              //Form1.ListBox1.Font.Name := 'Times New Roman';    // This changed ALL rows in listbox to be T N R
              ListBox1.Items.Add(sep);
              ListBox1.Items.Add(RECM2);


              Canvass := ListBox1.Canvas;
              Canvass.Brush.Color := TColor(ListBox1.Items[Index]);

              ListBox1.Canvas.Brush.Color := clGreen;

              //Canvass.FillRect(Rect);
              //S := ListBox.Items[Index];





              ListBox1.Items.Add(RECM1);
              ListBox1.Items.Add(REC0);
              ListBox1.Items.Add(RECPLUS1);
              ListBox1.Items.Add(RECPLUS2);
              ListBox1.Items.Add(spac10);
              ListBox1.Font.Color := clBlack;
              self.ListBox1.Font.Style := [];
              Application.ProcessMessages;
              //
              RECPLUS1 := spac10;
              RECPLUS2 := spac10;
              RECM2 := '';
              RECM1 := '';
              REC0 := '';
              //
              Triggered := 'N';
              //
              GOTO NEXT;
              //
            end;
          RECMX := RECM2;
          RECM2 := RECM1;
          RECM1 := REC0;
          REC0 := line;
          Triggered := 'N';
          ///
          ///    have not coded up the ChkTrig routine yet - so, these lines are just to have something we could set TRIGGERED sw with
          ///
          //P := Pos('00577976S20220412_0000000003W                   AI            18P', line);               // TEMP CODE
          //if P > 0 then Triggered := 'Y';    // TEMP CODE
          //P := Pos('00577976F20220412_0000000011X                   AI            18P', line);
          //if P > 0 then Triggered := 'Y';
          Q := Pos('C1301', line);
          if Q = 1 then Triggered := 'Y';            // find any record with C1301 in col 1 ... if find it, then mark this as one we want

          if Triggered = 'Y' then
           begin
            qualified := qualified + 1;
            if qualified > 39103 then
             begin
              log.Write(DtNow(Now) + copy(line, 1, 25));  // write it to log for now
              Application.ProcessMessages;
             end;
           end;

          ///
          ///
          //ChkTrig for REC0 now //(see if 'line' has proper stuff to cause a data catpure now... if so, set Triggered to Y)
          ///
          ///
          if RECMX <> '' then
            begin
              ListBox1.Items.Add(RECMX);
              Application.ProcessMessages;
            end;
          //
        NEXT:
          //
        end;
        lStatus.Caption := 'Reached end of file:' + InptFNam;
        //   when each of the read files runs out of records, we do the following:
          if Triggered = 'Y' then
            begin
              //
              log.Write(DtNow(Now) + copy(line, 1, 25));
              // write the whole enchilada output record at this point   (this is a CSV record, but is delimited by PIPE)
              //
              // To the listbox, add RECM2, RECM1, REC0, RECPLUS1, RECPLUS2 (add them in standout font or backgrnd color)
              ListBox1.Items.Add(sep);
              ListBox1.Items.Add(RECM2);
              ListBox1.Items.Add(RECM1);
              ListBox1.Items.Add(REC0);
              ListBox1.Items.Add(RECPLUS1);
              ListBox1.Items.Add(RECPLUS2);
            end
          else
            begin
              ListBox1.Items.Add(RECM2);
              ListBox1.Items.Add(RECM1);
              ListBox1.Items.Add(REC0);
            end;
        //
      end;
      //
    until FindNext(SR) <> 0;
    // once we get to this spot, it means that we've finished looking at ALL of the files that we were to consider
    FindClose(SR);
  end;
  //  here, we should LOG the overall results
NOGO:
    //ShowMessage('Arrived at NOGO label.');
    //Button1.Enabled := True;         // electing to leave button enabled and leave script showing on screen (so user can see what stuff to fix)
    GOTO GO;
    //
SCRIPTSEVERE:
    ShowMessage('Arrived at SCRIPTSEVERE label.');
    //
    GOTO GO;
    //
GO:
 End;




procedure Tppreconform.FormCreate(Sender: TObject);
var
 //CurDt: String;    del
  result: Integer;
  //delayseconds: Integer;
  i: Integer;
  //ExecParm: AnsiString;
  //
begin
  FCount := 10;
  Randomize;
  //
  CancelAUTORUN.Enabled := False;            // assume that auto-run is not enabled
  AutoContinue := 'N';                       // assume that auto-run is not enabled
  //
  StringGrid1.DefaultDrawing := True;
  //
  //StringGrid1.DefaultDrawing := False;
  //
  //
  //
  //Ppath := ExtractFilePath(ParamStr(0));              // pick up the location where we are running from
  //
  delayseconds := 0;                                  // assume that our auto-run delay amount will be zero seconds
  AITOUSE := '';                                      // no DEFAULT application ini will be in use... so, user must supply it (via exec parameter)
  //
  //
 // here, determine which Application INI to run with - by looking at run parameters
 //
 //
 // here, set number of DELAY seconds (based on exec parm) - and this will num secnds will give user chance to halt/modify setup when job starts
 //
  EXECPARM := '';
  ParmData := TStringList.Create;         // use this to split an execu parameter into segment-before-equal-sign and segment after
  for i := 0 to ParamCount do
   begin
    //ShowMessage('Parameter '+IntToStr(i)+' = '+ParamStr(i));
    if i = 0 then PPTH := ParamStr(i);
    if i <> 0 then
     begin
      //
      EXECPARM := EXECPARM + ParamStr(i) + ' ';
      //
      Split(ParamStr(i), '=', ParmData) ;  //split an execu parameter into segment-before-equal-sign and segment after
      //
      result := AnsiCompareText('/runafterdelay', ParmData[0]);   // Case INsensitive string compare
      if result = 0 then
       begin
        delayseconds := strtoint(ParmData[1]);   // Set DelaySeconds based on the provided execution parm
        CancelAUTORUN.Enabled := True;
        AutoContinue := 'Y';
       end;
      //
      result := AnsiCompareText('/applini', ParmData[0]);   // Case INsensitive string compare
      if result = 0 then AITOUSE := ParmData[1];            // Set location to get Application INI file from
     end;
   end;
  //
  if FileExists(AITOUSE) then
     begin
     end
   else
     begin
      ShowMessage('JOB FAILED. Application INI is required, but provided location not valid or not accessable: ' + AITOUSE);
      close;
      Halt(0);
     end;
  //
   TimeOut := IncSecond(Now, delayseconds);
   Timer1.Enabled := True;
   Label1.Caption := SecsToHmsStr(SecondsBetween(Now, TimeOut));
   //
   //Showmessage('made it here');
  //
  //
end;






procedure Tppreconform.FormDestroy(Sender: TObject);
begin
    log.Free;
end;






Procedure Tppreconform.FormShow(Sender: tObject);
Begin
  Button1.Enabled := True;
 //
End;




procedure Tppreconform.OnActivate(Sender: TObject);
//var
//S: AnsiString; del
//i: Integer; del
//NativeI: NativeInt; del
//NativeS: String;  del
//testdata: String;

begin
 DateTimeToString(J_RUNDATETIME, 'yyyymmddhhnnsszz', Now);
 S_RUNDATETIME := (DtNow(Now) + '');
 S_RUNDATE := (DtNow(Now) + '');
 S_RUNTIME := (DtNow(Now) + '');
 //
 DoWaitx(J_RUNDATETIME);
 //
 FillGrid(EXECPARM, PPTH, AITOUSE, StringGrid1, script);
 //
 if (AutoContinue = 'Y') then
   begin
      CancelAUTORUN.Enabled := False;            // turn this off now that it has done it's job
      AutoContinue := 'N';                       // turn this off now that it has done it's job
      Button1Click(Self.Button1);                // CLICK THE RUN BUTTON AUTOMATICALLY
   end;
 //
 //StringGrid1.Font.Color := clGreen;
 //StringGrid1.Tag := 22;
 // for i := 0 to StringGrid1.RowCount-5 Do     // GARY MINUS 5?
 //   begin
 //       //NativeS := IntToStr(StatementErrorCodes[i]);
 //       //NativeI := NativeInt(StatementErrorCodes[i]);
 //       //StringGrid1.Tag := NativeInt(StatementErrorCodes[i]);
 //       if StrToInt(StatementError[i]) <> 0 then showmessage('row ' + IntToStr(i) + ' has error per OnActivate');
 //       StringGrid1.Tag := NativeInt(StrToInt(StatementError[i]));
 //       //StringGrid1.InvalidateRow(i);
 //       StringGrid1.Invalidate;
 //       //TStringGridAccess(StringGrid1).InvalidateRow(i);
 //       //testdata := StringGrid1[1];
 //       //if StringGrid1.Tag <> 0 then ShowMessage('tag is nonzero:'+S);
 //       //StringGrid1.Tag := StatementErrorCodes[i];
 //       //
 //       //
 //       //
 //       //
 //       //S := StringGrid1.Cells[1, i];
 //       //if StringGrid1.Tag <> 0 then ShowMessage('tag is nonzero:'+S);
 //       //
 //  //      // gary, the below line did NOT cause a refresh on the stringgrid...
 //       //StringGrid1.Cells[1, i] := S;
 //       //
 //       //
 //  //StringGrid1.Canvas.Font.Color := FG[ACol, ARow];
 //  //StringGrid1.TextOut(Rect.Left + 2, Rect.Top + 2, S);
 //  end;


 //FillGrid(StringGrid1, ExecParm, ppth, aitouse, script);
 //
 //StringGrid1.DefaultDrawing := False;
 //
end;




//procedure Tppreconform.StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;  Rect: TRect; State: TGridDrawState; ErrColl: Integer);
procedure Tppreconform.StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;
 Rect: TRect; State: TGridDrawState);

var
mycolor: Tcolor;
targetrow: Integer;
targetcollumn: Integer;
RectForText: TRect;
S: String;
RC: String;

begin
  //targetrow := 2;
  //targetcollumn := 3;
  targetrow := 0;
  targetcollumn := 0;
  //if (myBooleanState) and (ACol = 3) and (ARow = 2) then
  mycolor := clWebKhaki;
  S := StringGrid1.Cells[ACol, ARow];
  RC := StringGrid1.Cells[0, ARow];
  //if StringGrid1.Font.Color = clGreen then
  //begin
  // targetrow := 9;
  //end;
  //
  //showmessage('about to check Tag value within SGDC');
  //if (StringGrid1.Tag <> 0) then showmessage('row ' + IntToStr(ARow) + ' has error per SGDC');
  //
  //if (StringGrid1.Tag = ARow) and (ARow <> 0) then
  if (ACol > 2) and (RC <> '0') then
   begin
    targetrow := ARow;
   end;
  //if (ACol = targetcollumn) and (ARow = targetrow) then
  if (ARow = targetrow) and (Length(StringGrid1.Cells[1, ARow]) <> 0) then
   begin
    mycolor := clred;
    if ARow = 0 then mycolor := clMoneyGreen;
   end;
  //if StringGrid1.Tag = ARow then targetrow := ARow;

  //if (ErrColl > 0) then
  // begin
  //  mycolor := clblue;
  // end;
  //if (ARow > 27) then
  // begin
  //  mycolor := clgreen;
  // end;

  //if (ACol = 3) and (ARow = 2) then
 // if (ARow = 2) then
  if (ACol >= 0) then
    with TStringGrid(Sender) do
   begin
      //paint the background red
      Canvas.Brush.Color := mycolor;
      Canvas.FillRect(Rect);
    //
 //     Canvas.Font.Color := clAqua;
      RectForText := Rect;
    // Make the rectangle where the text will be displayed a bit smaller than the cell
    // so the text is not "glued" to the grid lines
      InflateRect(RectForText, -2, -2);
    // Edit: using TextRect instead of TextOut to prevent overflowing of text
      Canvas.TextRect(RectForText, S);
    //
      //FG[ACol, ARow] := clAqua;
   //Canvas.Font.Color := clAqua;
      //Canvas.Font.Color := clOrange;
      //if StringGrid1.Font.Color = clGreen then targetrow := 9;Canvas.Font.Color := clWhite;
   //Canvas.TextOut(Rect.Left+2,Rect.Top+2,Cells[ACol, ARow]);




   end;
  //
  //if Canvas.Brush.Color <> clRed then
   // begin
    //  //paint the background blue
     // Canvas.Brush.Color := clblue;
      //Canvas.FillRect(Rect);
      //Canvas.TextOut(Rect.Left+2,Rect.Top+2,Cells[ACol, ARow]);
    //end;
 //StringGrid1.Invalidate;
end;

//procedure Tppreconform.StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;
//  Rect: TRect; State: TGridDrawState);
//begin
  //Canvas.font.Color := TAlphaColorRec.Green;
  //Canvas.FillText(Bounds, (Value.AsString),
  //  false, 100, [], TTextAlign.taLeading, TTextAlign.taCenter);
//  Rect := Bounds;
//  Rect.Left := Rect.Left + 2;
//  Canvas.Font.Style := [TFontStyle.fsBold];
//  Canvas.Fill.Color := TAlphaColorRec.Black;
//  Canvas.FillText(Rect, (Value.AsString), false, 100, [], TTextAlign.taLeading, TTextAlign.taCenter);

//end;

procedure Tppreconform.Timer1Timer(Sender: TObject);
begin
  Label1.Caption := SecsToHmsStr(SecondsBetween(Now, TimeOut));
  if Now > Timeout then Timer1.Enabled := False;
end;

End.

       COPY WAPPLCPY REPLACING
                   WAPPL-CALL-PARAMETERS  BY WNOTE-CALL-PARAMETERS
                   WAPPL-FUNCTION         BY WNOTE-FUNCTION
                   WAPPL-KEY-NUMBER       BY WNOTE-KEY-NUMBER
                   WAPPL-RETURN-CODE      BY WNOTE-RETURN-CODE
